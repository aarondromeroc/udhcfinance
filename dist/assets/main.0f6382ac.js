function Vn(s) {
  if (s === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return s;
}
function Pd(s, e) {
  (s.prototype = Object.create(e.prototype)),
    (s.prototype.constructor = s),
    (s.__proto__ = e);
}
/*!
 * GSAP 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Qt = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  Fr = { duration: 0.5, overwrite: !1, delay: 0 },
  bl,
  Et,
  tt,
  un = 1e8,
  je = 1 / un,
  qo = Math.PI * 2,
  Fh = qo / 4,
  kh = 0,
  Ld = Math.sqrt,
  zh = Math.cos,
  Bh = Math.sin,
  vt = function (e) {
    return typeof e == "string";
  },
  nt = function (e) {
    return typeof e == "function";
  },
  $n = function (e) {
    return typeof e == "number";
  },
  wl = function (e) {
    return typeof e == "undefined";
  },
  Ln = function (e) {
    return typeof e == "object";
  },
  kt = function (e) {
    return e !== !1;
  },
  Tl = function () {
    return typeof window != "undefined";
  },
  Vs = function (e) {
    return nt(e) || vt(e);
  },
  Rd =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  At = Array.isArray,
  Xo = /(?:-?\.?\d|\.)+/gi,
  Dd = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  Er = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  $a = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  Id = /[+-]=-?[.\d]+/,
  Od = /[^,'"\[\]\s]+/gi,
  Vh = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  Ze,
  sn,
  jo,
  El,
  en = {},
  Ma = {},
  Nd,
  Ud = function (e) {
    return (Ma = Yi(e, en)) && Ht;
  },
  Al = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  Ss = function (e, t) {
    return !t && console.warn(e);
  },
  Fd = function (e, t) {
    return (e && (en[e] = t) && Ma && (Ma[e] = t)) || en;
  },
  Ms = function () {
    return 0;
  },
  Gh = { suppressEvents: !0, isStart: !0, kill: !1 },
  ga = { suppressEvents: !0, kill: !1 },
  Hh = { suppressEvents: !0 },
  Cl = {},
  _i = [],
  Yo = {},
  kd,
  Yt = {},
  Ka = {},
  uc = 30,
  _a = [],
  Pl = "",
  Ll = function (e) {
    var t = e[0],
      n,
      i;
    if ((Ln(t) || nt(t) || (e = [e]), !(n = (t._gsap || {}).harness))) {
      for (i = _a.length; i-- && !_a[i].targetTest(t); );
      n = _a[i];
    }
    for (i = e.length; i--; )
      (e[i] && (e[i]._gsap || (e[i]._gsap = new cf(e[i], n)))) ||
        e.splice(i, 1);
    return e;
  },
  Hi = function (e) {
    return e._gsap || Ll(dn(e))[0]._gsap;
  },
  zd = function (e, t, n) {
    return (n = e[t]) && nt(n)
      ? e[t]()
      : (wl(n) && e.getAttribute && e.getAttribute(t)) || n;
  },
  zt = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  st = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  _t = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  Lr = function (e, t) {
    var n = t.charAt(0),
      i = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
    );
  },
  Wh = function (e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
    return i < n;
  },
  ba = function () {
    var e = _i.length,
      t = _i.slice(0),
      n,
      i;
    for (Yo = {}, _i.length = 0, n = 0; n < e; n++)
      (i = t[n]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
  },
  Bd = function (e, t, n, i) {
    _i.length && !Et && ba(),
      e.render(t, n, i || (Et && t < 0 && (e._initted || e._startAt))),
      _i.length && !Et && ba();
  },
  Vd = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(Od).length < 2
      ? t
      : vt(e)
      ? e.trim()
      : e;
  },
  Gd = function (e) {
    return e;
  },
  fn = function (e, t) {
    for (var n in t) n in e || (e[n] = t[n]);
    return e;
  },
  qh = function (e) {
    return function (t, n) {
      for (var i in n)
        i in t || (i === "duration" && e) || i === "ease" || (t[i] = n[i]);
    };
  },
  Yi = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  dc = function s(e, t) {
    for (var n in t)
      n !== "__proto__" &&
        n !== "constructor" &&
        n !== "prototype" &&
        (e[n] = Ln(t[n]) ? s(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e;
  },
  wa = function (e, t) {
    var n = {},
      i;
    for (i in e) i in t || (n[i] = e[i]);
    return n;
  },
  gs = function (e) {
    var t = e.parent || Ze,
      n = e.keyframes ? qh(At(e.keyframes)) : fn;
    if (kt(e.inherit))
      for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  Xh = function (e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; );
    return n < 0;
  },
  Hd = function (e, t, n, i, r) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var a = e[i],
      o;
    if (r) for (o = t[r]; a && a[r] > o; ) a = a._prev;
    return (
      a ? ((t._next = a._next), (a._next = t)) : ((t._next = e[n]), (e[n] = t)),
      t._next ? (t._next._prev = t) : (e[i] = t),
      (t._prev = a),
      (t.parent = t._dp = e),
      t
    );
  },
  Oa = function (e, t, n, i) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var r = t._prev,
      a = t._next;
    r ? (r._next = a) : e[n] === t && (e[n] = a),
      a ? (a._prev = r) : e[i] === t && (e[i] = r),
      (t._next = t._prev = t.parent = null);
  },
  yi = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  Wi = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
    return e;
  },
  jh = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  $o = function (e, t, n, i) {
    return (
      e._startAt &&
      (Et
        ? e._startAt.revert(ga)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, i))
    );
  },
  Yh = function s(e) {
    return !e || (e._ts && s(e.parent));
  },
  fc = function (e) {
    return e._repeat ? kr(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  kr = function (e, t) {
    var n = Math.floor((e /= t));
    return e && n === e ? n - 1 : n;
  },
  Ta = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  Na = function (e) {
    return (e._end = _t(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || je) || 0)
    ));
  },
  Ua = function (e, t) {
    var n = e._dp;
    return (
      n &&
        n.smoothChildTiming &&
        e._ts &&
        ((e._start = _t(
          n._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        Na(e),
        n._dirty || Wi(n, e)),
      e
    );
  },
  Wd = function (e, t) {
    var n;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((n = Ta(e.rawTime(), t)),
        (!t._dur || Us(0, t.totalDuration(), n) - t._tTime > je) &&
          t.render(n, !0)),
      Wi(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (n = e; n._dp; )
          n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
      e._zTime = -je;
    }
  },
  bn = function (e, t, n, i) {
    return (
      t.parent && yi(t),
      (t._start = _t(
        ($n(n) ? n : n || e !== Ze ? rn(e, n, t) : e._time) + t._delay
      )),
      (t._end = _t(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      Hd(e, t, "_first", "_last", e._sort ? "_start" : 0),
      Ko(t) || (e._recent = t),
      i || Wd(e, t),
      e._ts < 0 && Ua(e, e._tTime),
      e
    );
  },
  qd = function (e, t) {
    return (
      (en.ScrollTrigger || Al("scrollTrigger", t)) &&
      en.ScrollTrigger.create(t, e)
    );
  },
  Xd = function (e, t, n, i, r) {
    if ((Dl(e, t, r), !e._initted)) return 1;
    if (
      !n &&
      e._pt &&
      !Et &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      kd !== Kt.frame
    )
      return _i.push(e), (e._lazy = [r, i]), 1;
  },
  $h = function s(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t));
  },
  Ko = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  Kh = function (e, t, n, i) {
    var r = e.ratio,
      a =
        t < 0 ||
        (!t &&
          ((!e._start && $h(e) && !(!e._initted && Ko(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !Ko(e))))
          ? 0
          : 1,
      o = e._rDelay,
      l = 0,
      c,
      u,
      d;
    if (
      (o &&
        e._repeat &&
        ((l = Us(0, e._tDur, t)),
        (u = kr(l, o)),
        e._yoyo && u & 1 && (a = 1 - a),
        u !== kr(e._tTime, o) &&
          ((r = 1 - a), e.vars.repeatRefresh && e._initted && e.invalidate())),
      a !== r || Et || i || e._zTime === je || (!t && e._zTime))
    ) {
      if (!e._initted && Xd(e, t, i, n, l)) return;
      for (
        d = e._zTime,
          e._zTime = t || (n ? je : 0),
          n || (n = t && !d),
          e.ratio = a,
          e._from && (a = 1 - a),
          e._time = 0,
          e._tTime = l,
          c = e._pt;
        c;

      )
        c.r(a, c.d), (c = c._next);
      t < 0 && $o(e, t, n, !0),
        e._onUpdate && !n && Zt(e, "onUpdate"),
        l && e._repeat && !n && e.parent && Zt(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === a &&
          (a && yi(e, 1),
          !n &&
            !Et &&
            (Zt(e, a ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  Zh = function (e, t, n) {
    var i;
    if (n > t)
      for (i = e._first; i && i._start <= n; ) {
        if (i.data === "isPause" && i._start > t) return i;
        i = i._next;
      }
    else
      for (i = e._last; i && i._start >= n; ) {
        if (i.data === "isPause" && i._start < t) return i;
        i = i._prev;
      }
  },
  zr = function (e, t, n, i) {
    var r = e._repeat,
      a = _t(t) || 0,
      o = e._tTime / e._tDur;
    return (
      o && !i && (e._time *= a / e._dur),
      (e._dur = a),
      (e._tDur = r ? (r < 0 ? 1e10 : _t(a * (r + 1) + e._rDelay * r)) : a),
      o > 0 && !i && Ua(e, (e._tTime = e._tDur * o)),
      e.parent && Na(e),
      n || Wi(e.parent, e),
      e
    );
  },
  hc = function (e) {
    return e instanceof Ot ? Wi(e) : zr(e, e._dur);
  },
  Jh = { _start: 0, endTime: Ms, totalDuration: Ms },
  rn = function s(e, t, n) {
    var i = e.labels,
      r = e._recent || Jh,
      a = e.duration() >= un ? r.endTime(!1) : e._dur,
      o,
      l,
      c;
    return vt(t) && (isNaN(t) || t in i)
      ? ((l = t.charAt(0)),
        (c = t.substr(-1) === "%"),
        (o = t.indexOf("=")),
        l === "<" || l === ">"
          ? (o >= 0 && (t = t.replace(/=/, "")),
            (l === "<" ? r._start : r.endTime(r._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (c ? (o < 0 ? r : n).totalDuration() / 100 : 1))
          : o < 0
          ? (t in i || (i[t] = a), i[t])
          : ((l = parseFloat(t.charAt(o - 1) + t.substr(o + 1))),
            c && n && (l = (l / 100) * (At(n) ? n[0] : n).totalDuration()),
            o > 1 ? s(e, t.substr(0, o - 1), n) + l : a + l))
      : t == null
      ? a
      : +t;
  },
  _s = function (e, t, n) {
    var i = $n(t[1]),
      r = (i ? 2 : 1) + (e < 2 ? 0 : 1),
      a = t[r],
      o,
      l;
    if ((i && (a.duration = t[1]), (a.parent = n), e)) {
      for (o = a, l = n; l && !("immediateRender" in o); )
        (o = l.vars.defaults || {}), (l = kt(l.vars.inherit) && l.parent);
      (a.immediateRender = kt(o.immediateRender)),
        e < 2 ? (a.runBackwards = 1) : (a.startAt = t[r - 1]);
    }
    return new lt(t[0], a, t[r + 1]);
  },
  Mi = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  Us = function (e, t, n) {
    return n < e ? e : n > t ? t : n;
  },
  Tt = function (e, t) {
    return !vt(e) || !(t = Vh.exec(e)) ? "" : t[1];
  },
  Qh = function (e, t, n) {
    return Mi(n, function (i) {
      return Us(e, t, i);
    });
  },
  Zo = [].slice,
  jd = function (e, t) {
    return (
      e &&
      Ln(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Ln(e[0]))) &&
      !e.nodeType &&
      e !== sn
    );
  },
  ep = function (e, t, n) {
    return (
      n === void 0 && (n = []),
      e.forEach(function (i) {
        var r;
        return (vt(i) && !t) || jd(i, 1)
          ? (r = n).push.apply(r, dn(i))
          : n.push(i);
      }) || n
    );
  },
  dn = function (e, t, n) {
    return tt && !t && tt.selector
      ? tt.selector(e)
      : vt(e) && !n && (jo || !Br())
      ? Zo.call((t || El).querySelectorAll(e), 0)
      : At(e)
      ? ep(e, n)
      : jd(e)
      ? Zo.call(e, 0)
      : e
      ? [e]
      : [];
  },
  Jo = function (e) {
    return (
      (e = dn(e)[0] || Ss("Invalid scope") || {}),
      function (t) {
        var n = e.current || e.nativeElement || e;
        return dn(
          t,
          n.querySelectorAll
            ? n
            : n === e
            ? Ss("Invalid scope") || El.createElement("div")
            : e
        );
      }
    );
  },
  Yd = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  $d = function (e) {
    if (nt(e)) return e;
    var t = Ln(e) ? e : { each: e },
      n = qi(t.ease),
      i = t.from || 0,
      r = parseFloat(t.base) || 0,
      a = {},
      o = i > 0 && i < 1,
      l = isNaN(i) || o,
      c = t.axis,
      u = i,
      d = i;
    return (
      vt(i)
        ? (u = d = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
        : !o && l && ((u = i[0]), (d = i[1])),
      function (f, h, _) {
        var m = (_ || t).length,
          g = a[m],
          p,
          y,
          v,
          x,
          S,
          w,
          A,
          C,
          M;
        if (!g) {
          if (((M = t.grid === "auto" ? 0 : (t.grid || [1, un])[1]), !M)) {
            for (
              A = -un;
              A < (A = _[M++].getBoundingClientRect().left) && M < m;

            );
            M < m && M--;
          }
          for (
            g = a[m] = [],
              p = l ? Math.min(M, m) * u - 0.5 : i % M,
              y = M === un ? 0 : l ? (m * d) / M - 0.5 : (i / M) | 0,
              A = 0,
              C = un,
              w = 0;
            w < m;
            w++
          )
            (v = (w % M) - p),
              (x = y - ((w / M) | 0)),
              (g[w] = S = c ? Math.abs(c === "y" ? x : v) : Ld(v * v + x * x)),
              S > A && (A = S),
              S < C && (C = S);
          i === "random" && Yd(g),
            (g.max = A - C),
            (g.min = C),
            (g.v = m =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (M > m
                    ? m - 1
                    : c
                    ? c === "y"
                      ? m / M
                      : M
                    : Math.max(M, m / M)) ||
                0) * (i === "edges" ? -1 : 1)),
            (g.b = m < 0 ? r - m : r),
            (g.u = Tt(t.amount || t.each) || 0),
            (n = n && m < 0 ? af(n) : n);
        }
        return (
          (m = (g[f] - g.min) / g.max || 0),
          _t(g.b + (n ? n(m) : m) * g.v) + g.u
        );
      }
    );
  },
  Qo = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (n) {
      var i = _t(Math.round(parseFloat(n) / e) * e * t);
      return (i - (i % 1)) / t + ($n(n) ? 0 : Tt(n));
    };
  },
  Kd = function (e, t) {
    var n = At(e),
      i,
      r;
    return (
      !n &&
        Ln(e) &&
        ((i = n = e.radius || un),
        e.values
          ? ((e = dn(e.values)), (r = !$n(e[0])) && (i *= i))
          : (e = Qo(e.increment))),
      Mi(
        t,
        n
          ? nt(e)
            ? function (a) {
                return (r = e(a)), Math.abs(r - a) <= i ? r : a;
              }
            : function (a) {
                for (
                  var o = parseFloat(r ? a.x : a),
                    l = parseFloat(r ? a.y : 0),
                    c = un,
                    u = 0,
                    d = e.length,
                    f,
                    h;
                  d--;

                )
                  r
                    ? ((f = e[d].x - o), (h = e[d].y - l), (f = f * f + h * h))
                    : (f = Math.abs(e[d] - o)),
                    f < c && ((c = f), (u = d));
                return (
                  (u = !i || c <= i ? e[u] : a),
                  r || u === a || $n(a) ? u : u + Tt(a)
                );
              }
          : Qo(e)
      )
    );
  },
  Zd = function (e, t, n, i) {
    return Mi(At(e) ? !t : n === !0 ? !!(n = 0) : !i, function () {
      return At(e)
        ? e[~~(Math.random() * e.length)]
        : (n = n || 1e-5) &&
            (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) *
                n *
                i
            ) / i;
    });
  },
  tp = function () {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return function (i) {
      return t.reduce(function (r, a) {
        return a(r);
      }, i);
    };
  },
  np = function (e, t) {
    return function (n) {
      return e(parseFloat(n)) + (t || Tt(n));
    };
  },
  ip = function (e, t, n) {
    return Qd(e, t, 0, 1, n);
  },
  Jd = function (e, t, n) {
    return Mi(n, function (i) {
      return e[~~t(i)];
    });
  },
  rp = function s(e, t, n) {
    var i = t - e;
    return At(e)
      ? Jd(e, s(0, e.length), t)
      : Mi(n, function (r) {
          return ((i + ((r - e) % i)) % i) + e;
        });
  },
  sp = function s(e, t, n) {
    var i = t - e,
      r = i * 2;
    return At(e)
      ? Jd(e, s(0, e.length - 1), t)
      : Mi(n, function (a) {
          return (a = (r + ((a - e) % r)) % r || 0), e + (a > i ? r - a : a);
        });
  },
  bs = function (e) {
    for (var t = 0, n = "", i, r, a, o; ~(i = e.indexOf("random(", t)); )
      (a = e.indexOf(")", i)),
        (o = e.charAt(i + 7) === "["),
        (r = e.substr(i + 7, a - i - 7).match(o ? Od : Xo)),
        (n +=
          e.substr(t, i - t) + Zd(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5)),
        (t = a + 1);
    return n + e.substr(t, e.length - t);
  },
  Qd = function (e, t, n, i, r) {
    var a = t - e,
      o = i - n;
    return Mi(r, function (l) {
      return n + (((l - e) / a) * o || 0);
    });
  },
  ap = function s(e, t, n, i) {
    var r = isNaN(e + t)
      ? 0
      : function (h) {
          return (1 - h) * e + h * t;
        };
    if (!r) {
      var a = vt(e),
        o = {},
        l,
        c,
        u,
        d,
        f;
      if ((n === !0 && (i = 1) && (n = null), a))
        (e = { p: e }), (t = { p: t });
      else if (At(e) && !At(t)) {
        for (u = [], d = e.length, f = d - 2, c = 1; c < d; c++)
          u.push(s(e[c - 1], e[c]));
        d--,
          (r = function (_) {
            _ *= d;
            var m = Math.min(f, ~~_);
            return u[m](_ - m);
          }),
          (n = t);
      } else i || (e = Yi(At(e) ? [] : {}, e));
      if (!u) {
        for (l in t) Rl.call(o, e, l, "get", t[l]);
        r = function (_) {
          return Nl(_, o) || (a ? e.p : e);
        };
      }
    }
    return Mi(n, r);
  },
  pc = function (e, t, n) {
    var i = e.labels,
      r = un,
      a,
      o,
      l;
    for (a in i)
      (o = i[a] - t),
        o < 0 == !!n && o && r > (o = Math.abs(o)) && ((l = a), (r = o));
    return l;
  },
  Zt = function (e, t, n) {
    var i = e.vars,
      r = i[t],
      a = tt,
      o = e._ctx,
      l,
      c,
      u;
    if (!!r)
      return (
        (l = i[t + "Params"]),
        (c = i.callbackScope || e),
        n && _i.length && ba(),
        o && (tt = o),
        (u = l ? r.apply(c, l) : r.call(c)),
        (tt = a),
        u
      );
  },
  ds = function (e) {
    return (
      yi(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!Et),
      e.progress() < 1 && Zt(e, "onInterrupt"),
      e
    );
  },
  Ar,
  ef = [],
  tf = function (e) {
    if (Tl() && e) {
      e = (!e.name && e.default) || e;
      var t = e.name,
        n = nt(e),
        i =
          t && !n && e.init
            ? function () {
                this._props = [];
              }
            : e,
        r = {
          init: Ms,
          render: Nl,
          add: Rl,
          kill: Mp,
          modifier: Sp,
          rawVars: 0,
        },
        a = { targetTest: 0, get: 0, getSetter: Ol, aliases: {}, register: 0 };
      if ((Br(), e !== i)) {
        if (Yt[t]) return;
        fn(i, fn(wa(e, r), a)),
          Yi(i.prototype, Yi(r, wa(e, a))),
          (Yt[(i.prop = t)] = i),
          e.targetTest && (_a.push(i), (Cl[t] = 1)),
          (t =
            (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
            "Plugin");
      }
      Fd(t, i), e.register && e.register(Ht, i, Bt);
    } else e && ef.push(e);
  },
  qe = 255,
  fs = {
    aqua: [0, qe, qe],
    lime: [0, qe, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, qe],
    navy: [0, 0, 128],
    white: [qe, qe, qe],
    olive: [128, 128, 0],
    yellow: [qe, qe, 0],
    orange: [qe, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [qe, 0, 0],
    pink: [qe, 192, 203],
    cyan: [0, qe, qe],
    transparent: [qe, qe, qe, 0],
  },
  Za = function (e, t, n) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (n - t) * e * 6
        : e < 0.5
        ? n
        : e * 3 < 2
        ? t + (n - t) * (2 / 3 - e) * 6
        : t) *
        qe +
        0.5) |
        0
    );
  },
  nf = function (e, t, n) {
    var i = e ? ($n(e) ? [e >> 16, (e >> 8) & qe, e & qe] : 0) : fs.black,
      r,
      a,
      o,
      l,
      c,
      u,
      d,
      f,
      h,
      _;
    if (!i) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), fs[e]))
        i = fs[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((r = e.charAt(1)),
            (a = e.charAt(2)),
            (o = e.charAt(3)),
            (e =
              "#" +
              r +
              r +
              a +
              a +
              o +
              o +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (i = parseInt(e.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & qe, i & qe, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (i = [e >> 16, (e >> 8) & qe, e & qe]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((i = _ = e.match(Xo)), !t))
          (l = (+i[0] % 360) / 360),
            (c = +i[1] / 100),
            (u = +i[2] / 100),
            (a = u <= 0.5 ? u * (c + 1) : u + c - u * c),
            (r = u * 2 - a),
            i.length > 3 && (i[3] *= 1),
            (i[0] = Za(l + 1 / 3, r, a)),
            (i[1] = Za(l, r, a)),
            (i[2] = Za(l - 1 / 3, r, a));
        else if (~e.indexOf("="))
          return (i = e.match(Dd)), n && i.length < 4 && (i[3] = 1), i;
      } else i = e.match(Xo) || fs.transparent;
      i = i.map(Number);
    }
    return (
      t &&
        !_ &&
        ((r = i[0] / qe),
        (a = i[1] / qe),
        (o = i[2] / qe),
        (d = Math.max(r, a, o)),
        (f = Math.min(r, a, o)),
        (u = (d + f) / 2),
        d === f
          ? (l = c = 0)
          : ((h = d - f),
            (c = u > 0.5 ? h / (2 - d - f) : h / (d + f)),
            (l =
              d === r
                ? (a - o) / h + (a < o ? 6 : 0)
                : d === a
                ? (o - r) / h + 2
                : (r - a) / h + 4),
            (l *= 60)),
        (i[0] = ~~(l + 0.5)),
        (i[1] = ~~(c * 100 + 0.5)),
        (i[2] = ~~(u * 100 + 0.5))),
      n && i.length < 4 && (i[3] = 1),
      i
    );
  },
  rf = function (e) {
    var t = [],
      n = [],
      i = -1;
    return (
      e.split(vi).forEach(function (r) {
        var a = r.match(Er) || [];
        t.push.apply(t, a), n.push((i += a.length + 1));
      }),
      (t.c = n),
      t
    );
  },
  mc = function (e, t, n) {
    var i = "",
      r = (e + i).match(vi),
      a = t ? "hsla(" : "rgba(",
      o = 0,
      l,
      c,
      u,
      d;
    if (!r) return e;
    if (
      ((r = r.map(function (f) {
        return (
          (f = nf(f, t, 1)) &&
          a +
            (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) +
            ")"
        );
      })),
      n && ((u = rf(e)), (l = n.c), l.join(i) !== u.c.join(i)))
    )
      for (c = e.replace(vi, "1").split(Er), d = c.length - 1; o < d; o++)
        i +=
          c[o] +
          (~l.indexOf(o)
            ? r.shift() || a + "0,0,0,0)"
            : (u.length ? u : r.length ? r : n).shift());
    if (!c)
      for (c = e.split(vi), d = c.length - 1; o < d; o++) i += c[o] + r[o];
    return i + c[d];
  },
  vi = (function () {
    var s =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in fs) s += "|" + e + "\\b";
    return new RegExp(s + ")", "gi");
  })(),
  op = /hsl[a]?\(/,
  sf = function (e) {
    var t = e.join(" "),
      n;
    if (((vi.lastIndex = 0), vi.test(t)))
      return (
        (n = op.test(t)),
        (e[1] = mc(e[1], n)),
        (e[0] = mc(e[0], n, rf(e[1]))),
        !0
      );
  },
  ws,
  Kt = (function () {
    var s = Date.now,
      e = 500,
      t = 33,
      n = s(),
      i = n,
      r = 1e3 / 240,
      a = r,
      o = [],
      l,
      c,
      u,
      d,
      f,
      h,
      _ = function m(g) {
        var p = s() - i,
          y = g === !0,
          v,
          x,
          S,
          w;
        if (
          (p > e && (n += p - t),
          (i += p),
          (S = i - n),
          (v = S - a),
          (v > 0 || y) &&
            ((w = ++d.frame),
            (f = S - d.time * 1e3),
            (d.time = S = S / 1e3),
            (a += v + (v >= r ? 4 : r - v)),
            (x = 1)),
          y || (l = c(m)),
          x)
        )
          for (h = 0; h < o.length; h++) o[h](S, f, w, g);
      };
    return (
      (d = {
        time: 0,
        frame: 0,
        tick: function () {
          _(!0);
        },
        deltaRatio: function (g) {
          return f / (1e3 / (g || 60));
        },
        wake: function () {
          Nd &&
            (!jo &&
              Tl() &&
              ((sn = jo = window),
              (El = sn.document || {}),
              (en.gsap = Ht),
              (sn.gsapVersions || (sn.gsapVersions = [])).push(Ht.version),
              Ud(Ma || sn.GreenSockGlobals || (!sn.gsap && sn) || {}),
              (u = sn.requestAnimationFrame),
              ef.forEach(tf)),
            l && d.sleep(),
            (c =
              u ||
              function (g) {
                return setTimeout(g, (a - d.time * 1e3 + 1) | 0);
              }),
            (ws = 1),
            _(2));
        },
        sleep: function () {
          (u ? sn.cancelAnimationFrame : clearTimeout)(l), (ws = 0), (c = Ms);
        },
        lagSmoothing: function (g, p) {
          (e = g || 1 / 0), (t = Math.min(p || 33, e));
        },
        fps: function (g) {
          (r = 1e3 / (g || 240)), (a = d.time * 1e3 + r);
        },
        add: function (g, p, y) {
          var v = p
            ? function (x, S, w, A) {
                g(x, S, w, A), d.remove(v);
              }
            : g;
          return d.remove(g), o[y ? "unshift" : "push"](v), Br(), v;
        },
        remove: function (g, p) {
          ~(p = o.indexOf(g)) && o.splice(p, 1) && h >= p && h--;
        },
        _listeners: o,
      }),
      d
    );
  })(),
  Br = function () {
    return !ws && Kt.wake();
  },
  Oe = {},
  lp = /^[\d.\-M][\d.\-,\s]/,
  cp = /["']/g,
  up = function (e) {
    for (
      var t = {},
        n = e.substr(1, e.length - 3).split(":"),
        i = n[0],
        r = 1,
        a = n.length,
        o,
        l,
        c;
      r < a;
      r++
    )
      (l = n[r]),
        (o = r !== a - 1 ? l.lastIndexOf(",") : l.length),
        (c = l.substr(0, o)),
        (t[i] = isNaN(c) ? c.replace(cp, "").trim() : +c),
        (i = l.substr(o + 1).trim());
    return t;
  },
  dp = function (e) {
    var t = e.indexOf("(") + 1,
      n = e.indexOf(")"),
      i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
  },
  fp = function (e) {
    var t = (e + "").split("("),
      n = Oe[t[0]];
    return n && t.length > 1 && n.config
      ? n.config.apply(
          null,
          ~e.indexOf("{") ? [up(t[1])] : dp(e).split(",").map(Vd)
        )
      : Oe._CE && lp.test(e)
      ? Oe._CE("", e)
      : n;
  },
  af = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  of = function s(e, t) {
    for (var n = e._first, i; n; )
      n instanceof Ot
        ? s(n, t)
        : n.vars.yoyoEase &&
          (!n._yoyo || !n._repeat) &&
          n._yoyo !== t &&
          (n.timeline
            ? s(n.timeline, t)
            : ((i = n._ease),
              (n._ease = n._yEase),
              (n._yEase = i),
              (n._yoyo = t))),
        (n = n._next);
  },
  qi = function (e, t) {
    return (e && (nt(e) ? e : Oe[e] || fp(e))) || t;
  },
  nr = function (e, t, n, i) {
    n === void 0 &&
      (n = function (l) {
        return 1 - t(1 - l);
      }),
      i === void 0 &&
        (i = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        });
    var r = { easeIn: t, easeOut: n, easeInOut: i },
      a;
    return (
      zt(e, function (o) {
        (Oe[o] = en[o] = r), (Oe[(a = o.toLowerCase())] = n);
        for (var l in r)
          Oe[
            a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
          ] = Oe[o + "." + l] = r[l];
      }),
      r
    );
  },
  lf = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  Ja = function s(e, t, n) {
    var i = t >= 1 ? t : 1,
      r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      a = (r / qo) * (Math.asin(1 / i) || 0),
      o = function (u) {
        return u === 1 ? 1 : i * Math.pow(2, -10 * u) * Bh((u - a) * r) + 1;
      },
      l =
        e === "out"
          ? o
          : e === "in"
          ? function (c) {
              return 1 - o(1 - c);
            }
          : lf(o);
    return (
      (r = qo / r),
      (l.config = function (c, u) {
        return s(e, c, u);
      }),
      l
    );
  },
  Qa = function s(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function (a) {
        return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
      },
      i =
        e === "out"
          ? n
          : e === "in"
          ? function (r) {
              return 1 - n(1 - r);
            }
          : lf(n);
    return (
      (i.config = function (r) {
        return s(e, r);
      }),
      i
    );
  };
zt("Linear,Quad,Cubic,Quart,Quint,Strong", function (s, e) {
  var t = e < 5 ? e + 1 : e;
  nr(
    s + ",Power" + (t - 1),
    e
      ? function (n) {
          return Math.pow(n, t);
        }
      : function (n) {
          return n;
        },
    function (n) {
      return 1 - Math.pow(1 - n, t);
    },
    function (n) {
      return n < 0.5
        ? Math.pow(n * 2, t) / 2
        : 1 - Math.pow((1 - n) * 2, t) / 2;
    }
  );
});
Oe.Linear.easeNone = Oe.none = Oe.Linear.easeIn;
nr("Elastic", Ja("in"), Ja("out"), Ja());
(function (s, e) {
  var t = 1 / e,
    n = 2 * t,
    i = 2.5 * t,
    r = function (o) {
      return o < t
        ? s * o * o
        : o < n
        ? s * Math.pow(o - 1.5 / e, 2) + 0.75
        : o < i
        ? s * (o -= 2.25 / e) * o + 0.9375
        : s * Math.pow(o - 2.625 / e, 2) + 0.984375;
    };
  nr(
    "Bounce",
    function (a) {
      return 1 - r(1 - a);
    },
    r
  );
})(7.5625, 2.75);
nr("Expo", function (s) {
  return s ? Math.pow(2, 10 * (s - 1)) : 0;
});
nr("Circ", function (s) {
  return -(Ld(1 - s * s) - 1);
});
nr("Sine", function (s) {
  return s === 1 ? 1 : -zh(s * Fh) + 1;
});
nr("Back", Qa("in"), Qa("out"), Qa());
Oe.SteppedEase =
  Oe.steps =
  en.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e,
          i = e + (t ? 0 : 1),
          r = t ? 1 : 0,
          a = 1 - je;
        return function (o) {
          return (((i * Us(0, a, o)) | 0) + r) * n;
        };
      },
    };
Fr.ease = Oe["quad.out"];
zt(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (s) {
    return (Pl += s + "," + s + "Params,");
  }
);
var cf = function (e, t) {
    (this.id = kh++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : zd),
      (this.set = t ? t.getSetter : Ol);
  },
  Ts = (function () {
    function s(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        zr(this, +t.duration, 1, 1),
        (this.data = t.data),
        tt && ((this._ctx = tt), tt.data.push(this)),
        ws || Kt.wake();
    }
    var e = s.prototype;
    return (
      (e.delay = function (n) {
        return n || n === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + n - this._delay),
            (this._delay = n),
            this)
          : this._delay;
      }),
      (e.duration = function (n) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (n) {
        return arguments.length
          ? ((this._dirty = 0),
            zr(
              this,
              this._repeat < 0
                ? n
                : (n - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (n, i) {
        if ((Br(), !arguments.length)) return this._tTime;
        var r = this._dp;
        if (r && r.smoothChildTiming && this._ts) {
          for (Ua(this, n), !r._dp || r.parent || Wd(r, this); r && r.parent; )
            r.parent._time !==
              r._start +
                (r._ts >= 0
                  ? r._tTime / r._ts
                  : (r.totalDuration() - r._tTime) / -r._ts) &&
              r.totalTime(r._tTime, !0),
              (r = r.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && n < this._tDur) ||
              (this._ts < 0 && n > 0) ||
              (!this._tDur && !n)) &&
            bn(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== n ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === je) ||
            (!n && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = n), Bd(this, n, i)),
          this
        );
      }),
      (e.time = function (n, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), n + fc(this)) %
                (this._dur + this._rDelay) || (n ? this._dur : 0),
              i
            )
          : this._time;
      }),
      (e.totalProgress = function (n, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * n, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (e.progress = function (n, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) +
                fc(this),
              i
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (e.iteration = function (n, i) {
        var r = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (n - 1) * r, i)
          : this._repeat
          ? kr(this._tTime, r) + 1
          : 1;
      }),
      (e.timeScale = function (n, i) {
        if (!arguments.length) return this._rts === -je ? 0 : this._rts;
        if (this._rts === n) return this;
        var r =
          this.parent && this._ts ? Ta(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +n || 0),
          (this._ts = this._ps || n === -je ? 0 : this._rts),
          this.totalTime(Us(-Math.abs(this._delay), this._tDur, r), i !== !1),
          Na(this),
          jh(this)
        );
      }),
      (e.paused = function (n) {
        return arguments.length
          ? (this._ps !== n &&
              ((this._ps = n),
              n
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Br(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== je &&
                      (this._tTime -= je)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (n) {
        if (arguments.length) {
          this._start = n;
          var i = this.parent || this._dp;
          return (
            i && (i._sort || !this.parent) && bn(i, this, n - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (n) {
        return (
          this._start +
          (kt(n) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (n) {
        var i = this.parent || this._dp;
        return i
          ? n &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? Ta(i.rawTime(n), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (n) {
        n === void 0 && (n = Hh);
        var i = Et;
        return (
          (Et = n),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(n),
            this.totalTime(-0.01, n.suppressEvents)),
          this.data !== "nested" && n.kill !== !1 && this.kill(),
          (Et = i),
          this
        );
      }),
      (e.globalTime = function (n) {
        for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
          (r = i._start + r / (Math.abs(i._ts) || 1)), (i = i._dp);
        return !this.parent && this._sat ? this._sat.globalTime(n) : r;
      }),
      (e.repeat = function (n) {
        return arguments.length
          ? ((this._repeat = n === 1 / 0 ? -2 : n), hc(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (n) {
        if (arguments.length) {
          var i = this._time;
          return (this._rDelay = n), hc(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (n) {
        return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
      }),
      (e.seek = function (n, i) {
        return this.totalTime(rn(this, n), kt(i));
      }),
      (e.restart = function (n, i) {
        return this.play().totalTime(n ? -this._delay : 0, kt(i));
      }),
      (e.play = function (n, i) {
        return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (n, i) {
        return (
          n != null && this.seek(n || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (n, i) {
        return n != null && this.seek(n, i), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (n) {
        return arguments.length
          ? (!!n !== this.reversed() &&
              this.timeScale(-this._rts || (n ? -je : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -je), this;
      }),
      (e.isActive = function () {
        var n = this.parent || this._dp,
          i = this._start,
          r;
        return !!(
          !n ||
          (this._ts &&
            this._initted &&
            n.isActive() &&
            (r = n.rawTime(!0)) >= i &&
            r < this.endTime(!0) - je)
        );
      }),
      (e.eventCallback = function (n, i, r) {
        var a = this.vars;
        return arguments.length > 1
          ? (i
              ? ((a[n] = i),
                r && (a[n + "Params"] = r),
                n === "onUpdate" && (this._onUpdate = i))
              : delete a[n],
            this)
          : a[n];
      }),
      (e.then = function (n) {
        var i = this;
        return new Promise(function (r) {
          var a = nt(n) ? n : Gd,
            o = function () {
              var c = i.then;
              (i.then = null),
                nt(a) && (a = a(i)) && (a.then || a === i) && (i.then = c),
                r(a),
                (i.then = c);
            };
          (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? o()
            : (i._prom = o);
        });
      }),
      (e.kill = function () {
        ds(this);
      }),
      s
    );
  })();
fn(Ts.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -je,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var Ot = (function (s) {
  Pd(e, s);
  function e(n, i) {
    var r;
    return (
      n === void 0 && (n = {}),
      (r = s.call(this, n) || this),
      (r.labels = {}),
      (r.smoothChildTiming = !!n.smoothChildTiming),
      (r.autoRemoveChildren = !!n.autoRemoveChildren),
      (r._sort = kt(n.sortChildren)),
      Ze && bn(n.parent || Ze, Vn(r), i),
      n.reversed && r.reverse(),
      n.paused && r.paused(!0),
      n.scrollTrigger && qd(Vn(r), n.scrollTrigger),
      r
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (i, r, a) {
      return _s(0, arguments, this), this;
    }),
    (t.from = function (i, r, a) {
      return _s(1, arguments, this), this;
    }),
    (t.fromTo = function (i, r, a, o) {
      return _s(2, arguments, this), this;
    }),
    (t.set = function (i, r, a) {
      return (
        (r.duration = 0),
        (r.parent = this),
        gs(r).repeatDelay || (r.repeat = 0),
        (r.immediateRender = !!r.immediateRender),
        new lt(i, r, rn(this, a), 1),
        this
      );
    }),
    (t.call = function (i, r, a) {
      return bn(this, lt.delayedCall(0, i, r), a);
    }),
    (t.staggerTo = function (i, r, a, o, l, c, u) {
      return (
        (a.duration = r),
        (a.stagger = a.stagger || o),
        (a.onComplete = c),
        (a.onCompleteParams = u),
        (a.parent = this),
        new lt(i, a, rn(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (i, r, a, o, l, c, u) {
      return (
        (a.runBackwards = 1),
        (gs(a).immediateRender = kt(a.immediateRender)),
        this.staggerTo(i, r, a, o, l, c, u)
      );
    }),
    (t.staggerFromTo = function (i, r, a, o, l, c, u, d) {
      return (
        (o.startAt = a),
        (gs(o).immediateRender = kt(o.immediateRender)),
        this.staggerTo(i, r, o, l, c, u, d)
      );
    }),
    (t.render = function (i, r, a) {
      var o = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        c = this._dur,
        u = i <= 0 ? 0 : _t(i),
        d = this._zTime < 0 != i < 0 && (this._initted || !c),
        f,
        h,
        _,
        m,
        g,
        p,
        y,
        v,
        x,
        S,
        w,
        A;
      if (
        (this !== Ze && u > l && i >= 0 && (u = l), u !== this._tTime || a || d)
      ) {
        if (
          (o !== this._time &&
            c &&
            ((u += this._time - o), (i += this._time - o)),
          (f = u),
          (x = this._start),
          (v = this._ts),
          (p = !v),
          d && (c || (o = this._zTime), (i || !r) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((w = this._yoyo),
            (g = c + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(g * 100 + i, r, a);
          if (
            ((f = _t(u % g)),
            u === l
              ? ((m = this._repeat), (f = c))
              : ((m = ~~(u / g)),
                m && m === u / g && ((f = c), m--),
                f > c && (f = c)),
            (S = kr(this._tTime, g)),
            !o &&
              this._tTime &&
              S !== m &&
              this._tTime - S * g - this._dur <= 0 &&
              (S = m),
            w && m & 1 && ((f = c - f), (A = 1)),
            m !== S && !this._lock)
          ) {
            var C = w && S & 1,
              M = C === (w && m & 1);
            if (
              (m < S && (C = !C),
              (o = C ? 0 : u % c ? c : u),
              (this._lock = 1),
              (this.render(o || (A ? 0 : _t(m * g)), r, !c)._lock = 0),
              (this._tTime = u),
              !r && this.parent && Zt(this, "onRepeat"),
              this.vars.repeatRefresh && !A && (this.invalidate()._lock = 1),
              (o && o !== this._time) ||
                p !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((c = this._dur),
              (l = this._tDur),
              M &&
                ((this._lock = 2),
                (o = C ? c : -1e-4),
                this.render(o, !0),
                this.vars.repeatRefresh && !A && this.invalidate()),
              (this._lock = 0),
              !this._ts && !p)
            )
              return this;
            of(this, A);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((y = Zh(this, _t(o), _t(f))), y && (u -= f - (f = y._start))),
          (this._tTime = u),
          (this._time = f),
          (this._act = !v),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (o = 0)),
          !o && f && !r && !m && (Zt(this, "onStart"), this._tTime !== u))
        )
          return this;
        if (f >= o && i >= 0)
          for (h = this._first; h; ) {
            if (
              ((_ = h._next), (h._act || f >= h._start) && h._ts && y !== h)
            ) {
              if (h.parent !== this) return this.render(i, r, a);
              if (
                (h.render(
                  h._ts > 0
                    ? (f - h._start) * h._ts
                    : (h._dirty ? h.totalDuration() : h._tDur) +
                        (f - h._start) * h._ts,
                  r,
                  a
                ),
                f !== this._time || (!this._ts && !p))
              ) {
                (y = 0), _ && (u += this._zTime = -je);
                break;
              }
            }
            h = _;
          }
        else {
          h = this._last;
          for (var b = i < 0 ? i : f; h; ) {
            if (((_ = h._prev), (h._act || b <= h._end) && h._ts && y !== h)) {
              if (h.parent !== this) return this.render(i, r, a);
              if (
                (h.render(
                  h._ts > 0
                    ? (b - h._start) * h._ts
                    : (h._dirty ? h.totalDuration() : h._tDur) +
                        (b - h._start) * h._ts,
                  r,
                  a || (Et && (h._initted || h._startAt))
                ),
                f !== this._time || (!this._ts && !p))
              ) {
                (y = 0), _ && (u += this._zTime = b ? -je : je);
                break;
              }
            }
            h = _;
          }
        }
        if (
          y &&
          !r &&
          (this.pause(),
          (y.render(f >= o ? 0 : -je)._zTime = f >= o ? 1 : -1),
          this._ts)
        )
          return (this._start = x), Na(this), this.render(i, r, a);
        this._onUpdate && !r && Zt(this, "onUpdate", !0),
          ((u === l && this._tTime >= this.totalDuration()) || (!u && o)) &&
            (x === this._start || Math.abs(v) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !c) &&
                ((u === l && this._ts > 0) || (!u && this._ts < 0)) &&
                yi(this, 1),
              !r &&
                !(i < 0 && !o) &&
                (u || o || !l) &&
                (Zt(
                  this,
                  u === l && i >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(u < l && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (i, r) {
      var a = this;
      if (($n(r) || (r = rn(this, r, i)), !(i instanceof Ts))) {
        if (At(i))
          return (
            i.forEach(function (o) {
              return a.add(o, r);
            }),
            this
          );
        if (vt(i)) return this.addLabel(i, r);
        if (nt(i)) i = lt.delayedCall(0, i);
        else return this;
      }
      return this !== i ? bn(this, i, r) : this;
    }),
    (t.getChildren = function (i, r, a, o) {
      i === void 0 && (i = !0),
        r === void 0 && (r = !0),
        a === void 0 && (a = !0),
        o === void 0 && (o = -un);
      for (var l = [], c = this._first; c; )
        c._start >= o &&
          (c instanceof lt
            ? r && l.push(c)
            : (a && l.push(c), i && l.push.apply(l, c.getChildren(!0, r, a)))),
          (c = c._next);
      return l;
    }),
    (t.getById = function (i) {
      for (var r = this.getChildren(1, 1, 1), a = r.length; a--; )
        if (r[a].vars.id === i) return r[a];
    }),
    (t.remove = function (i) {
      return vt(i)
        ? this.removeLabel(i)
        : nt(i)
        ? this.killTweensOf(i)
        : (Oa(this, i),
          i === this._recent && (this._recent = this._last),
          Wi(this));
    }),
    (t.totalTime = function (i, r) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = _t(
              Kt.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts)
            )),
          s.prototype.totalTime.call(this, i, r),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (i, r) {
      return (this.labels[i] = rn(this, r)), this;
    }),
    (t.removeLabel = function (i) {
      return delete this.labels[i], this;
    }),
    (t.addPause = function (i, r, a) {
      var o = lt.delayedCall(0, r || Ms, a);
      return (
        (o.data = "isPause"), (this._hasPause = 1), bn(this, o, rn(this, i))
      );
    }),
    (t.removePause = function (i) {
      var r = this._first;
      for (i = rn(this, i); r; )
        r._start === i && r.data === "isPause" && yi(r), (r = r._next);
    }),
    (t.killTweensOf = function (i, r, a) {
      for (var o = this.getTweensOf(i, a), l = o.length; l--; )
        di !== o[l] && o[l].kill(i, r);
      return this;
    }),
    (t.getTweensOf = function (i, r) {
      for (var a = [], o = dn(i), l = this._first, c = $n(r), u; l; )
        l instanceof lt
          ? Wh(l._targets, o) &&
            (c
              ? (!di || (l._initted && l._ts)) &&
                l.globalTime(0) <= r &&
                l.globalTime(l.totalDuration()) > r
              : !r || l.isActive()) &&
            a.push(l)
          : (u = l.getTweensOf(o, r)).length && a.push.apply(a, u),
          (l = l._next);
      return a;
    }),
    (t.tweenTo = function (i, r) {
      r = r || {};
      var a = this,
        o = rn(a, i),
        l = r,
        c = l.startAt,
        u = l.onStart,
        d = l.onStartParams,
        f = l.immediateRender,
        h,
        _ = lt.to(
          a,
          fn(
            {
              ease: r.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: o,
              overwrite: "auto",
              duration:
                r.duration ||
                Math.abs(
                  (o - (c && "time" in c ? c.time : a._time)) / a.timeScale()
                ) ||
                je,
              onStart: function () {
                if ((a.pause(), !h)) {
                  var g =
                    r.duration ||
                    Math.abs(
                      (o - (c && "time" in c ? c.time : a._time)) /
                        a.timeScale()
                    );
                  _._dur !== g && zr(_, g, 0, 1).render(_._time, !0, !0),
                    (h = 1);
                }
                u && u.apply(_, d || []);
              },
            },
            r
          )
        );
      return f ? _.render(0) : _;
    }),
    (t.tweenFromTo = function (i, r, a) {
      return this.tweenTo(r, fn({ startAt: { time: rn(this, i) } }, a));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (i) {
      return i === void 0 && (i = this._time), pc(this, rn(this, i));
    }),
    (t.previousLabel = function (i) {
      return i === void 0 && (i = this._time), pc(this, rn(this, i), 1);
    }),
    (t.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + je);
    }),
    (t.shiftChildren = function (i, r, a) {
      a === void 0 && (a = 0);
      for (var o = this._first, l = this.labels, c; o; )
        o._start >= a && ((o._start += i), (o._end += i)), (o = o._next);
      if (r) for (c in l) l[c] >= a && (l[c] += i);
      return Wi(this);
    }),
    (t.invalidate = function (i) {
      var r = this._first;
      for (this._lock = 0; r; ) r.invalidate(i), (r = r._next);
      return s.prototype.invalidate.call(this, i);
    }),
    (t.clear = function (i) {
      i === void 0 && (i = !0);
      for (var r = this._first, a; r; ) (a = r._next), this.remove(r), (r = a);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        Wi(this)
      );
    }),
    (t.totalDuration = function (i) {
      var r = 0,
        a = this,
        o = a._last,
        l = un,
        c,
        u,
        d;
      if (arguments.length)
        return a.timeScale(
          (a._repeat < 0 ? a.duration() : a.totalDuration()) /
            (a.reversed() ? -i : i)
        );
      if (a._dirty) {
        for (d = a.parent; o; )
          (c = o._prev),
            o._dirty && o.totalDuration(),
            (u = o._start),
            u > l && a._sort && o._ts && !a._lock
              ? ((a._lock = 1), (bn(a, o, u - o._delay, 1)._lock = 0))
              : (l = u),
            u < 0 &&
              o._ts &&
              ((r -= u),
              ((!d && !a._dp) || (d && d.smoothChildTiming)) &&
                ((a._start += u / a._ts), (a._time -= u), (a._tTime -= u)),
              a.shiftChildren(-u, !1, -1 / 0),
              (l = 0)),
            o._end > r && o._ts && (r = o._end),
            (o = c);
        zr(a, a === Ze && a._time > r ? a._time : r, 1, 1), (a._dirty = 0);
      }
      return a._tDur;
    }),
    (e.updateRoot = function (i) {
      if ((Ze._ts && (Bd(Ze, Ta(i, Ze)), (kd = Kt.frame)), Kt.frame >= uc)) {
        uc += Qt.autoSleep || 120;
        var r = Ze._first;
        if ((!r || !r._ts) && Qt.autoSleep && Kt._listeners.length < 2) {
          for (; r && !r._ts; ) r = r._next;
          r || Kt.sleep();
        }
      }
    }),
    e
  );
})(Ts);
fn(Ot.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var hp = function (e, t, n, i, r, a, o) {
    var l = new Bt(this._pt, e, t, 0, 1, mf, null, r),
      c = 0,
      u = 0,
      d,
      f,
      h,
      _,
      m,
      g,
      p,
      y;
    for (
      l.b = n,
        l.e = i,
        n += "",
        i += "",
        (p = ~i.indexOf("random(")) && (i = bs(i)),
        a && ((y = [n, i]), a(y, e, t), (n = y[0]), (i = y[1])),
        f = n.match($a) || [];
      (d = $a.exec(i));

    )
      (_ = d[0]),
        (m = i.substring(c, d.index)),
        h ? (h = (h + 1) % 5) : m.substr(-5) === "rgba(" && (h = 1),
        _ !== f[u++] &&
          ((g = parseFloat(f[u - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: m || u === 1 ? m : ",",
            s: g,
            c: _.charAt(1) === "=" ? Lr(g, _) - g : parseFloat(_) - g,
            m: h && h < 4 ? Math.round : 0,
          }),
          (c = $a.lastIndex));
    return (
      (l.c = c < i.length ? i.substring(c, i.length) : ""),
      (l.fp = o),
      (Id.test(i) || p) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  Rl = function (e, t, n, i, r, a, o, l, c, u) {
    nt(i) && (i = i(r || 0, e, a));
    var d = e[t],
      f =
        n !== "get"
          ? n
          : nt(d)
          ? c
            ? e[
                t.indexOf("set") || !nt(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](c)
            : e[t]()
          : d,
      h = nt(d) ? (c ? vp : hf) : Il,
      _;
    if (
      (vt(i) &&
        (~i.indexOf("random(") && (i = bs(i)),
        i.charAt(1) === "=" &&
          ((_ = Lr(f, i) + (Tt(f) || 0)), (_ || _ === 0) && (i = _))),
      !u || f !== i || el)
    )
      return !isNaN(f * i) && i !== ""
        ? ((_ = new Bt(
            this._pt,
            e,
            t,
            +f || 0,
            i - (f || 0),
            typeof d == "boolean" ? yp : pf,
            0,
            h
          )),
          c && (_.fp = c),
          o && _.modifier(o, this, e),
          (this._pt = _))
        : (!d && !(t in e) && Al(t, i),
          hp.call(this, e, t, f, i, h, l || Qt.stringFilter, c));
  },
  pp = function (e, t, n, i, r) {
    if (
      (nt(e) && (e = vs(e, r, t, n, i)),
      !Ln(e) || (e.style && e.nodeType) || At(e) || Rd(e))
    )
      return vt(e) ? vs(e, r, t, n, i) : e;
    var a = {},
      o;
    for (o in e) a[o] = vs(e[o], r, t, n, i);
    return a;
  },
  uf = function (e, t, n, i, r, a) {
    var o, l, c, u;
    if (
      Yt[e] &&
      (o = new Yt[e]()).init(
        r,
        o.rawVars ? t[e] : pp(t[e], i, r, a, n),
        n,
        i,
        a
      ) !== !1 &&
      ((n._pt = l = new Bt(n._pt, r, e, 0, 1, o.render, o, 0, o.priority)),
      n !== Ar)
    )
      for (c = n._ptLookup[n._targets.indexOf(r)], u = o._props.length; u--; )
        c[o._props[u]] = l;
    return o;
  },
  di,
  el,
  Dl = function s(e, t, n) {
    var i = e.vars,
      r = i.ease,
      a = i.startAt,
      o = i.immediateRender,
      l = i.lazy,
      c = i.onUpdate,
      u = i.runBackwards,
      d = i.yoyoEase,
      f = i.keyframes,
      h = i.autoRevert,
      _ = e._dur,
      m = e._startAt,
      g = e._targets,
      p = e.parent,
      y = p && p.data === "nested" ? p.vars.targets : g,
      v = e._overwrite === "auto" && !bl,
      x = e.timeline,
      S,
      w,
      A,
      C,
      M,
      b,
      R,
      D,
      P,
      I,
      U,
      H,
      Y;
    if (
      (x && (!f || !r) && (r = "none"),
      (e._ease = qi(r, Fr.ease)),
      (e._yEase = d ? af(qi(d === !0 ? r : d, Fr.ease)) : 0),
      d &&
        e._yoyo &&
        !e._repeat &&
        ((d = e._yEase), (e._yEase = e._ease), (e._ease = d)),
      (e._from = !x && !!i.runBackwards),
      !x || (f && !i.stagger))
    ) {
      if (
        ((D = g[0] ? Hi(g[0]).harness : 0),
        (H = D && i[D.prop]),
        (S = wa(i, Cl)),
        m &&
          (m._zTime < 0 && m.progress(1),
          t < 0 && u && o && !h ? m.render(-1, !0) : m.revert(u && _ ? ga : Gh),
          (m._lazy = 0)),
        a)
      ) {
        if (
          (yi(
            (e._startAt = lt.set(
              g,
              fn(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: p,
                  immediateRender: !0,
                  lazy: !m && kt(l),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    c &&
                    function () {
                      return Zt(e, "onUpdate");
                    },
                  stagger: 0,
                },
                a
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (Et || (!o && !h)) && e._startAt.revert(ga),
          o && _ && t <= 0 && n <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (u && _ && !m) {
        if (
          (t && (o = !1),
          (A = fn(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: o && !m && kt(l),
              immediateRender: o,
              stagger: 0,
              parent: p,
            },
            S
          )),
          H && (A[D.prop] = H),
          yi((e._startAt = lt.set(g, A))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (Et ? e._startAt.revert(ga) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !o)
        )
          s(e._startAt, je, je);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (_ && kt(l)) || (l && !_), w = 0;
        w < g.length;
        w++
      ) {
        if (
          ((M = g[w]),
          (R = M._gsap || Ll(g)[w]._gsap),
          (e._ptLookup[w] = I = {}),
          Yo[R.id] && _i.length && ba(),
          (U = y === g ? w : y.indexOf(M)),
          D &&
            (P = new D()).init(M, H || S, e, U, y) !== !1 &&
            ((e._pt = C =
              new Bt(e._pt, M, P.name, 0, 1, P.render, P, 0, P.priority)),
            P._props.forEach(function (B) {
              I[B] = C;
            }),
            P.priority && (b = 1)),
          !D || H)
        )
          for (A in S)
            Yt[A] && (P = uf(A, S, e, U, M, y))
              ? P.priority && (b = 1)
              : (I[A] = C =
                  Rl.call(e, M, A, "get", S[A], U, y, 0, i.stringFilter));
        e._op && e._op[w] && e.kill(M, e._op[w]),
          v &&
            e._pt &&
            ((di = e),
            Ze.killTweensOf(M, I, e.globalTime(t)),
            (Y = !e.parent),
            (di = 0)),
          e._pt && l && (Yo[R.id] = 1);
      }
      b && gf(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = c),
      (e._initted = (!e._op || e._pt) && !Y),
      f && t <= 0 && x.render(un, !0, !0);
  },
  mp = function (e, t, n, i, r, a, o, l) {
    var c = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      u,
      d,
      f,
      h;
    if (!c)
      for (
        c = e._ptCache[t] = [], f = e._ptLookup, h = e._targets.length;
        h--;

      ) {
        if (((u = f[h][t]), u && u.d && u.d._pt))
          for (u = u.d._pt; u && u.p !== t && u.fp !== t; ) u = u._next;
        if (!u)
          return (
            (el = 1),
            (e.vars[t] = "+=0"),
            Dl(e, o),
            (el = 0),
            l ? Ss(t + " not eligible for reset") : 1
          );
        c.push(u);
      }
    for (h = c.length; h--; )
      (d = c[h]),
        (u = d._pt || d),
        (u.s = (i || i === 0) && !r ? i : u.s + (i || 0) + a * u.c),
        (u.c = n - u.s),
        d.e && (d.e = st(n) + Tt(d.e)),
        d.b && (d.b = u.s + Tt(d.b));
  },
  gp = function (e, t) {
    var n = e[0] ? Hi(e[0]).harness : 0,
      i = n && n.aliases,
      r,
      a,
      o,
      l;
    if (!i) return t;
    r = Yi({}, t);
    for (a in i)
      if (a in r) for (l = i[a].split(","), o = l.length; o--; ) r[l[o]] = r[a];
    return r;
  },
  _p = function (e, t, n, i) {
    var r = t.ease || i || "power1.inOut",
      a,
      o;
    if (At(t))
      (o = n[e] || (n[e] = [])),
        t.forEach(function (l, c) {
          return o.push({ t: (c / (t.length - 1)) * 100, v: l, e: r });
        });
    else
      for (a in t)
        (o = n[a] || (n[a] = [])),
          a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: r });
  },
  vs = function (e, t, n, i, r) {
    return nt(e)
      ? e.call(t, n, i, r)
      : vt(e) && ~e.indexOf("random(")
      ? bs(e)
      : e;
  },
  df = Pl + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  ff = {};
zt(df + ",id,stagger,delay,duration,paused,scrollTrigger", function (s) {
  return (ff[s] = 1);
});
var lt = (function (s) {
  Pd(e, s);
  function e(n, i, r, a) {
    var o;
    typeof i == "number" && ((r.duration = i), (i = r), (r = null)),
      (o = s.call(this, a ? i : gs(i)) || this);
    var l = o.vars,
      c = l.duration,
      u = l.delay,
      d = l.immediateRender,
      f = l.stagger,
      h = l.overwrite,
      _ = l.keyframes,
      m = l.defaults,
      g = l.scrollTrigger,
      p = l.yoyoEase,
      y = i.parent || Ze,
      v = (At(n) || Rd(n) ? $n(n[0]) : "length" in i) ? [n] : dn(n),
      x,
      S,
      w,
      A,
      C,
      M,
      b,
      R;
    if (
      ((o._targets = v.length
        ? Ll(v)
        : Ss(
            "GSAP target " + n + " not found. https://gsap.com",
            !Qt.nullTargetWarn
          ) || []),
      (o._ptLookup = []),
      (o._overwrite = h),
      _ || f || Vs(c) || Vs(u))
    ) {
      if (
        ((i = o.vars),
        (x = o.timeline =
          new Ot({
            data: "nested",
            defaults: m || {},
            targets: y && y.data === "nested" ? y.vars.targets : v,
          })),
        x.kill(),
        (x.parent = x._dp = Vn(o)),
        (x._start = 0),
        f || Vs(c) || Vs(u))
      ) {
        if (((A = v.length), (b = f && $d(f)), Ln(f)))
          for (C in f) ~df.indexOf(C) && (R || (R = {}), (R[C] = f[C]));
        for (S = 0; S < A; S++)
          (w = wa(i, ff)),
            (w.stagger = 0),
            p && (w.yoyoEase = p),
            R && Yi(w, R),
            (M = v[S]),
            (w.duration = +vs(c, Vn(o), S, M, v)),
            (w.delay = (+vs(u, Vn(o), S, M, v) || 0) - o._delay),
            !f &&
              A === 1 &&
              w.delay &&
              ((o._delay = u = w.delay), (o._start += u), (w.delay = 0)),
            x.to(M, w, b ? b(S, M, v) : 0),
            (x._ease = Oe.none);
        x.duration() ? (c = u = 0) : (o.timeline = 0);
      } else if (_) {
        gs(fn(x.vars.defaults, { ease: "none" })),
          (x._ease = qi(_.ease || i.ease || "none"));
        var D = 0,
          P,
          I,
          U;
        if (At(_))
          _.forEach(function (H) {
            return x.to(v, H, ">");
          }),
            x.duration();
        else {
          w = {};
          for (C in _)
            C === "ease" || C === "easeEach" || _p(C, _[C], w, _.easeEach);
          for (C in w)
            for (
              P = w[C].sort(function (H, Y) {
                return H.t - Y.t;
              }),
                D = 0,
                S = 0;
              S < P.length;
              S++
            )
              (I = P[S]),
                (U = {
                  ease: I.e,
                  duration: ((I.t - (S ? P[S - 1].t : 0)) / 100) * c,
                }),
                (U[C] = I.v),
                x.to(v, U, D),
                (D += U.duration);
          x.duration() < c && x.to({}, { duration: c - x.duration() });
        }
      }
      c || o.duration((c = x.duration()));
    } else o.timeline = 0;
    return (
      h === !0 && !bl && ((di = Vn(o)), Ze.killTweensOf(v), (di = 0)),
      bn(y, Vn(o), r),
      i.reversed && o.reverse(),
      i.paused && o.paused(!0),
      (d ||
        (!c &&
          !_ &&
          o._start === _t(y._time) &&
          kt(d) &&
          Yh(Vn(o)) &&
          y.data !== "nested")) &&
        ((o._tTime = -je), o.render(Math.max(0, -u) || 0)),
      g && qd(Vn(o), g),
      o
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (i, r, a) {
      var o = this._time,
        l = this._tDur,
        c = this._dur,
        u = i < 0,
        d = i > l - je && !u ? l : i < je ? 0 : i,
        f,
        h,
        _,
        m,
        g,
        p,
        y,
        v,
        x;
      if (!c) Kh(this, i, r, a);
      else if (
        d !== this._tTime ||
        !i ||
        a ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== u)
      ) {
        if (((f = d), (v = this.timeline), this._repeat)) {
          if (((m = c + this._rDelay), this._repeat < -1 && u))
            return this.totalTime(m * 100 + i, r, a);
          if (
            ((f = _t(d % m)),
            d === l
              ? ((_ = this._repeat), (f = c))
              : ((_ = ~~(d / m)),
                _ && _ === _t(d / m) && ((f = c), _--),
                f > c && (f = c)),
            (p = this._yoyo && _ & 1),
            p && ((x = this._yEase), (f = c - f)),
            (g = kr(this._tTime, m)),
            f === o && !a && this._initted && _ === g)
          )
            return (this._tTime = d), this;
          _ !== g &&
            (v && this._yEase && of(v, p),
            this.vars.repeatRefresh &&
              !p &&
              !this._lock &&
              this._time !== c &&
              this._initted &&
              ((this._lock = a = 1),
              (this.render(_t(m * _), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (Xd(this, u ? i : f, a, r, d)) return (this._tTime = 0), this;
          if (o !== this._time && !(a && this.vars.repeatRefresh && _ !== g))
            return this;
          if (c !== this._dur) return this.render(i, r, a);
        }
        if (
          ((this._tTime = d),
          (this._time = f),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = y = (x || this._ease)(f / c)),
          this._from && (this.ratio = y = 1 - y),
          f && !o && !r && !_ && (Zt(this, "onStart"), this._tTime !== d))
        )
          return this;
        for (h = this._pt; h; ) h.r(y, h.d), (h = h._next);
        (v &&
          v.render(
            i < 0 ? i : !f && p ? -je : v._dur * v._ease(f / this._dur),
            r,
            a
          )) ||
          (this._startAt && (this._zTime = i)),
          this._onUpdate &&
            !r &&
            (u && $o(this, i, r, a), Zt(this, "onUpdate")),
          this._repeat &&
            _ !== g &&
            this.vars.onRepeat &&
            !r &&
            this.parent &&
            Zt(this, "onRepeat"),
          (d === this._tDur || !d) &&
            this._tTime === d &&
            (u && !this._onUpdate && $o(this, i, !0, !0),
            (i || !c) &&
              ((d === this._tDur && this._ts > 0) || (!d && this._ts < 0)) &&
              yi(this, 1),
            !r &&
              !(u && !o) &&
              (d || o || p) &&
              (Zt(this, d === l ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (i) {
      return (
        (!i || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(i),
        s.prototype.invalidate.call(this, i)
      );
    }),
    (t.resetTo = function (i, r, a, o, l) {
      ws || Kt.wake(), this._ts || this.play();
      var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        u;
      return (
        this._initted || Dl(this, c),
        (u = this._ease(c / this._dur)),
        mp(this, i, r, a, o, u, c, l)
          ? this.resetTo(i, r, a, o, 1)
          : (Ua(this, 0),
            this.parent ||
              Hd(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (i, r) {
      if ((r === void 0 && (r = "all"), !i && (!r || r === "all")))
        return (this._lazy = this._pt = 0), this.parent ? ds(this) : this;
      if (this.timeline) {
        var a = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(i, r, di && di.vars.overwrite !== !0)
            ._first || ds(this),
          this.parent &&
            a !== this.timeline.totalDuration() &&
            zr(this, (this._dur * this.timeline._tDur) / a, 0, 1),
          this
        );
      }
      var o = this._targets,
        l = i ? dn(i) : o,
        c = this._ptLookup,
        u = this._pt,
        d,
        f,
        h,
        _,
        m,
        g,
        p;
      if ((!r || r === "all") && Xh(o, l))
        return r === "all" && (this._pt = 0), ds(this);
      for (
        d = this._op = this._op || [],
          r !== "all" &&
            (vt(r) &&
              ((m = {}),
              zt(r, function (y) {
                return (m[y] = 1);
              }),
              (r = m)),
            (r = gp(o, r))),
          p = o.length;
        p--;

      )
        if (~l.indexOf(o[p])) {
          (f = c[p]),
            r === "all"
              ? ((d[p] = r), (_ = f), (h = {}))
              : ((h = d[p] = d[p] || {}), (_ = r));
          for (m in _)
            (g = f && f[m]),
              g &&
                ((!("kill" in g.d) || g.d.kill(m) === !0) && Oa(this, g, "_pt"),
                delete f[m]),
              h !== "all" && (h[m] = 1);
        }
      return this._initted && !this._pt && u && ds(this), this;
    }),
    (e.to = function (i, r) {
      return new e(i, r, arguments[2]);
    }),
    (e.from = function (i, r) {
      return _s(1, arguments);
    }),
    (e.delayedCall = function (i, r, a, o) {
      return new e(r, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: i,
        onComplete: r,
        onReverseComplete: r,
        onCompleteParams: a,
        onReverseCompleteParams: a,
        callbackScope: o,
      });
    }),
    (e.fromTo = function (i, r, a) {
      return _s(2, arguments);
    }),
    (e.set = function (i, r) {
      return (r.duration = 0), r.repeatDelay || (r.repeat = 0), new e(i, r);
    }),
    (e.killTweensOf = function (i, r, a) {
      return Ze.killTweensOf(i, r, a);
    }),
    e
  );
})(Ts);
fn(lt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
zt("staggerTo,staggerFrom,staggerFromTo", function (s) {
  lt[s] = function () {
    var e = new Ot(),
      t = Zo.call(arguments, 0);
    return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
  };
});
var Il = function (e, t, n) {
    return (e[t] = n);
  },
  hf = function (e, t, n) {
    return e[t](n);
  },
  vp = function (e, t, n, i) {
    return e[t](i.fp, n);
  },
  xp = function (e, t, n) {
    return e.setAttribute(t, n);
  },
  Ol = function (e, t) {
    return nt(e[t]) ? hf : wl(e[t]) && e.setAttribute ? xp : Il;
  },
  pf = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  yp = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  mf = function (e, t) {
    var n = t._pt,
      i = "";
    if (!e && t.b) i = t.b;
    else if (e === 1 && t.e) i = t.e;
    else {
      for (; n; )
        (i =
          n.p +
          (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) +
          i),
          (n = n._next);
      i += t.c;
    }
    t.set(t.t, t.p, i, t);
  },
  Nl = function (e, t) {
    for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
  },
  Sp = function (e, t, n, i) {
    for (var r = this._pt, a; r; )
      (a = r._next), r.p === i && r.modifier(e, t, n), (r = a);
  },
  Mp = function (e) {
    for (var t = this._pt, n, i; t; )
      (i = t._next),
        (t.p === e && !t.op) || t.op === e
          ? Oa(this, t, "_pt")
          : t.dep || (n = 1),
        (t = i);
    return !n;
  },
  bp = function (e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
  },
  gf = function (e) {
    for (var t = e._pt, n, i, r, a; t; ) {
      for (n = t._next, i = r; i && i.pr > t.pr; ) i = i._next;
      (t._prev = i ? i._prev : a) ? (t._prev._next = t) : (r = t),
        (t._next = i) ? (i._prev = t) : (a = t),
        (t = n);
    }
    e._pt = r;
  },
  Bt = (function () {
    function s(t, n, i, r, a, o, l, c, u) {
      (this.t = n),
        (this.s = r),
        (this.c = a),
        (this.p = i),
        (this.r = o || pf),
        (this.d = l || this),
        (this.set = c || Il),
        (this.pr = u || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = s.prototype;
    return (
      (e.modifier = function (n, i, r) {
        (this.mSet = this.mSet || this.set),
          (this.set = bp),
          (this.m = n),
          (this.mt = r),
          (this.tween = i);
      }),
      s
    );
  })();
zt(
  Pl +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (s) {
    return (Cl[s] = 1);
  }
);
en.TweenMax = en.TweenLite = lt;
en.TimelineLite = en.TimelineMax = Ot;
Ze = new Ot({
  sortChildren: !1,
  defaults: Fr,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
Qt.stringFilter = sf;
var Xi = [],
  va = {},
  wp = [],
  gc = 0,
  Tp = 0,
  eo = function (e) {
    return (va[e] || wp).map(function (t) {
      return t();
    });
  },
  tl = function () {
    var e = Date.now(),
      t = [];
    e - gc > 2 &&
      (eo("matchMediaInit"),
      Xi.forEach(function (n) {
        var i = n.queries,
          r = n.conditions,
          a,
          o,
          l,
          c;
        for (o in i)
          (a = sn.matchMedia(i[o]).matches),
            a && (l = 1),
            a !== r[o] && ((r[o] = a), (c = 1));
        c && (n.revert(), l && t.push(n));
      }),
      eo("matchMediaRevert"),
      t.forEach(function (n) {
        return n.onMatch(n, function (i) {
          return n.add(null, i);
        });
      }),
      (gc = e),
      eo("matchMedia"));
  },
  _f = (function () {
    function s(t, n) {
      (this.selector = n && Jo(n)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = Tp++),
        t && this.add(t);
    }
    var e = s.prototype;
    return (
      (e.add = function (n, i, r) {
        nt(n) && ((r = i), (i = n), (n = nt));
        var a = this,
          o = function () {
            var c = tt,
              u = a.selector,
              d;
            return (
              c && c !== a && c.data.push(a),
              r && (a.selector = Jo(r)),
              (tt = a),
              (d = i.apply(a, arguments)),
              nt(d) && a._r.push(d),
              (tt = c),
              (a.selector = u),
              (a.isReverted = !1),
              d
            );
          };
        return (
          (a.last = o),
          n === nt
            ? o(a, function (l) {
                return a.add(null, l);
              })
            : n
            ? (a[n] = o)
            : o
        );
      }),
      (e.ignore = function (n) {
        var i = tt;
        (tt = null), n(this), (tt = i);
      }),
      (e.getTweens = function () {
        var n = [];
        return (
          this.data.forEach(function (i) {
            return i instanceof s
              ? n.push.apply(n, i.getTweens())
              : i instanceof lt &&
                  !(i.parent && i.parent.data === "nested") &&
                  n.push(i);
          }),
          n
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (n, i) {
        var r = this;
        if (
          (n
            ? (function () {
                for (var o = r.getTweens(), l = r.data.length, c; l--; )
                  (c = r.data[l]),
                    c.data === "isFlip" &&
                      (c.revert(),
                      c.getChildren(!0, !0, !1).forEach(function (u) {
                        return o.splice(o.indexOf(u), 1);
                      }));
                for (
                  o
                    .map(function (u) {
                      return {
                        g:
                          u._dur ||
                          u._delay ||
                          (u._sat && !u._sat.vars.immediateRender)
                            ? u.globalTime(0)
                            : -1 / 0,
                        t: u,
                      };
                    })
                    .sort(function (u, d) {
                      return d.g - u.g || -1 / 0;
                    })
                    .forEach(function (u) {
                      return u.t.revert(n);
                    }),
                    l = r.data.length;
                  l--;

                )
                  (c = r.data[l]),
                    c instanceof Ot
                      ? c.data !== "nested" &&
                        (c.scrollTrigger && c.scrollTrigger.revert(), c.kill())
                      : !(c instanceof lt) && c.revert && c.revert(n);
                r._r.forEach(function (u) {
                  return u(n, r);
                }),
                  (r.isReverted = !0);
              })()
            : this.data.forEach(function (o) {
                return o.kill && o.kill();
              }),
          this.clear(),
          i)
        )
          for (var a = Xi.length; a--; )
            Xi[a].id === this.id && Xi.splice(a, 1);
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      s
    );
  })(),
  Ep = (function () {
    function s(t) {
      (this.contexts = []), (this.scope = t);
    }
    var e = s.prototype;
    return (
      (e.add = function (n, i, r) {
        Ln(n) || (n = { matches: n });
        var a = new _f(0, r || this.scope),
          o = (a.conditions = {}),
          l,
          c,
          u;
        tt && !a.selector && (a.selector = tt.selector),
          this.contexts.push(a),
          (i = a.add("onMatch", i)),
          (a.queries = n);
        for (c in n)
          c === "all"
            ? (u = 1)
            : ((l = sn.matchMedia(n[c])),
              l &&
                (Xi.indexOf(a) < 0 && Xi.push(a),
                (o[c] = l.matches) && (u = 1),
                l.addListener
                  ? l.addListener(tl)
                  : l.addEventListener("change", tl)));
        return (
          u &&
            i(a, function (d) {
              return a.add(null, d);
            }),
          this
        );
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      (e.kill = function (n) {
        this.contexts.forEach(function (i) {
          return i.kill(n, !0);
        });
      }),
      s
    );
  })(),
  Ea = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      t.forEach(function (i) {
        return tf(i);
      });
    },
    timeline: function (e) {
      return new Ot(e);
    },
    getTweensOf: function (e, t) {
      return Ze.getTweensOf(e, t);
    },
    getProperty: function (e, t, n, i) {
      vt(e) && (e = dn(e)[0]);
      var r = Hi(e || {}).get,
        a = n ? Gd : Vd;
      return (
        n === "native" && (n = ""),
        e &&
          (t
            ? a(((Yt[t] && Yt[t].get) || r)(e, t, n, i))
            : function (o, l, c) {
                return a(((Yt[o] && Yt[o].get) || r)(e, o, l, c));
              })
      );
    },
    quickSetter: function (e, t, n) {
      if (((e = dn(e)), e.length > 1)) {
        var i = e.map(function (u) {
            return Ht.quickSetter(u, t, n);
          }),
          r = i.length;
        return function (u) {
          for (var d = r; d--; ) i[d](u);
        };
      }
      e = e[0] || {};
      var a = Yt[t],
        o = Hi(e),
        l = (o.harness && (o.harness.aliases || {})[t]) || t,
        c = a
          ? function (u) {
              var d = new a();
              (Ar._pt = 0),
                d.init(e, n ? u + n : u, Ar, 0, [e]),
                d.render(1, d),
                Ar._pt && Nl(1, Ar);
            }
          : o.set(e, l);
      return a
        ? c
        : function (u) {
            return c(e, l, n ? u + n : u, o, 1);
          };
    },
    quickTo: function (e, t, n) {
      var i,
        r = Ht.to(
          e,
          Yi(((i = {}), (i[t] = "+=0.1"), (i.paused = !0), i), n || {})
        ),
        a = function (l, c, u) {
          return r.resetTo(t, l, c, u);
        };
      return (a.tween = r), a;
    },
    isTweening: function (e) {
      return Ze.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = qi(e.ease, Fr.ease)), dc(Fr, e || {});
    },
    config: function (e) {
      return dc(Qt, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        n = e.effect,
        i = e.plugins,
        r = e.defaults,
        a = e.extendTimeline;
      (i || "").split(",").forEach(function (o) {
        return (
          o && !Yt[o] && !en[o] && Ss(t + " effect requires " + o + " plugin.")
        );
      }),
        (Ka[t] = function (o, l, c) {
          return n(dn(o), fn(l || {}, r), c);
        }),
        a &&
          (Ot.prototype[t] = function (o, l, c) {
            return this.add(Ka[t](o, Ln(l) ? l : (c = l) && {}, this), c);
          });
    },
    registerEase: function (e, t) {
      Oe[e] = qi(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? qi(e, t) : Oe;
    },
    getById: function (e) {
      return Ze.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var n = new Ot(e),
        i,
        r;
      for (
        n.smoothChildTiming = kt(e.smoothChildTiming),
          Ze.remove(n),
          n._dp = 0,
          n._time = n._tTime = Ze._time,
          i = Ze._first;
        i;

      )
        (r = i._next),
          (t ||
            !(
              !i._dur &&
              i instanceof lt &&
              i.vars.onComplete === i._targets[0]
            )) &&
            bn(n, i, i._start - i._delay),
          (i = r);
      return bn(Ze, n, 0), n;
    },
    context: function (e, t) {
      return e ? new _f(e, t) : tt;
    },
    matchMedia: function (e) {
      return new Ep(e);
    },
    matchMediaRefresh: function () {
      return (
        Xi.forEach(function (e) {
          var t = e.conditions,
            n,
            i;
          for (i in t) t[i] && ((t[i] = !1), (n = 1));
          n && e.revert();
        }) || tl()
      );
    },
    addEventListener: function (e, t) {
      var n = va[e] || (va[e] = []);
      ~n.indexOf(t) || n.push(t);
    },
    removeEventListener: function (e, t) {
      var n = va[e],
        i = n && n.indexOf(t);
      i >= 0 && n.splice(i, 1);
    },
    utils: {
      wrap: rp,
      wrapYoyo: sp,
      distribute: $d,
      random: Zd,
      snap: Kd,
      normalize: ip,
      getUnit: Tt,
      clamp: Qh,
      splitColor: nf,
      toArray: dn,
      selector: Jo,
      mapRange: Qd,
      pipe: tp,
      unitize: np,
      interpolate: ap,
      shuffle: Yd,
    },
    install: Ud,
    effects: Ka,
    ticker: Kt,
    updateRoot: Ot.updateRoot,
    plugins: Yt,
    globalTimeline: Ze,
    core: {
      PropTween: Bt,
      globals: Fd,
      Tween: lt,
      Timeline: Ot,
      Animation: Ts,
      getCache: Hi,
      _removeLinkedListItem: Oa,
      reverting: function () {
        return Et;
      },
      context: function (e) {
        return e && tt && (tt.data.push(e), (e._ctx = tt)), tt;
      },
      suppressOverwrites: function (e) {
        return (bl = e);
      },
    },
  };
zt("to,from,fromTo,delayedCall,set,killTweensOf", function (s) {
  return (Ea[s] = lt[s]);
});
Kt.add(Ot.updateRoot);
Ar = Ea.to({}, { duration: 0 });
var Ap = function (e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
      n = n._next;
    return n;
  },
  Cp = function (e, t) {
    var n = e._targets,
      i,
      r,
      a;
    for (i in t)
      for (r = n.length; r--; )
        (a = e._ptLookup[r][i]),
          a &&
            (a = a.d) &&
            (a._pt && (a = Ap(a, i)),
            a && a.modifier && a.modifier(t[i], e, n[r], i));
  },
  to = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (i, r, a) {
        a._onInit = function (o) {
          var l, c;
          if (
            (vt(r) &&
              ((l = {}),
              zt(r, function (u) {
                return (l[u] = 1);
              }),
              (r = l)),
            t)
          ) {
            l = {};
            for (c in r) l[c] = t(r[c]);
            r = l;
          }
          Cp(o, r);
        };
      },
    };
  },
  Ht =
    Ea.registerPlugin(
      {
        name: "attr",
        init: function (e, t, n, i, r) {
          var a, o, l;
          this.tween = n;
          for (a in t)
            (l = e.getAttribute(a) || ""),
              (o = this.add(
                e,
                "setAttribute",
                (l || 0) + "",
                t[a],
                i,
                r,
                0,
                0,
                a
              )),
              (o.op = a),
              (o.b = l),
              this._props.push(a);
        },
        render: function (e, t) {
          for (var n = t._pt; n; )
            Et ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
        },
      },
      {
        name: "endArray",
        init: function (e, t) {
          for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
        },
      },
      to("roundProps", Qo),
      to("modifiers"),
      to("snap", Kd)
    ) || Ea;
lt.version = Ot.version = Ht.version = "3.12.3";
Nd = 1;
Tl() && Br();
Oe.Power0;
Oe.Power1;
Oe.Power2;
Oe.Power3;
Oe.Power4;
Oe.Linear;
Oe.Quad;
Oe.Cubic;
Oe.Quart;
Oe.Quint;
Oe.Strong;
Oe.Elastic;
Oe.Back;
Oe.SteppedEase;
Oe.Bounce;
Oe.Sine;
Oe.Expo;
Oe.Circ;
/*!
 * CSSPlugin 3.12.3
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var _c,
  fi,
  Rr,
  Ul,
  ki,
  vc,
  Fl,
  Pp = function () {
    return typeof window != "undefined";
  },
  Kn = {},
  Ii = 180 / Math.PI,
  Dr = Math.PI / 180,
  rr = Math.atan2,
  xc = 1e8,
  kl = /([A-Z])/g,
  Lp = /(left|right|width|margin|padding|x)/i,
  Rp = /[\s,\(]\S/,
  Tn = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  nl = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  Dp = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  Ip = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  Op = function (e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  vf = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  xf = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  Np = function (e, t, n) {
    return (e.style[t] = n);
  },
  Up = function (e, t, n) {
    return e.style.setProperty(t, n);
  },
  Fp = function (e, t, n) {
    return (e._gsap[t] = n);
  },
  kp = function (e, t, n) {
    return (e._gsap.scaleX = e._gsap.scaleY = n);
  },
  zp = function (e, t, n, i, r) {
    var a = e._gsap;
    (a.scaleX = a.scaleY = n), a.renderTransform(r, a);
  },
  Bp = function (e, t, n, i, r) {
    var a = e._gsap;
    (a[t] = n), a.renderTransform(r, a);
  },
  Je = "transform",
  Vt = Je + "Origin",
  Vp = function s(e, t) {
    var n = this,
      i = this.target,
      r = i.style,
      a = i._gsap;
    if (e in Kn && r) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = Tn[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (o) {
                return (n.tfm[o] = Gn(i, o));
              })
            : (this.tfm[e] = a.x ? a[e] : Gn(i, e)),
          e === Vt && (this.tfm.zOrigin = a.zOrigin);
      else
        return Tn.transform.split(",").forEach(function (o) {
          return s.call(n, o, t);
        });
      if (this.props.indexOf(Je) >= 0) return;
      a.svg &&
        ((this.svgo = i.getAttribute("data-svg-origin")),
        this.props.push(Vt, t, "")),
        (e = Je);
    }
    (r || t) && this.props.push(e, t, r[e]);
  },
  yf = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  Gp = function () {
    var e = this.props,
      t = this.target,
      n = t.style,
      i = t._gsap,
      r,
      a;
    for (r = 0; r < e.length; r += 3)
      e[r + 1]
        ? (t[e[r]] = e[r + 2])
        : e[r + 2]
        ? (n[e[r]] = e[r + 2])
        : n.removeProperty(
            e[r].substr(0, 2) === "--"
              ? e[r]
              : e[r].replace(kl, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (a in this.tfm) i[a] = this.tfm[a];
      i.svg &&
        (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (r = Fl()),
        (!r || !r.isStart) &&
          !n[Je] &&
          (yf(n),
          i.zOrigin &&
            n[Vt] &&
            ((n[Vt] += " " + i.zOrigin + "px"),
            (i.zOrigin = 0),
            i.renderTransform()),
          (i.uncache = 1));
    }
  },
  Sf = function (e, t) {
    var n = { target: e, props: [], revert: Gp, save: Vp };
    return (
      e._gsap || Ht.core.getCache(e),
      t &&
        t.split(",").forEach(function (i) {
          return n.save(i);
        }),
      n
    );
  },
  Mf,
  il = function (e, t) {
    var n = fi.createElementNS
      ? fi.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : fi.createElement(e);
    return n && n.style ? n : fi.createElement(e);
  },
  An = function s(e, t, n) {
    var i = getComputedStyle(e);
    return (
      i[t] ||
      i.getPropertyValue(t.replace(kl, "-$1").toLowerCase()) ||
      i.getPropertyValue(t) ||
      (!n && s(e, Vr(t) || t, 1)) ||
      ""
    );
  },
  yc = "O,Moz,ms,Ms,Webkit".split(","),
  Vr = function (e, t, n) {
    var i = t || ki,
      r = i.style,
      a = 5;
    if (e in r && !n) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      a-- && !(yc[a] + e in r);

    );
    return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? yc[a] : "") + e;
  },
  rl = function () {
    Pp() &&
      window.document &&
      ((_c = window),
      (fi = _c.document),
      (Rr = fi.documentElement),
      (ki = il("div") || { style: {} }),
      il("div"),
      (Je = Vr(Je)),
      (Vt = Je + "Origin"),
      (ki.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (Mf = !!Vr("perspective")),
      (Fl = Ht.core.reverting),
      (Ul = 1));
  },
  no = function s(e) {
    var t = il(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      n = this.parentNode,
      i = this.nextSibling,
      r = this.style.cssText,
      a;
    if (
      (Rr.appendChild(t),
      t.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        (a = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = s);
      } catch {}
    else this._gsapBBox && (a = this._gsapBBox());
    return (
      n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
      Rr.removeChild(t),
      (this.style.cssText = r),
      a
    );
  },
  Sc = function (e, t) {
    for (var n = t.length; n--; )
      if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
  },
  bf = function (e) {
    var t;
    try {
      t = e.getBBox();
    } catch {
      t = no.call(e, !0);
    }
    return (
      (t && (t.width || t.height)) || e.getBBox === no || (t = no.call(e, !0)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +Sc(e, ["x", "cx", "x1"]) || 0,
            y: +Sc(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  wf = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && bf(e));
  },
  $i = function (e, t) {
    if (t) {
      var n = e.style,
        i;
      t in Kn && t !== Vt && (t = Je),
        n.removeProperty
          ? ((i = t.substr(0, 2)),
            (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
            n.removeProperty(
              i === "--" ? t : t.replace(kl, "-$1").toLowerCase()
            ))
          : n.removeAttribute(t);
    }
  },
  hi = function (e, t, n, i, r, a) {
    var o = new Bt(e._pt, t, n, 0, 1, a ? xf : vf);
    return (e._pt = o), (o.b = i), (o.e = r), e._props.push(n), o;
  },
  Mc = { deg: 1, rad: 1, turn: 1 },
  Hp = { grid: 1, flex: 1 },
  Si = function s(e, t, n, i) {
    var r = parseFloat(n) || 0,
      a = (n + "").trim().substr((r + "").length) || "px",
      o = ki.style,
      l = Lp.test(t),
      c = e.tagName.toLowerCase() === "svg",
      u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
      d = 100,
      f = i === "px",
      h = i === "%",
      _,
      m,
      g,
      p;
    if (i === a || !r || Mc[i] || Mc[a]) return r;
    if (
      (a !== "px" && !f && (r = s(e, t, n, "px")),
      (p = e.getCTM && wf(e)),
      (h || a === "%") && (Kn[t] || ~t.indexOf("adius")))
    )
      return (
        (_ = p ? e.getBBox()[l ? "width" : "height"] : e[u]),
        st(h ? (r / _) * d : (r / 100) * _)
      );
    if (
      ((o[l ? "width" : "height"] = d + (f ? a : i)),
      (m =
        ~t.indexOf("adius") || (i === "em" && e.appendChild && !c)
          ? e
          : e.parentNode),
      p && (m = (e.ownerSVGElement || {}).parentNode),
      (!m || m === fi || !m.appendChild) && (m = fi.body),
      (g = m._gsap),
      g && h && g.width && l && g.time === Kt.time && !g.uncache)
    )
      return st((r / g.width) * d);
    if (h && (t === "height" || t === "width")) {
      var y = e.style[t];
      (e.style[t] = d + i), (_ = e[u]), y ? (e.style[t] = y) : $i(e, t);
    } else
      (h || a === "%") &&
        !Hp[An(m, "display")] &&
        (o.position = An(e, "position")),
        m === e && (o.position = "static"),
        m.appendChild(ki),
        (_ = ki[u]),
        m.removeChild(ki),
        (o.position = "absolute");
    return (
      l && h && ((g = Hi(m)), (g.time = Kt.time), (g.width = m[u])),
      st(f ? (_ * r) / d : _ && r ? (d / _) * r : 0)
    );
  },
  Gn = function (e, t, n, i) {
    var r;
    return (
      Ul || rl(),
      t in Tn &&
        t !== "transform" &&
        ((t = Tn[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      Kn[t] && t !== "transform"
        ? ((r = As(e, i)),
          (r =
            t !== "transformOrigin"
              ? r[t]
              : r.svg
              ? r.origin
              : Ca(An(e, Vt)) + " " + r.zOrigin + "px"))
        : ((r = e.style[t]),
          (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) &&
            (r =
              (Aa[t] && Aa[t](e, t, n)) ||
              An(e, t) ||
              zd(e, t) ||
              (t === "opacity" ? 1 : 0))),
      n && !~(r + "").trim().indexOf(" ") ? Si(e, t, r, n) + n : r
    );
  },
  Wp = function (e, t, n, i) {
    if (!n || n === "none") {
      var r = Vr(t, e, 1),
        a = r && An(e, r, 1);
      a && a !== n
        ? ((t = r), (n = a))
        : t === "borderColor" && (n = An(e, "borderTopColor"));
    }
    var o = new Bt(this._pt, e.style, t, 0, 1, mf),
      l = 0,
      c = 0,
      u,
      d,
      f,
      h,
      _,
      m,
      g,
      p,
      y,
      v,
      x,
      S;
    if (
      ((o.b = n),
      (o.e = i),
      (n += ""),
      (i += ""),
      i === "auto" &&
        ((m = e.style[t]),
        (e.style[t] = i),
        (i = An(e, t) || i),
        m ? (e.style[t] = m) : $i(e, t)),
      (u = [n, i]),
      sf(u),
      (n = u[0]),
      (i = u[1]),
      (f = n.match(Er) || []),
      (S = i.match(Er) || []),
      S.length)
    ) {
      for (; (d = Er.exec(i)); )
        (g = d[0]),
          (y = i.substring(l, d.index)),
          _
            ? (_ = (_ + 1) % 5)
            : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (_ = 1),
          g !== (m = f[c++] || "") &&
            ((h = parseFloat(m) || 0),
            (x = m.substr((h + "").length)),
            g.charAt(1) === "=" && (g = Lr(h, g) + x),
            (p = parseFloat(g)),
            (v = g.substr((p + "").length)),
            (l = Er.lastIndex - v.length),
            v ||
              ((v = v || Qt.units[t] || x),
              l === i.length && ((i += v), (o.e += v))),
            x !== v && (h = Si(e, t, m, v) || 0),
            (o._pt = {
              _next: o._pt,
              p: y || c === 1 ? y : ",",
              s: h,
              c: p - h,
              m: (_ && _ < 4) || t === "zIndex" ? Math.round : 0,
            }));
      o.c = l < i.length ? i.substring(l, i.length) : "";
    } else o.r = t === "display" && i === "none" ? xf : vf;
    return Id.test(i) && (o.e = 0), (this._pt = o), o;
  },
  bc = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  qp = function (e) {
    var t = e.split(" "),
      n = t[0],
      i = t[1] || "50%";
    return (
      (n === "top" || n === "bottom" || i === "left" || i === "right") &&
        ((e = n), (n = i), (i = e)),
      (t[0] = bc[n] || n),
      (t[1] = bc[i] || i),
      t.join(" ")
    );
  },
  Xp = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var n = t.t,
        i = n.style,
        r = t.u,
        a = n._gsap,
        o,
        l,
        c;
      if (r === "all" || r === !0) (i.cssText = ""), (l = 1);
      else
        for (r = r.split(","), c = r.length; --c > -1; )
          (o = r[c]),
            Kn[o] && ((l = 1), (o = o === "transformOrigin" ? Vt : Je)),
            $i(n, o);
      l &&
        ($i(n, Je),
        a &&
          (a.svg && n.removeAttribute("transform"),
          As(n, 1),
          (a.uncache = 1),
          yf(i)));
    }
  },
  Aa = {
    clearProps: function (e, t, n, i, r) {
      if (r.data !== "isFromStart") {
        var a = (e._pt = new Bt(e._pt, t, n, 0, 0, Xp));
        return (a.u = i), (a.pr = -10), (a.tween = r), e._props.push(n), 1;
      }
    },
  },
  Es = [1, 0, 0, 1, 0, 0],
  Tf = {},
  Ef = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  wc = function (e) {
    var t = An(e, Je);
    return Ef(t) ? Es : t.substr(7).match(Dd).map(st);
  },
  zl = function (e, t) {
    var n = e._gsap || Hi(e),
      i = e.style,
      r = wc(e),
      a,
      o,
      l,
      c;
    return n.svg && e.getAttribute("transform")
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (r = [l.a, l.b, l.c, l.d, l.e, l.f]),
        r.join(",") === "1,0,0,1,0,0" ? Es : r)
      : (r === Es &&
          !e.offsetParent &&
          e !== Rr &&
          !n.svg &&
          ((l = i.display),
          (i.display = "block"),
          (a = e.parentNode),
          (!a || !e.offsetParent) &&
            ((c = 1), (o = e.nextElementSibling), Rr.appendChild(e)),
          (r = wc(e)),
          l ? (i.display = l) : $i(e, "display"),
          c &&
            (o
              ? a.insertBefore(e, o)
              : a
              ? a.appendChild(e)
              : Rr.removeChild(e))),
        t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
  },
  sl = function (e, t, n, i, r, a) {
    var o = e._gsap,
      l = r || zl(e, !0),
      c = o.xOrigin || 0,
      u = o.yOrigin || 0,
      d = o.xOffset || 0,
      f = o.yOffset || 0,
      h = l[0],
      _ = l[1],
      m = l[2],
      g = l[3],
      p = l[4],
      y = l[5],
      v = t.split(" "),
      x = parseFloat(v[0]) || 0,
      S = parseFloat(v[1]) || 0,
      w,
      A,
      C,
      M;
    n
      ? l !== Es &&
        (A = h * g - _ * m) &&
        ((C = x * (g / A) + S * (-m / A) + (m * y - g * p) / A),
        (M = x * (-_ / A) + S * (h / A) - (h * y - _ * p) / A),
        (x = C),
        (S = M))
      : ((w = bf(e)),
        (x = w.x + (~v[0].indexOf("%") ? (x / 100) * w.width : x)),
        (S = w.y + (~(v[1] || v[0]).indexOf("%") ? (S / 100) * w.height : S)),
        !("xOrigin" in o) && (x || S) && ((x -= w.x), (S -= w.y))),
      i || (i !== !1 && o.smooth)
        ? ((p = x - c),
          (y = S - u),
          (o.xOffset = d + (p * h + y * m) - p),
          (o.yOffset = f + (p * _ + y * g) - y))
        : (o.xOffset = o.yOffset = 0),
      (o.xOrigin = x),
      (o.yOrigin = S),
      (o.smooth = !!i),
      (o.origin = t),
      (o.originIsAbsolute = !!n),
      (e.style[Vt] = "0px 0px"),
      a &&
        (hi(a, o, "xOrigin", c, x),
        hi(a, o, "yOrigin", u, S),
        hi(a, o, "xOffset", d, o.xOffset),
        hi(a, o, "yOffset", f, o.yOffset)),
      e.setAttribute("data-svg-origin", x + " " + S);
  },
  As = function (e, t) {
    var n = e._gsap || new cf(e);
    if ("x" in n && !t && !n.uncache) return n;
    var i = e.style,
      r = n.scaleX < 0,
      a = "px",
      o = "deg",
      l = getComputedStyle(e),
      c = An(e, Vt) || "0",
      u,
      d,
      f,
      h,
      _,
      m,
      g,
      p,
      y,
      v,
      x,
      S,
      w,
      A,
      C,
      M,
      b,
      R,
      D,
      P,
      I,
      U,
      H,
      Y,
      B,
      Q,
      Z,
      me,
      te,
      V,
      K,
      ie;
    return (
      (u = d = f = m = g = p = y = v = x = 0),
      (h = _ = 1),
      (n.svg = !!(e.getCTM && wf(e))),
      l.translate &&
        ((l.translate !== "none" ||
          l.scale !== "none" ||
          l.rotate !== "none") &&
          (i[Je] =
            (l.translate !== "none"
              ? "translate3d(" +
                (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
            (l.scale !== "none"
              ? "scale(" + l.scale.split(" ").join(",") + ") "
              : "") +
            (l[Je] !== "none" ? l[Je] : "")),
        (i.scale = i.rotate = i.translate = "none")),
      (A = zl(e, n.svg)),
      n.svg &&
        (n.uncache
          ? ((B = e.getBBox()),
            (c = n.xOrigin - B.x + "px " + (n.yOrigin - B.y) + "px"),
            (Y = ""))
          : (Y = !t && e.getAttribute("data-svg-origin")),
        sl(e, Y || c, !!Y || n.originIsAbsolute, n.smooth !== !1, A)),
      (S = n.xOrigin || 0),
      (w = n.yOrigin || 0),
      A !== Es &&
        ((R = A[0]),
        (D = A[1]),
        (P = A[2]),
        (I = A[3]),
        (u = U = A[4]),
        (d = H = A[5]),
        A.length === 6
          ? ((h = Math.sqrt(R * R + D * D)),
            (_ = Math.sqrt(I * I + P * P)),
            (m = R || D ? rr(D, R) * Ii : 0),
            (y = P || I ? rr(P, I) * Ii + m : 0),
            y && (_ *= Math.abs(Math.cos(y * Dr))),
            n.svg && ((u -= S - (S * R + w * P)), (d -= w - (S * D + w * I))))
          : ((ie = A[6]),
            (V = A[7]),
            (Z = A[8]),
            (me = A[9]),
            (te = A[10]),
            (K = A[11]),
            (u = A[12]),
            (d = A[13]),
            (f = A[14]),
            (C = rr(ie, te)),
            (g = C * Ii),
            C &&
              ((M = Math.cos(-C)),
              (b = Math.sin(-C)),
              (Y = U * M + Z * b),
              (B = H * M + me * b),
              (Q = ie * M + te * b),
              (Z = U * -b + Z * M),
              (me = H * -b + me * M),
              (te = ie * -b + te * M),
              (K = V * -b + K * M),
              (U = Y),
              (H = B),
              (ie = Q)),
            (C = rr(-P, te)),
            (p = C * Ii),
            C &&
              ((M = Math.cos(-C)),
              (b = Math.sin(-C)),
              (Y = R * M - Z * b),
              (B = D * M - me * b),
              (Q = P * M - te * b),
              (K = I * b + K * M),
              (R = Y),
              (D = B),
              (P = Q)),
            (C = rr(D, R)),
            (m = C * Ii),
            C &&
              ((M = Math.cos(C)),
              (b = Math.sin(C)),
              (Y = R * M + D * b),
              (B = U * M + H * b),
              (D = D * M - R * b),
              (H = H * M - U * b),
              (R = Y),
              (U = B)),
            g &&
              Math.abs(g) + Math.abs(m) > 359.9 &&
              ((g = m = 0), (p = 180 - p)),
            (h = st(Math.sqrt(R * R + D * D + P * P))),
            (_ = st(Math.sqrt(H * H + ie * ie))),
            (C = rr(U, H)),
            (y = Math.abs(C) > 2e-4 ? C * Ii : 0),
            (x = K ? 1 / (K < 0 ? -K : K) : 0)),
        n.svg &&
          ((Y = e.getAttribute("transform")),
          (n.forceCSS = e.setAttribute("transform", "") || !Ef(An(e, Je))),
          Y && e.setAttribute("transform", Y))),
      Math.abs(y) > 90 &&
        Math.abs(y) < 270 &&
        (r
          ? ((h *= -1), (y += m <= 0 ? 180 : -180), (m += m <= 0 ? 180 : -180))
          : ((_ *= -1), (y += y <= 0 ? 180 : -180))),
      (t = t || n.uncache),
      (n.x =
        u -
        ((n.xPercent =
          u &&
          ((!t && n.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0)))
          ? (e.offsetWidth * n.xPercent) / 100
          : 0) +
        a),
      (n.y =
        d -
        ((n.yPercent =
          d &&
          ((!t && n.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0)))
          ? (e.offsetHeight * n.yPercent) / 100
          : 0) +
        a),
      (n.z = f + a),
      (n.scaleX = st(h)),
      (n.scaleY = st(_)),
      (n.rotation = st(m) + o),
      (n.rotationX = st(g) + o),
      (n.rotationY = st(p) + o),
      (n.skewX = y + o),
      (n.skewY = v + o),
      (n.transformPerspective = x + a),
      (n.zOrigin = parseFloat(c.split(" ")[2]) || (!t && n.zOrigin) || 0) &&
        (i[Vt] = Ca(c)),
      n.svg || (n.xOffset = n.yOffset = 0),
      (n.force3D = Qt.force3D),
      (n.renderTransform = n.svg ? Yp : Mf ? Af : jp),
      (n.uncache = 0),
      n
    );
  },
  Ca = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  io = function (e, t, n) {
    var i = Tt(t);
    return st(parseFloat(t) + parseFloat(Si(e, "x", n + "px", i))) + i;
  },
  jp = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      Af(e, t);
  },
  Ci = "0deg",
  ts = "0px",
  Pi = ") ",
  Af = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      r = n.yPercent,
      a = n.x,
      o = n.y,
      l = n.z,
      c = n.rotation,
      u = n.rotationY,
      d = n.rotationX,
      f = n.skewX,
      h = n.skewY,
      _ = n.scaleX,
      m = n.scaleY,
      g = n.transformPerspective,
      p = n.force3D,
      y = n.target,
      v = n.zOrigin,
      x = "",
      S = (p === "auto" && e && e !== 1) || p === !0;
    if (v && (d !== Ci || u !== Ci)) {
      var w = parseFloat(u) * Dr,
        A = Math.sin(w),
        C = Math.cos(w),
        M;
      (w = parseFloat(d) * Dr),
        (M = Math.cos(w)),
        (a = io(y, a, A * M * -v)),
        (o = io(y, o, -Math.sin(w) * -v)),
        (l = io(y, l, C * M * -v + v));
    }
    g !== ts && (x += "perspective(" + g + Pi),
      (i || r) && (x += "translate(" + i + "%, " + r + "%) "),
      (S || a !== ts || o !== ts || l !== ts) &&
        (x +=
          l !== ts || S
            ? "translate3d(" + a + ", " + o + ", " + l + ") "
            : "translate(" + a + ", " + o + Pi),
      c !== Ci && (x += "rotate(" + c + Pi),
      u !== Ci && (x += "rotateY(" + u + Pi),
      d !== Ci && (x += "rotateX(" + d + Pi),
      (f !== Ci || h !== Ci) && (x += "skew(" + f + ", " + h + Pi),
      (_ !== 1 || m !== 1) && (x += "scale(" + _ + ", " + m + Pi),
      (y.style[Je] = x || "translate(0, 0)");
  },
  Yp = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      r = n.yPercent,
      a = n.x,
      o = n.y,
      l = n.rotation,
      c = n.skewX,
      u = n.skewY,
      d = n.scaleX,
      f = n.scaleY,
      h = n.target,
      _ = n.xOrigin,
      m = n.yOrigin,
      g = n.xOffset,
      p = n.yOffset,
      y = n.forceCSS,
      v = parseFloat(a),
      x = parseFloat(o),
      S,
      w,
      A,
      C,
      M;
    (l = parseFloat(l)),
      (c = parseFloat(c)),
      (u = parseFloat(u)),
      u && ((u = parseFloat(u)), (c += u), (l += u)),
      l || c
        ? ((l *= Dr),
          (c *= Dr),
          (S = Math.cos(l) * d),
          (w = Math.sin(l) * d),
          (A = Math.sin(l - c) * -f),
          (C = Math.cos(l - c) * f),
          c &&
            ((u *= Dr),
            (M = Math.tan(c - u)),
            (M = Math.sqrt(1 + M * M)),
            (A *= M),
            (C *= M),
            u &&
              ((M = Math.tan(u)),
              (M = Math.sqrt(1 + M * M)),
              (S *= M),
              (w *= M))),
          (S = st(S)),
          (w = st(w)),
          (A = st(A)),
          (C = st(C)))
        : ((S = d), (C = f), (w = A = 0)),
      ((v && !~(a + "").indexOf("px")) || (x && !~(o + "").indexOf("px"))) &&
        ((v = Si(h, "x", a, "px")), (x = Si(h, "y", o, "px"))),
      (_ || m || g || p) &&
        ((v = st(v + _ - (_ * S + m * A) + g)),
        (x = st(x + m - (_ * w + m * C) + p))),
      (i || r) &&
        ((M = h.getBBox()),
        (v = st(v + (i / 100) * M.width)),
        (x = st(x + (r / 100) * M.height))),
      (M =
        "matrix(" + S + "," + w + "," + A + "," + C + "," + v + "," + x + ")"),
      h.setAttribute("transform", M),
      y && (h.style[Je] = M);
  },
  $p = function (e, t, n, i, r) {
    var a = 360,
      o = vt(r),
      l = parseFloat(r) * (o && ~r.indexOf("rad") ? Ii : 1),
      c = l - i,
      u = i + c + "deg",
      d,
      f;
    return (
      o &&
        ((d = r.split("_")[1]),
        d === "short" && ((c %= a), c !== c % (a / 2) && (c += c < 0 ? a : -a)),
        d === "cw" && c < 0
          ? (c = ((c + a * xc) % a) - ~~(c / a) * a)
          : d === "ccw" && c > 0 && (c = ((c - a * xc) % a) - ~~(c / a) * a)),
      (e._pt = f = new Bt(e._pt, t, n, i, c, Dp)),
      (f.e = u),
      (f.u = "deg"),
      e._props.push(n),
      f
    );
  },
  Tc = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  Kp = function (e, t, n) {
    var i = Tc({}, n._gsap),
      r = "perspective,force3D,transformOrigin,svgOrigin",
      a = n.style,
      o,
      l,
      c,
      u,
      d,
      f,
      h,
      _;
    i.svg
      ? ((c = n.getAttribute("transform")),
        n.setAttribute("transform", ""),
        (a[Je] = t),
        (o = As(n, 1)),
        $i(n, Je),
        n.setAttribute("transform", c))
      : ((c = getComputedStyle(n)[Je]),
        (a[Je] = t),
        (o = As(n, 1)),
        (a[Je] = c));
    for (l in Kn)
      (c = i[l]),
        (u = o[l]),
        c !== u &&
          r.indexOf(l) < 0 &&
          ((h = Tt(c)),
          (_ = Tt(u)),
          (d = h !== _ ? Si(n, l, c, _) : parseFloat(c)),
          (f = parseFloat(u)),
          (e._pt = new Bt(e._pt, o, l, d, f - d, nl)),
          (e._pt.u = _ || 0),
          e._props.push(l));
    Tc(o, i);
  };
zt("padding,margin,Width,Radius", function (s, e) {
  var t = "Top",
    n = "Right",
    i = "Bottom",
    r = "Left",
    a = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function (o) {
      return e < 2 ? s + o : "border" + o + s;
    });
  Aa[e > 1 ? "border" + s : s] = function (o, l, c, u, d) {
    var f, h;
    if (arguments.length < 4)
      return (
        (f = a.map(function (_) {
          return Gn(o, _, c);
        })),
        (h = f.join(" ")),
        h.split(f[0]).length === 5 ? f[0] : h
      );
    (f = (u + "").split(" ")),
      (h = {}),
      a.forEach(function (_, m) {
        return (h[_] = f[m] = f[m] || f[((m - 1) / 2) | 0]);
      }),
      o.init(l, h, d);
  };
});
var Cf = {
  name: "css",
  register: rl,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, n, i, r) {
    var a = this._props,
      o = e.style,
      l = n.vars.startAt,
      c,
      u,
      d,
      f,
      h,
      _,
      m,
      g,
      p,
      y,
      v,
      x,
      S,
      w,
      A,
      C;
    Ul || rl(),
      (this.styles = this.styles || Sf(e)),
      (C = this.styles.props),
      (this.tween = n);
    for (m in t)
      if (m !== "autoRound" && ((u = t[m]), !(Yt[m] && uf(m, t, n, i, e, r)))) {
        if (
          ((h = typeof u),
          (_ = Aa[m]),
          h === "function" && ((u = u.call(n, i, e, r)), (h = typeof u)),
          h === "string" && ~u.indexOf("random(") && (u = bs(u)),
          _)
        )
          _(this, e, m, u, n) && (A = 1);
        else if (m.substr(0, 2) === "--")
          (c = (getComputedStyle(e).getPropertyValue(m) + "").trim()),
            (u += ""),
            (vi.lastIndex = 0),
            vi.test(c) || ((g = Tt(c)), (p = Tt(u))),
            p ? g !== p && (c = Si(e, m, c, p) + p) : g && (u += g),
            this.add(o, "setProperty", c, u, i, r, 0, 0, m),
            a.push(m),
            C.push(m, 0, o[m]);
        else if (h !== "undefined") {
          if (
            (l && m in l
              ? ((c = typeof l[m] == "function" ? l[m].call(n, i, e, r) : l[m]),
                vt(c) && ~c.indexOf("random(") && (c = bs(c)),
                Tt(c + "") ||
                  c === "auto" ||
                  (c += Qt.units[m] || Tt(Gn(e, m)) || ""),
                (c + "").charAt(1) === "=" && (c = Gn(e, m)))
              : (c = Gn(e, m)),
            (f = parseFloat(c)),
            (y = h === "string" && u.charAt(1) === "=" && u.substr(0, 2)),
            y && (u = u.substr(2)),
            (d = parseFloat(u)),
            m in Tn &&
              (m === "autoAlpha" &&
                (f === 1 && Gn(e, "visibility") === "hidden" && d && (f = 0),
                C.push("visibility", 0, o.visibility),
                hi(
                  this,
                  o,
                  "visibility",
                  f ? "inherit" : "hidden",
                  d ? "inherit" : "hidden",
                  !d
                )),
              m !== "scale" &&
                m !== "transform" &&
                ((m = Tn[m]), ~m.indexOf(",") && (m = m.split(",")[0]))),
            (v = m in Kn),
            v)
          ) {
            if (
              (this.styles.save(m),
              x ||
                ((S = e._gsap),
                (S.renderTransform && !t.parseTransform) ||
                  As(e, t.parseTransform),
                (w = t.smoothOrigin !== !1 && S.smooth),
                (x = this._pt =
                  new Bt(this._pt, o, Je, 0, 1, S.renderTransform, S, 0, -1)),
                (x.dep = 1)),
              m === "scale")
            )
              (this._pt = new Bt(
                this._pt,
                S,
                "scaleY",
                S.scaleY,
                (y ? Lr(S.scaleY, y + d) : d) - S.scaleY || 0,
                nl
              )),
                (this._pt.u = 0),
                a.push("scaleY", m),
                (m += "X");
            else if (m === "transformOrigin") {
              C.push(Vt, 0, o[Vt]),
                (u = qp(u)),
                S.svg
                  ? sl(e, u, 0, w, 0, this)
                  : ((p = parseFloat(u.split(" ")[2]) || 0),
                    p !== S.zOrigin && hi(this, S, "zOrigin", S.zOrigin, p),
                    hi(this, o, m, Ca(c), Ca(u)));
              continue;
            } else if (m === "svgOrigin") {
              sl(e, u, 1, w, 0, this);
              continue;
            } else if (m in Tf) {
              $p(this, S, m, f, y ? Lr(f, y + u) : u);
              continue;
            } else if (m === "smoothOrigin") {
              hi(this, S, "smooth", S.smooth, u);
              continue;
            } else if (m === "force3D") {
              S[m] = u;
              continue;
            } else if (m === "transform") {
              Kp(this, u, e);
              continue;
            }
          } else m in o || (m = Vr(m) || m);
          if (v || ((d || d === 0) && (f || f === 0) && !Rp.test(u) && m in o))
            (g = (c + "").substr((f + "").length)),
              d || (d = 0),
              (p = Tt(u) || (m in Qt.units ? Qt.units[m] : g)),
              g !== p && (f = Si(e, m, c, p)),
              (this._pt = new Bt(
                this._pt,
                v ? S : o,
                m,
                f,
                (y ? Lr(f, y + d) : d) - f,
                !v && (p === "px" || m === "zIndex") && t.autoRound !== !1
                  ? Op
                  : nl
              )),
              (this._pt.u = p || 0),
              g !== p && p !== "%" && ((this._pt.b = c), (this._pt.r = Ip));
          else if (m in o) Wp.call(this, e, m, c, y ? y + u : u);
          else if (m in e) this.add(e, m, c || e[m], y ? y + u : u, i, r);
          else if (m !== "parseTransform") {
            Al(m, u);
            continue;
          }
          v || (m in o ? C.push(m, 0, o[m]) : C.push(m, 1, c || e[m])),
            a.push(m);
        }
      }
    A && gf(this);
  },
  render: function (e, t) {
    if (t.tween._time || !Fl())
      for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
    else t.styles.revert();
  },
  get: Gn,
  aliases: Tn,
  getSetter: function (e, t, n) {
    var i = Tn[t];
    return (
      i && i.indexOf(",") < 0 && (t = i),
      t in Kn && t !== Vt && (e._gsap.x || Gn(e, "x"))
        ? n && vc === n
          ? t === "scale"
            ? kp
            : Fp
          : (vc = n || {}) && (t === "scale" ? zp : Bp)
        : e.style && !wl(e.style[t])
        ? Np
        : ~t.indexOf("-")
        ? Up
        : Ol(e, t)
    );
  },
  core: { _removeProperty: $i, _getMatrix: zl },
};
Ht.utils.checkPrefix = Vr;
Ht.core.getStyleSaver = Sf;
(function (s, e, t, n) {
  var i = zt(s + "," + e + "," + t, function (r) {
    Kn[r] = 1;
  });
  zt(e, function (r) {
    (Qt.units[r] = "deg"), (Tf[r] = 1);
  }),
    (Tn[i[13]] = s + "," + e),
    zt(n, function (r) {
      var a = r.split(":");
      Tn[a[1]] = i[a[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
zt(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (s) {
    Qt.units[s] = "px";
  }
);
Ht.registerPlugin(Cf);
var Wn = Ht.registerPlugin(Cf) || Ht;
Wn.core.Tween;
function Ec(s, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    (n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      "value" in n && (n.writable = !0),
      Object.defineProperty(s, n.key, n);
  }
}
function Bl(s, e, t) {
  return e && Ec(s.prototype, e), t && Ec(s, t), s;
}
function zi() {
  return (zi =
    Object.assign ||
    function (s) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (s[n] = t[n]);
      }
      return s;
    }).apply(this, arguments);
}
function Fa(s, e) {
  (s.prototype = Object.create(e.prototype)),
    (s.prototype.constructor = s),
    (s.__proto__ = e);
}
function Pf(s) {
  return (Pf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      })(s);
}
function Vl(s, e) {
  return (Vl =
    Object.setPrototypeOf ||
    function (t, n) {
      return (t.__proto__ = n), t;
    })(s, e);
}
function Lf(s, e, t) {
  return (Lf = (function () {
    if (
      typeof Reflect == "undefined" ||
      !Reflect.construct ||
      Reflect.construct.sham
    )
      return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return (
        Date.prototype.toString.call(
          Reflect.construct(Date, [], function () {})
        ),
        !0
      );
    } catch {
      return !1;
    }
  })()
    ? Reflect.construct
    : function (n, i, r) {
        var a = [null];
        a.push.apply(a, i);
        var o = new (Function.bind.apply(n, a))();
        return r && Vl(o, r.prototype), o;
      }).apply(null, arguments);
}
function Rf(s) {
  var e = typeof Map == "function" ? new Map() : void 0;
  return (Rf = function (t) {
    if (t === null || Function.toString.call(t).indexOf("[native code]") === -1)
      return t;
    if (typeof t != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(t)) return e.get(t);
      e.set(t, n);
    }
    function n() {
      return Lf(t, arguments, Pf(this).constructor);
    }
    return (
      (n.prototype = Object.create(t.prototype, {
        constructor: {
          value: n,
          enumerable: !1,
          writable: !0,
          configurable: !0,
        },
      })),
      Vl(n, t)
    );
  })(s);
}
function wr(s, e) {
  try {
    var t = s();
  } catch (n) {
    return e(n);
  }
  return t && t.then ? t.then(void 0, e) : t;
}
typeof Symbol != "undefined" &&
  (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))),
  typeof Symbol != "undefined" &&
    (Symbol.asyncIterator ||
      (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
var ui,
  Zp = "2.9.7",
  Jp = function () {};
(function (s) {
  (s[(s.off = 0)] = "off"),
    (s[(s.error = 1)] = "error"),
    (s[(s.warning = 2)] = "warning"),
    (s[(s.info = 3)] = "info"),
    (s[(s.debug = 4)] = "debug");
})(ui || (ui = {}));
var Ac = ui.off,
  Bi = (function () {
    function s(t) {
      this.t = t;
    }
    (s.getLevel = function () {
      return Ac;
    }),
      (s.setLevel = function (t) {
        return (Ac = ui[t]);
      });
    var e = s.prototype;
    return (
      (e.error = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.error, ui.error, n);
      }),
      (e.warn = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.warn, ui.warning, n);
      }),
      (e.info = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.info, ui.info, n);
      }),
      (e.debug = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        this.i(console.log, ui.debug, n);
      }),
      (e.i = function (t, n, i) {
        n <= s.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(i));
      }),
      s
    );
  })(),
  Oi = Wl,
  Qp = If,
  em = Gl,
  tm = Of,
  nm = Nf,
  Df = "/",
  im = new RegExp(
    [
      "(\\\\.)",
      "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?",
    ].join("|"),
    "g"
  );
function Gl(s, e) {
  for (
    var t,
      n = [],
      i = 0,
      r = 0,
      a = "",
      o = (e && e.delimiter) || Df,
      l = (e && e.whitelist) || void 0,
      c = !1;
    (t = im.exec(s)) !== null;

  ) {
    var u = t[0],
      d = t[1],
      f = t.index;
    if (((a += s.slice(r, f)), (r = f + u.length), d)) (a += d[1]), (c = !0);
    else {
      var h = "",
        _ = t[2],
        m = t[3],
        g = t[4],
        p = t[5];
      if (!c && a.length) {
        var y = a.length - 1,
          v = a[y];
        (!l || l.indexOf(v) > -1) && ((h = v), (a = a.slice(0, y)));
      }
      a && (n.push(a), (a = ""), (c = !1));
      var x = m || g,
        S = h || o;
      n.push({
        name: _ || i++,
        prefix: h,
        delimiter: S,
        optional: p === "?" || p === "*",
        repeat: p === "+" || p === "*",
        pattern: x ? rm(x) : "[^" + Bn(S === o ? S : S + o) + "]+?",
      });
    }
  }
  return (a || r < s.length) && n.push(a + s.substr(r)), n;
}
function If(s, e) {
  return function (t, n) {
    var i = s.exec(t);
    if (!i) return !1;
    for (
      var r = i[0],
        a = i.index,
        o = {},
        l = (n && n.decode) || decodeURIComponent,
        c = 1;
      c < i.length;
      c++
    )
      if (i[c] !== void 0) {
        var u = e[c - 1];
        o[u.name] = u.repeat
          ? i[c].split(u.delimiter).map(function (d) {
              return l(d, u);
            })
          : l(i[c], u);
      }
    return { path: r, index: a, params: o };
  };
}
function Of(s, e) {
  for (var t = new Array(s.length), n = 0; n < s.length; n++)
    typeof s[n] == "object" &&
      (t[n] = new RegExp("^(?:" + s[n].pattern + ")$", Hl(e)));
  return function (i, r) {
    for (
      var a = "",
        o = (r && r.encode) || encodeURIComponent,
        l = !r || r.validate !== !1,
        c = 0;
      c < s.length;
      c++
    ) {
      var u = s[c];
      if (typeof u != "string") {
        var d,
          f = i ? i[u.name] : void 0;
        if (Array.isArray(f)) {
          if (!u.repeat)
            throw new TypeError(
              'Expected "' + u.name + '" to not repeat, but got array'
            );
          if (f.length === 0) {
            if (u.optional) continue;
            throw new TypeError('Expected "' + u.name + '" to not be empty');
          }
          for (var h = 0; h < f.length; h++) {
            if (((d = o(f[h], u)), l && !t[c].test(d)))
              throw new TypeError(
                'Expected all "' + u.name + '" to match "' + u.pattern + '"'
              );
            a += (h === 0 ? u.prefix : u.delimiter) + d;
          }
        } else if (
          typeof f != "string" &&
          typeof f != "number" &&
          typeof f != "boolean"
        ) {
          if (!u.optional)
            throw new TypeError(
              'Expected "' +
                u.name +
                '" to be ' +
                (u.repeat ? "an array" : "a string")
            );
        } else {
          if (((d = o(String(f), u)), l && !t[c].test(d)))
            throw new TypeError(
              'Expected "' +
                u.name +
                '" to match "' +
                u.pattern +
                '", but got "' +
                d +
                '"'
            );
          a += u.prefix + d;
        }
      } else a += u;
    }
    return a;
  };
}
function Bn(s) {
  return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function rm(s) {
  return s.replace(/([=!:$/()])/g, "\\$1");
}
function Hl(s) {
  return s && s.sensitive ? "" : "i";
}
function Nf(s, e, t) {
  for (
    var n = (t = t || {}).strict,
      i = t.start !== !1,
      r = t.end !== !1,
      a = t.delimiter || Df,
      o = []
        .concat(t.endsWith || [])
        .map(Bn)
        .concat("$")
        .join("|"),
      l = i ? "^" : "",
      c = 0;
    c < s.length;
    c++
  ) {
    var u = s[c];
    if (typeof u == "string") l += Bn(u);
    else {
      var d = u.repeat
        ? "(?:" +
          u.pattern +
          ")(?:" +
          Bn(u.delimiter) +
          "(?:" +
          u.pattern +
          "))*"
        : u.pattern;
      e && e.push(u),
        (l += u.optional
          ? u.prefix
            ? "(?:" + Bn(u.prefix) + "(" + d + "))?"
            : "(" + d + ")?"
          : Bn(u.prefix) + "(" + d + ")");
    }
  }
  if (r)
    n || (l += "(?:" + Bn(a) + ")?"), (l += o === "$" ? "$" : "(?=" + o + ")");
  else {
    var f = s[s.length - 1],
      h = typeof f == "string" ? f[f.length - 1] === a : f === void 0;
    n || (l += "(?:" + Bn(a) + "(?=" + o + "))?"),
      h || (l += "(?=" + Bn(a) + "|" + o + ")");
  }
  return new RegExp(l, Hl(t));
}
function Wl(s, e, t) {
  return s instanceof RegExp
    ? (function (n, i) {
        if (!i) return n;
        var r = n.source.match(/\((?!\?)/g);
        if (r)
          for (var a = 0; a < r.length; a++)
            i.push({
              name: a,
              prefix: null,
              delimiter: null,
              optional: !1,
              repeat: !1,
              pattern: null,
            });
        return n;
      })(s, e)
    : Array.isArray(s)
    ? (function (n, i, r) {
        for (var a = [], o = 0; o < n.length; o++)
          a.push(Wl(n[o], i, r).source);
        return new RegExp("(?:" + a.join("|") + ")", Hl(r));
      })(s, e, t)
    : (function (n, i, r) {
        return Nf(Gl(n, r), i, r);
      })(s, e, t);
}
(Oi.match = function (s, e) {
  var t = [];
  return If(Wl(s, t, e), t);
}),
  (Oi.regexpToFunction = Qp),
  (Oi.parse = em),
  (Oi.compile = function (s, e) {
    return Of(Gl(s, e), e);
  }),
  (Oi.tokensToFunction = tm),
  (Oi.tokensToRegExp = nm);
var Cn = {
    container: "container",
    history: "history",
    namespace: "namespace",
    prefix: "data-barba",
    prevent: "prevent",
    wrapper: "wrapper",
  },
  Vi = new ((function () {
    function s() {
      (this.o = Cn), (this.u = new DOMParser());
    }
    var e = s.prototype;
    return (
      (e.toString = function (t) {
        return t.outerHTML;
      }),
      (e.toDocument = function (t) {
        return this.u.parseFromString(t, "text/html");
      }),
      (e.toElement = function (t) {
        var n = document.createElement("div");
        return (n.innerHTML = t), n;
      }),
      (e.getHtml = function (t) {
        return t === void 0 && (t = document), this.toString(t.documentElement);
      }),
      (e.getWrapper = function (t) {
        return (
          t === void 0 && (t = document),
          t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
        );
      }),
      (e.getContainer = function (t) {
        return (
          t === void 0 && (t = document),
          t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
        );
      }),
      (e.removeContainer = function (t) {
        document.body.contains(t) && t.parentNode.removeChild(t);
      }),
      (e.addContainer = function (t, n) {
        var i = this.getContainer();
        i ? this.s(t, i) : n.appendChild(t);
      }),
      (e.getNamespace = function (t) {
        t === void 0 && (t = document);
        var n = t.querySelector(
          "[" + this.o.prefix + "-" + this.o.namespace + "]"
        );
        return n
          ? n.getAttribute(this.o.prefix + "-" + this.o.namespace)
          : null;
      }),
      (e.getHref = function (t) {
        if (t.tagName && t.tagName.toLowerCase() === "a") {
          if (typeof t.href == "string") return t.href;
          var n = t.getAttribute("href") || t.getAttribute("xlink:href");
          if (n) return this.resolveUrl(n.baseVal || n);
        }
        return null;
      }),
      (e.resolveUrl = function () {
        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
          n[i] = arguments[i];
        var r = n.length;
        if (r === 0)
          throw new Error(
            "resolveUrl requires at least one argument; got none."
          );
        var a = document.createElement("base");
        if (((a.href = arguments[0]), r === 1)) return a.href;
        var o = document.getElementsByTagName("head")[0];
        o.insertBefore(a, o.firstChild);
        for (var l, c = document.createElement("a"), u = 1; u < r; u++)
          (c.href = arguments[u]), (a.href = l = c.href);
        return o.removeChild(a), l;
      }),
      (e.s = function (t, n) {
        n.parentNode.insertBefore(t, n.nextSibling);
      }),
      s
    );
  })())(),
  Uf = new ((function () {
    function s() {
      (this.h = []), (this.v = -1);
    }
    var e = s.prototype;
    return (
      (e.init = function (t, n) {
        this.l = "barba";
        var i = {
          ns: n,
          scroll: { x: window.scrollX, y: window.scrollY },
          url: t,
        };
        this.h.push(i), (this.v = 0);
        var r = { from: this.l, index: 0, states: [].concat(this.h) };
        window.history && window.history.replaceState(r, "", t);
      }),
      (e.change = function (t, n, i) {
        if (i && i.state) {
          var r = i.state,
            a = r.index;
          (n = this.m(this.v - a)), this.replace(r.states), (this.v = a);
        } else this.add(t, n);
        return n;
      }),
      (e.add = function (t, n) {
        var i = this.size,
          r = this.p(n),
          a = {
            ns: "tmp",
            scroll: { x: window.scrollX, y: window.scrollY },
            url: t,
          };
        this.h.push(a), (this.v = i);
        var o = { from: this.l, index: i, states: [].concat(this.h) };
        switch (r) {
          case "push":
            window.history && window.history.pushState(o, "", t);
            break;
          case "replace":
            window.history && window.history.replaceState(o, "", t);
        }
      }),
      (e.update = function (t, n) {
        var i = n || this.v,
          r = zi({}, this.get(i), {}, t);
        this.set(i, r);
      }),
      (e.remove = function (t) {
        t ? this.h.splice(t, 1) : this.h.pop(), this.v--;
      }),
      (e.clear = function () {
        (this.h = []), (this.v = -1);
      }),
      (e.replace = function (t) {
        this.h = t;
      }),
      (e.get = function (t) {
        return this.h[t];
      }),
      (e.set = function (t, n) {
        return (this.h[t] = n);
      }),
      (e.p = function (t) {
        var n = "push",
          i = t,
          r = Cn.prefix + "-" + Cn.history;
        return (
          i.hasAttribute && i.hasAttribute(r) && (n = i.getAttribute(r)), n
        );
      }),
      (e.m = function (t) {
        return Math.abs(t) > 1
          ? t > 0
            ? "forward"
            : "back"
          : t === 0
          ? "popstate"
          : t > 0
          ? "back"
          : "forward";
      }),
      Bl(s, [
        {
          key: "current",
          get: function () {
            return this.h[this.v];
          },
        },
        {
          key: "state",
          get: function () {
            return this.h[this.h.length - 1];
          },
        },
        {
          key: "previous",
          get: function () {
            return this.v < 1 ? null : this.h[this.v - 1];
          },
        },
        {
          key: "size",
          get: function () {
            return this.h.length;
          },
        },
      ]),
      s
    );
  })())(),
  Pa = function (s, e) {
    try {
      var t = (function () {
        if (!e.next.html)
          return Promise.resolve(s).then(function (n) {
            var i = e.next;
            if (n) {
              var r = Vi.toElement(n);
              (i.namespace = Vi.getNamespace(r)),
                (i.container = Vi.getContainer(r)),
                (i.html = n),
                Uf.update({ ns: i.namespace });
              var a = Vi.toDocument(n);
              document.title = a.title;
            }
          });
      })();
      return Promise.resolve(t && t.then ? t.then(function () {}) : void 0);
    } catch (n) {
      return Promise.reject(n);
    }
  },
  Ff = Oi,
  sm = {
    __proto__: null,
    update: Pa,
    nextTick: function () {
      return new Promise(function (s) {
        window.requestAnimationFrame(s);
      });
    },
    pathToRegexp: Ff,
  },
  kf = function () {
    return window.location.origin;
  },
  Cs = function (s) {
    return s === void 0 && (s = window.location.href), La(s).port;
  },
  La = function (s) {
    var e,
      t = s.match(/:\d+/);
    if (t === null) /^http/.test(s) && (e = 80), /^https/.test(s) && (e = 443);
    else {
      var n = t[0].substring(1);
      e = parseInt(n, 10);
    }
    var i,
      r = s.replace(kf(), ""),
      a = {},
      o = r.indexOf("#");
    o >= 0 && ((i = r.slice(o + 1)), (r = r.slice(0, o)));
    var l = r.indexOf("?");
    return (
      l >= 0 && ((a = zf(r.slice(l + 1))), (r = r.slice(0, l))),
      { hash: i, path: r, port: e, query: a }
    );
  },
  zf = function (s) {
    return s.split("&").reduce(function (e, t) {
      var n = t.split("=");
      return (e[n[0]] = n[1]), e;
    }, {});
  },
  al = function (s) {
    return (
      s === void 0 && (s = window.location.href),
      s.replace(/(\/#.*|\/|#.*)$/, "")
    );
  },
  am = {
    __proto__: null,
    getHref: function () {
      return window.location.href;
    },
    getOrigin: kf,
    getPort: Cs,
    getPath: function (s) {
      return s === void 0 && (s = window.location.href), La(s).path;
    },
    parse: La,
    parseQuery: zf,
    clean: al,
  };
function om(s, e, t) {
  return (
    e === void 0 && (e = 2e3),
    new Promise(function (n, i) {
      var r = new XMLHttpRequest();
      (r.onreadystatechange = function () {
        if (r.readyState === XMLHttpRequest.DONE) {
          if (r.status === 200) n(r.responseText);
          else if (r.status) {
            var a = { status: r.status, statusText: r.statusText };
            t(s, a), i(a);
          }
        }
      }),
        (r.ontimeout = function () {
          var a = new Error("Timeout error [" + e + "]");
          t(s, a), i(a);
        }),
        (r.onerror = function () {
          var a = new Error("Fetch error");
          t(s, a), i(a);
        }),
        r.open("GET", s),
        (r.timeout = e),
        r.setRequestHeader(
          "Accept",
          "text/html,application/xhtml+xml,application/xml"
        ),
        r.setRequestHeader("x-barba", "yes"),
        r.send();
    })
  );
}
var lm = function (s) {
  return (
    !!s &&
    (typeof s == "object" || typeof s == "function") &&
    typeof s.then == "function"
  );
};
function Cr(s, e) {
  return (
    e === void 0 && (e = {}),
    function () {
      for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
        n[i] = arguments[i];
      var r = !1,
        a = new Promise(function (o, l) {
          e.async = function () {
            return (
              (r = !0),
              function (u, d) {
                u ? l(u) : o(d);
              }
            );
          };
          var c = s.apply(e, n);
          r || (lm(c) ? c.then(o, l) : o(c));
        });
      return a;
    }
  );
}
var li = new ((function (s) {
    function e() {
      var n;
      return (
        ((n = s.call(this) || this).logger = new Bi("@barba/core")),
        (n.all = [
          "ready",
          "page",
          "reset",
          "currentAdded",
          "currentRemoved",
          "nextAdded",
          "nextRemoved",
          "beforeOnce",
          "once",
          "afterOnce",
          "before",
          "beforeLeave",
          "leave",
          "afterLeave",
          "beforeEnter",
          "enter",
          "afterEnter",
          "after",
        ]),
        (n.registered = new Map()),
        n.init(),
        n
      );
    }
    Fa(e, s);
    var t = e.prototype;
    return (
      (t.init = function () {
        var n = this;
        this.registered.clear(),
          this.all.forEach(function (i) {
            n[i] ||
              (n[i] = function (r, a) {
                n.registered.has(i) || n.registered.set(i, new Set()),
                  n.registered.get(i).add({ ctx: a || {}, fn: r });
              });
          });
      }),
      (t.do = function (n) {
        for (
          var i = this,
            r = arguments.length,
            a = new Array(r > 1 ? r - 1 : 0),
            o = 1;
          o < r;
          o++
        )
          a[o - 1] = arguments[o];
        if (this.registered.has(n)) {
          var l = Promise.resolve();
          return (
            this.registered.get(n).forEach(function (c) {
              l = l.then(function () {
                return Cr(c.fn, c.ctx).apply(void 0, a);
              });
            }),
            l.catch(function (c) {
              i.logger.debug("Hook error [" + n + "]"), i.logger.error(c);
            })
          );
        }
        return Promise.resolve();
      }),
      (t.clear = function () {
        var n = this;
        this.all.forEach(function (i) {
          delete n[i];
        }),
          this.init();
      }),
      (t.help = function () {
        this.logger.info("Available hooks: " + this.all.join(","));
        var n = [];
        this.registered.forEach(function (i, r) {
          return n.push(r);
        }),
          this.logger.info("Registered hooks: " + n.join(","));
      }),
      e
    );
  })(Jp))(),
  Bf = (function () {
    function s(e) {
      if (((this.P = []), typeof e == "boolean")) this.g = e;
      else {
        var t = Array.isArray(e) ? e : [e];
        this.P = t.map(function (n) {
          return Ff(n);
        });
      }
    }
    return (
      (s.prototype.checkHref = function (e) {
        if (typeof this.g == "boolean") return this.g;
        var t = La(e).path;
        return this.P.some(function (n) {
          return n.exec(t) !== null;
        });
      }),
      s
    );
  })(),
  cm = (function (s) {
    function e(n) {
      var i;
      return ((i = s.call(this, n) || this).k = new Map()), i;
    }
    Fa(e, s);
    var t = e.prototype;
    return (
      (t.set = function (n, i, r) {
        return (
          this.k.set(n, { action: r, request: i }), { action: r, request: i }
        );
      }),
      (t.get = function (n) {
        return this.k.get(n);
      }),
      (t.getRequest = function (n) {
        return this.k.get(n).request;
      }),
      (t.getAction = function (n) {
        return this.k.get(n).action;
      }),
      (t.has = function (n) {
        return !this.checkHref(n) && this.k.has(n);
      }),
      (t.delete = function (n) {
        return this.k.delete(n);
      }),
      (t.update = function (n, i) {
        var r = zi({}, this.k.get(n), {}, i);
        return this.k.set(n, r), r;
      }),
      e
    );
  })(Bf),
  um = function () {
    return !window.history.pushState;
  },
  dm = function (s) {
    return !s.el || !s.href;
  },
  fm = function (s) {
    var e = s.event;
    return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey;
  },
  hm = function (s) {
    var e = s.el;
    return e.hasAttribute("target") && e.target === "_blank";
  },
  pm = function (s) {
    var e = s.el;
    return (
      (e.protocol !== void 0 && window.location.protocol !== e.protocol) ||
      (e.hostname !== void 0 && window.location.hostname !== e.hostname)
    );
  },
  mm = function (s) {
    var e = s.el;
    return e.port !== void 0 && Cs() !== Cs(e.href);
  },
  gm = function (s) {
    var e = s.el;
    return e.getAttribute && typeof e.getAttribute("download") == "string";
  },
  _m = function (s) {
    return s.el.hasAttribute(Cn.prefix + "-" + Cn.prevent);
  },
  vm = function (s) {
    return Boolean(
      s.el.closest("[" + Cn.prefix + "-" + Cn.prevent + '="all"]')
    );
  },
  xm = function (s) {
    var e = s.href;
    return al(e) === al() && Cs(e) === Cs();
  },
  ym = (function (s) {
    function e(n) {
      var i;
      return (
        ((i = s.call(this, n) || this).suite = []),
        (i.tests = new Map()),
        i.init(),
        i
      );
    }
    Fa(e, s);
    var t = e.prototype;
    return (
      (t.init = function () {
        this.add("pushState", um),
          this.add("exists", dm),
          this.add("newTab", fm),
          this.add("blank", hm),
          this.add("corsDomain", pm),
          this.add("corsPort", mm),
          this.add("download", gm),
          this.add("preventSelf", _m),
          this.add("preventAll", vm),
          this.add("sameUrl", xm, !1);
      }),
      (t.add = function (n, i, r) {
        r === void 0 && (r = !0), this.tests.set(n, i), r && this.suite.push(n);
      }),
      (t.run = function (n, i, r, a) {
        return this.tests.get(n)({ el: i, event: r, href: a });
      }),
      (t.checkLink = function (n, i, r) {
        var a = this;
        return this.suite.some(function (o) {
          return a.run(o, n, i, r);
        });
      }),
      e
    );
  })(Bf),
  ro = (function (s) {
    function e(t, n) {
      var i;
      n === void 0 && (n = "Barba error");
      for (
        var r = arguments.length, a = new Array(r > 2 ? r - 2 : 0), o = 2;
        o < r;
        o++
      )
        a[o - 2] = arguments[o];
      return (
        ((i = s.call.apply(s, [this].concat(a)) || this).error = t),
        (i.label = n),
        Error.captureStackTrace &&
          Error.captureStackTrace(
            (function (l) {
              if (l === void 0)
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                );
              return l;
            })(i),
            e
          ),
        (i.name = "BarbaError"),
        i
      );
    }
    return Fa(e, s), e;
  })(Rf(Error)),
  Sm = (function () {
    function s(t) {
      t === void 0 && (t = []),
        (this.logger = new Bi("@barba/core")),
        (this.all = []),
        (this.page = []),
        (this.once = []),
        (this.A = [
          { name: "namespace", type: "strings" },
          { name: "custom", type: "function" },
        ]),
        t && (this.all = this.all.concat(t)),
        this.update();
    }
    var e = s.prototype;
    return (
      (e.add = function (t, n) {
        switch (t) {
          case "rule":
            this.A.splice(n.position || 0, 0, n.value);
            break;
          case "transition":
          default:
            this.all.push(n);
        }
        this.update();
      }),
      (e.resolve = function (t, n) {
        var i = this;
        n === void 0 && (n = {});
        var r = n.once ? this.once : this.page;
        r = r.filter(
          n.self
            ? function (f) {
                return f.name && f.name === "self";
              }
            : function (f) {
                return !f.name || f.name !== "self";
              }
        );
        var a = new Map(),
          o = r.find(function (f) {
            var h = !0,
              _ = {};
            return (
              !(!n.self || f.name !== "self") ||
              (i.A.reverse().forEach(function (m) {
                h &&
                  ((h = i.R(f, m, t, _)),
                  f.from &&
                    f.to &&
                    (h = i.R(f, m, t, _, "from") && i.R(f, m, t, _, "to")),
                  f.from && !f.to && (h = i.R(f, m, t, _, "from")),
                  !f.from && f.to && (h = i.R(f, m, t, _, "to")));
              }),
              a.set(f, _),
              h)
            );
          }),
          l = a.get(o),
          c = [];
        if ((c.push(n.once ? "once" : "page"), n.self && c.push("self"), l)) {
          var u,
            d = [o];
          Object.keys(l).length > 0 && d.push(l),
            (u = this.logger).info.apply(
              u,
              ["Transition found [" + c.join(",") + "]"].concat(d)
            );
        } else this.logger.info("No transition found [" + c.join(",") + "]");
        return o;
      }),
      (e.update = function () {
        var t = this;
        (this.all = this.all
          .map(function (n) {
            return t.T(n);
          })
          .sort(function (n, i) {
            return n.priority - i.priority;
          })
          .reverse()
          .map(function (n) {
            return delete n.priority, n;
          })),
          (this.page = this.all.filter(function (n) {
            return n.leave !== void 0 || n.enter !== void 0;
          })),
          (this.once = this.all.filter(function (n) {
            return n.once !== void 0;
          }));
      }),
      (e.R = function (t, n, i, r, a) {
        var o = !0,
          l = !1,
          c = t,
          u = n.name,
          d = u,
          f = u,
          h = u,
          _ = a ? c[a] : c,
          m = a === "to" ? i.next : i.current;
        if (a ? _ && _[u] : _[u]) {
          switch (n.type) {
            case "strings":
            default:
              var g = Array.isArray(_[d]) ? _[d] : [_[d]];
              m[d] && g.indexOf(m[d]) !== -1 && (l = !0),
                g.indexOf(m[d]) === -1 && (o = !1);
              break;
            case "object":
              var p = Array.isArray(_[f]) ? _[f] : [_[f]];
              m[f]
                ? (m[f].name && p.indexOf(m[f].name) !== -1 && (l = !0),
                  p.indexOf(m[f].name) === -1 && (o = !1))
                : (o = !1);
              break;
            case "function":
              _[h](i) ? (l = !0) : (o = !1);
          }
          l && (a ? ((r[a] = r[a] || {}), (r[a][u] = c[a][u])) : (r[u] = c[u]));
        }
        return o;
      }),
      (e.O = function (t, n, i) {
        var r = 0;
        return (
          (t[n] || (t.from && t.from[n]) || (t.to && t.to[n])) &&
            ((r += Math.pow(10, i)),
            t.from && t.from[n] && (r += 1),
            t.to && t.to[n] && (r += 2)),
          r
        );
      }),
      (e.T = function (t) {
        var n = this;
        t.priority = 0;
        var i = 0;
        return (
          this.A.forEach(function (r, a) {
            i += n.O(t, r.name, a + 1);
          }),
          (t.priority = i),
          t
        );
      }),
      s
    );
  })(),
  Mm = (function () {
    function s(t) {
      t === void 0 && (t = []),
        (this.logger = new Bi("@barba/core")),
        (this.S = !1),
        (this.store = new Sm(t));
    }
    var e = s.prototype;
    return (
      (e.get = function (t, n) {
        return this.store.resolve(t, n);
      }),
      (e.doOnce = function (t) {
        var n = t.data,
          i = t.transition;
        try {
          var r = function () {
              a.S = !1;
            },
            a = this,
            o = i || {};
          a.S = !0;
          var l = wr(
            function () {
              return Promise.resolve(a.j("beforeOnce", n, o)).then(function () {
                return Promise.resolve(a.once(n, o)).then(function () {
                  return Promise.resolve(a.j("afterOnce", n, o)).then(
                    function () {}
                  );
                });
              });
            },
            function (c) {
              (a.S = !1),
                a.logger.debug("Transition error [before/after/once]"),
                a.logger.error(c);
            }
          );
          return Promise.resolve(l && l.then ? l.then(r) : r());
        } catch (c) {
          return Promise.reject(c);
        }
      }),
      (e.doPage = function (t) {
        var n = t.data,
          i = t.transition,
          r = t.page,
          a = t.wrapper;
        try {
          var o = function (h) {
              if (l) return h;
              c.S = !1;
            },
            l = !1,
            c = this,
            u = i || {},
            d = u.sync === !0 || !1;
          c.S = !0;
          var f = wr(
            function () {
              function h() {
                return Promise.resolve(c.j("before", n, u)).then(function () {
                  var m = !1;
                  function g(y) {
                    return m
                      ? y
                      : Promise.resolve(c.remove(n)).then(function () {
                          return Promise.resolve(c.j("after", n, u)).then(
                            function () {}
                          );
                        });
                  }
                  var p = (function () {
                    if (d)
                      return wr(
                        function () {
                          return Promise.resolve(c.add(n, a)).then(function () {
                            return Promise.resolve(
                              c.j("beforeLeave", n, u)
                            ).then(function () {
                              return Promise.resolve(
                                c.j("beforeEnter", n, u)
                              ).then(function () {
                                return Promise.resolve(
                                  Promise.all([c.leave(n, u), c.enter(n, u)])
                                ).then(function () {
                                  return Promise.resolve(
                                    c.j("afterLeave", n, u)
                                  ).then(function () {
                                    return Promise.resolve(
                                      c.j("afterEnter", n, u)
                                    ).then(function () {});
                                  });
                                });
                              });
                            });
                          });
                        },
                        function (S) {
                          if (c.M(S))
                            throw new ro(S, "Transition error [sync]");
                        }
                      );
                    var y = function (S) {
                        return m
                          ? S
                          : wr(
                              function () {
                                var w = (function () {
                                  if (v !== !1)
                                    return Promise.resolve(c.add(n, a)).then(
                                      function () {
                                        return Promise.resolve(
                                          c.j("beforeEnter", n, u)
                                        ).then(function () {
                                          return Promise.resolve(
                                            c.enter(n, u, v)
                                          ).then(function () {
                                            return Promise.resolve(
                                              c.j("afterEnter", n, u)
                                            ).then(function () {});
                                          });
                                        });
                                      }
                                    );
                                })();
                                if (w && w.then) return w.then(function () {});
                              },
                              function (w) {
                                if (c.M(w))
                                  throw new ro(
                                    w,
                                    "Transition error [before/after/enter]"
                                  );
                              }
                            );
                      },
                      v = !1,
                      x = wr(
                        function () {
                          return Promise.resolve(c.j("beforeLeave", n, u)).then(
                            function () {
                              return Promise.resolve(
                                Promise.all([c.leave(n, u), Pa(r, n)]).then(
                                  function (S) {
                                    return S[0];
                                  }
                                )
                              ).then(function (S) {
                                return (
                                  (v = S),
                                  Promise.resolve(c.j("afterLeave", n, u)).then(
                                    function () {}
                                  )
                                );
                              });
                            }
                          );
                        },
                        function (S) {
                          if (c.M(S))
                            throw new ro(
                              S,
                              "Transition error [before/after/leave]"
                            );
                        }
                      );
                    return x && x.then ? x.then(y) : y(x);
                  })();
                  return p && p.then ? p.then(g) : g(p);
                });
              }
              var _ = (function () {
                if (d) return Promise.resolve(Pa(r, n)).then(function () {});
              })();
              return _ && _.then ? _.then(h) : h();
            },
            function (h) {
              throw (
                ((c.S = !1),
                h.name && h.name === "BarbaError"
                  ? (c.logger.debug(h.label), c.logger.error(h.error), h)
                  : (c.logger.debug("Transition error [page]"),
                    c.logger.error(h),
                    h))
              );
            }
          );
          return Promise.resolve(f && f.then ? f.then(o) : o(f));
        } catch (h) {
          return Promise.reject(h);
        }
      }),
      (e.once = function (t, n) {
        try {
          return Promise.resolve(li.do("once", t, n)).then(function () {
            return n.once ? Cr(n.once, n)(t) : Promise.resolve();
          });
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.leave = function (t, n) {
        try {
          return Promise.resolve(li.do("leave", t, n)).then(function () {
            return n.leave ? Cr(n.leave, n)(t) : Promise.resolve();
          });
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.enter = function (t, n, i) {
        try {
          return Promise.resolve(li.do("enter", t, n)).then(function () {
            return n.enter ? Cr(n.enter, n)(t, i) : Promise.resolve();
          });
        } catch (r) {
          return Promise.reject(r);
        }
      }),
      (e.add = function (t, n) {
        try {
          return (
            Vi.addContainer(t.next.container, n),
            li.do("nextAdded", t),
            Promise.resolve()
          );
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.remove = function (t) {
        try {
          return (
            Vi.removeContainer(t.current.container),
            li.do("currentRemoved", t),
            Promise.resolve()
          );
        } catch (n) {
          return Promise.reject(n);
        }
      }),
      (e.M = function (t) {
        return t.message
          ? !/Timeout error|Fetch error/.test(t.message)
          : !t.status;
      }),
      (e.j = function (t, n, i) {
        try {
          return Promise.resolve(li.do(t, n, i)).then(function () {
            return i[t] ? Cr(i[t], i)(n) : Promise.resolve();
          });
        } catch (r) {
          return Promise.reject(r);
        }
      }),
      Bl(s, [
        {
          key: "isRunning",
          get: function () {
            return this.S;
          },
          set: function (t) {
            this.S = t;
          },
        },
        {
          key: "hasOnce",
          get: function () {
            return this.store.once.length > 0;
          },
        },
        {
          key: "hasSelf",
          get: function () {
            return this.store.all.some(function (t) {
              return t.name === "self";
            });
          },
        },
        {
          key: "shouldWait",
          get: function () {
            return this.store.all.some(function (t) {
              return (t.to && !t.to.route) || t.sync;
            });
          },
        },
      ]),
      s
    );
  })(),
  bm = (function () {
    function s(e) {
      var t = this;
      (this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"]),
        (this.byNamespace = new Map()),
        e.length !== 0 &&
          (e.forEach(function (n) {
            t.byNamespace.set(n.namespace, n);
          }),
          this.names.forEach(function (n) {
            li[n](t.L(n));
          }));
    }
    return (
      (s.prototype.L = function (e) {
        var t = this;
        return function (n) {
          var i = e.match(/enter/i) ? n.next : n.current,
            r = t.byNamespace.get(i.namespace);
          return r && r[e] ? Cr(r[e], r)(n) : Promise.resolve();
        };
      }),
      s
    );
  })();
Element.prototype.matches ||
  (Element.prototype.matches =
    Element.prototype.msMatchesSelector ||
    Element.prototype.webkitMatchesSelector),
  Element.prototype.closest ||
    (Element.prototype.closest = function (s) {
      var e = this;
      do {
        if (e.matches(s)) return e;
        e = e.parentElement || e.parentNode;
      } while (e !== null && e.nodeType === 1);
      return null;
    });
var wm = {
    container: null,
    html: "",
    namespace: "",
    url: { hash: "", href: "", path: "", port: null, query: {} },
  },
  ql = new ((function () {
    function s() {
      (this.version = Zp),
        (this.schemaPage = wm),
        (this.Logger = Bi),
        (this.logger = new Bi("@barba/core")),
        (this.plugins = []),
        (this.hooks = li),
        (this.dom = Vi),
        (this.helpers = sm),
        (this.history = Uf),
        (this.request = om),
        (this.url = am);
    }
    var e = s.prototype;
    return (
      (e.use = function (t, n) {
        var i = this.plugins;
        i.indexOf(t) > -1
          ? this.logger.warn("Plugin [" + t.name + "] already installed.")
          : typeof t.install == "function"
          ? (t.install(this, n), i.push(t))
          : this.logger.warn(
              "Plugin [" + t.name + '] has no "install" method.'
            );
      }),
      (e.init = function (t) {
        var n = t === void 0 ? {} : t,
          i = n.transitions,
          r = i === void 0 ? [] : i,
          a = n.views,
          o = a === void 0 ? [] : a,
          l = n.schema,
          c = l === void 0 ? Cn : l,
          u = n.requestError,
          d = n.timeout,
          f = d === void 0 ? 2e3 : d,
          h = n.cacheIgnore,
          _ = h !== void 0 && h,
          m = n.prefetchIgnore,
          g = m !== void 0 && m,
          p = n.preventRunning,
          y = p !== void 0 && p,
          v = n.prevent,
          x = v === void 0 ? null : v,
          S = n.debug,
          w = n.logLevel;
        if (
          (Bi.setLevel(
            (S !== void 0 && S) === !0 ? "debug" : w === void 0 ? "off" : w
          ),
          this.logger.info(this.version),
          Object.keys(c).forEach(function (M) {
            Cn[M] && (Cn[M] = c[M]);
          }),
          (this.$ = u),
          (this.timeout = f),
          (this.cacheIgnore = _),
          (this.prefetchIgnore = g),
          (this.preventRunning = y),
          (this._ = this.dom.getWrapper()),
          !this._)
        )
          throw new Error("[@barba/core] No Barba wrapper found");
        this._.setAttribute("aria-live", "polite"), this.q();
        var A = this.data.current;
        if (!A.container)
          throw new Error("[@barba/core] No Barba container found");
        if (
          ((this.cache = new cm(_)),
          (this.prevent = new ym(g)),
          (this.transitions = new Mm(r)),
          (this.views = new bm(o)),
          x !== null)
        ) {
          if (typeof x != "function")
            throw new Error("[@barba/core] Prevent should be a function");
          this.prevent.add("preventCustom", x);
        }
        this.history.init(A.url.href, A.namespace),
          (this.B = this.B.bind(this)),
          (this.U = this.U.bind(this)),
          (this.D = this.D.bind(this)),
          this.F(),
          this.plugins.forEach(function (M) {
            return M.init();
          });
        var C = this.data;
        (C.trigger = "barba"),
          (C.next = C.current),
          (C.current = zi({}, this.schemaPage)),
          this.hooks.do("ready", C),
          this.once(C),
          this.q();
      }),
      (e.destroy = function () {
        this.q(),
          this.H(),
          this.history.clear(),
          this.hooks.clear(),
          (this.plugins = []);
      }),
      (e.force = function (t) {
        window.location.assign(t);
      }),
      (e.go = function (t, n, i) {
        var r;
        if ((n === void 0 && (n = "barba"), this.transitions.isRunning))
          this.force(t);
        else if (
          !(r =
            n === "popstate"
              ? this.history.current &&
                this.url.getPath(this.history.current.url) ===
                  this.url.getPath(t)
              : this.prevent.run("sameUrl", null, null, t)) ||
          this.transitions.hasSelf
        )
          return (
            (n = this.history.change(t, n, i)),
            i && (i.stopPropagation(), i.preventDefault()),
            this.page(t, n, r)
          );
      }),
      (e.once = function (t) {
        try {
          var n = this;
          return Promise.resolve(n.hooks.do("beforeEnter", t)).then(
            function () {
              function i() {
                return Promise.resolve(n.hooks.do("afterEnter", t)).then(
                  function () {}
                );
              }
              var r = (function () {
                if (n.transitions.hasOnce) {
                  var a = n.transitions.get(t, { once: !0 });
                  return Promise.resolve(
                    n.transitions.doOnce({ transition: a, data: t })
                  ).then(function () {});
                }
              })();
              return r && r.then ? r.then(i) : i();
            }
          );
        } catch (i) {
          return Promise.reject(i);
        }
      }),
      (e.page = function (t, n, i) {
        try {
          var r = function () {
              var c = a.data;
              return Promise.resolve(a.hooks.do("page", c)).then(function () {
                var u = wr(
                  function () {
                    var d = a.transitions.get(c, { once: !1, self: i });
                    return Promise.resolve(
                      a.transitions.doPage({
                        data: c,
                        page: o,
                        transition: d,
                        wrapper: a._,
                      })
                    ).then(function () {
                      a.q();
                    });
                  },
                  function () {
                    Bi.getLevel() === 0 && a.force(c.current.url.href);
                  }
                );
                if (u && u.then) return u.then(function () {});
              });
            },
            a = this;
          (a.data.next.url = zi({ href: t }, a.url.parse(t))),
            (a.data.trigger = n);
          var o = a.cache.has(t)
              ? a.cache.update(t, { action: "click" }).request
              : a.cache.set(
                  t,
                  a.request(t, a.timeout, a.onRequestError.bind(a, n)),
                  "click"
                ).request,
            l = (function () {
              if (a.transitions.shouldWait)
                return Promise.resolve(Pa(o, a.data)).then(function () {});
            })();
          return Promise.resolve(l && l.then ? l.then(r) : r());
        } catch (c) {
          return Promise.reject(c);
        }
      }),
      (e.onRequestError = function (t) {
        this.transitions.isRunning = !1;
        for (
          var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1;
          r < n;
          r++
        )
          i[r - 1] = arguments[r];
        var a = i[0],
          o = i[1],
          l = this.cache.getAction(a);
        return (
          this.cache.delete(a),
          !(
            (this.$ && this.$(t, l, a, o) === !1) ||
            (l === "click" && this.force(a), 1)
          )
        );
      }),
      (e.prefetch = function (t) {
        var n = this;
        this.cache.has(t) ||
          this.cache.set(
            t,
            this.request(
              t,
              this.timeout,
              this.onRequestError.bind(this, "barba")
            ).catch(function (i) {
              n.logger.error(i);
            }),
            "prefetch"
          );
      }),
      (e.F = function () {
        this.prefetchIgnore !== !0 &&
          (document.addEventListener("mouseover", this.B),
          document.addEventListener("touchstart", this.B)),
          document.addEventListener("click", this.U),
          window.addEventListener("popstate", this.D);
      }),
      (e.H = function () {
        this.prefetchIgnore !== !0 &&
          (document.removeEventListener("mouseover", this.B),
          document.removeEventListener("touchstart", this.B)),
          document.removeEventListener("click", this.U),
          window.removeEventListener("popstate", this.D);
      }),
      (e.B = function (t) {
        var n = this,
          i = this.I(t);
        if (i) {
          var r = this.dom.getHref(i);
          this.prevent.checkHref(r) ||
            this.cache.has(r) ||
            this.cache.set(
              r,
              this.request(
                r,
                this.timeout,
                this.onRequestError.bind(this, i)
              ).catch(function (a) {
                n.logger.error(a);
              }),
              "enter"
            );
        }
      }),
      (e.U = function (t) {
        var n = this.I(t);
        if (n)
          return this.transitions.isRunning && this.preventRunning
            ? (t.preventDefault(), void t.stopPropagation())
            : void this.go(this.dom.getHref(n), n, t);
      }),
      (e.D = function (t) {
        this.go(this.url.getHref(), "popstate", t);
      }),
      (e.I = function (t) {
        for (var n = t.target; n && !this.dom.getHref(n); ) n = n.parentNode;
        if (n && !this.prevent.checkLink(n, t, this.dom.getHref(n))) return n;
      }),
      (e.q = function () {
        var t = this.url.getHref(),
          n = {
            container: this.dom.getContainer(),
            html: this.dom.getHtml(),
            namespace: this.dom.getNamespace(),
            url: zi({ href: t }, this.url.parse(t)),
          };
        (this.C = {
          current: n,
          next: zi({}, this.schemaPage),
          trigger: void 0,
        }),
          this.hooks.do("reset", this.data);
      }),
      Bl(s, [
        {
          key: "data",
          get: function () {
            return this.C;
          },
        },
        {
          key: "wrapper",
          get: function () {
            return this._;
          },
        },
      ]),
      s
    );
  })())();
(function () {
  function s() {
    for (var n = arguments.length, i = 0; i < n; i++) {
      var r = i < 0 || arguments.length <= i ? void 0 : arguments[i];
      r.nodeType === 1 || r.nodeType === 11
        ? this.appendChild(r)
        : this.appendChild(document.createTextNode(String(r)));
    }
  }
  function e() {
    for (; this.lastChild; ) this.removeChild(this.lastChild);
    arguments.length && this.append.apply(this, arguments);
  }
  function t() {
    for (
      var n = this.parentNode, i = arguments.length, r = new Array(i), a = 0;
      a < i;
      a++
    )
      r[a] = arguments[a];
    var o = r.length;
    if (!!n)
      for (o || n.removeChild(this); o--; ) {
        var l = r[o];
        typeof l != "object"
          ? (l = this.ownerDocument.createTextNode(l))
          : l.parentNode && l.parentNode.removeChild(l),
          o ? n.insertBefore(this.previousSibling, l) : n.replaceChild(l, this);
      }
  }
  typeof Element != "undefined" &&
    (Element.prototype.append ||
      ((Element.prototype.append = s), (DocumentFragment.prototype.append = s)),
    Element.prototype.replaceChildren ||
      ((Element.prototype.replaceChildren = e),
      (DocumentFragment.prototype.replaceChildren = e)),
    Element.prototype.replaceWith ||
      ((Element.prototype.replaceWith = t),
      (DocumentFragment.prototype.replaceWith = t)));
})();
function Tm(s, e) {
  return Object.getOwnPropertyNames(Object(s)).reduce(function (t, n) {
    var i = Object.getOwnPropertyDescriptor(Object(s), n),
      r = Object.getOwnPropertyDescriptor(Object(e), n);
    return Object.defineProperty(t, n, r || i);
  }, {});
}
var Em = {
  splitClass: "",
  lineClass: "line",
  wordClass: "word",
  charClass: "char",
  types: ["lines", "words", "chars"],
  absolute: !1,
  tagName: "div",
};
Tm(Em, {});
function Cc(s) {
  return (
    s !== null &&
    typeof s == "object" &&
    "constructor" in s &&
    s.constructor === Object
  );
}
function Xl(s, e) {
  s === void 0 && (s = {}),
    e === void 0 && (e = {}),
    Object.keys(e).forEach((t) => {
      typeof s[t] == "undefined"
        ? (s[t] = e[t])
        : Cc(e[t]) &&
          Cc(s[t]) &&
          Object.keys(e[t]).length > 0 &&
          Xl(s[t], e[t]);
    });
}
const Vf = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: { blur() {}, nodeName: "" },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return { initEvent() {} };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      },
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: "",
  },
};
function bi() {
  const s = typeof document != "undefined" ? document : {};
  return Xl(s, Vf), s;
}
const Am = {
  document: Vf,
  navigator: { userAgent: "" },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: "",
  },
  history: { replaceState() {}, pushState() {}, go() {}, back() {} },
  CustomEvent: function () {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      },
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(s) {
    return typeof setTimeout == "undefined" ? (s(), null) : setTimeout(s, 0);
  },
  cancelAnimationFrame(s) {
    typeof setTimeout != "undefined" && clearTimeout(s);
  },
};
function Ct() {
  const s = typeof window != "undefined" ? window : {};
  return Xl(s, Am), s;
}
function Cm(s) {
  return (
    s === void 0 && (s = ""),
    s
      .trim()
      .split(" ")
      .filter((e) => !!e.trim())
  );
}
function Pm(s) {
  const e = s;
  Object.keys(e).forEach((t) => {
    try {
      e[t] = null;
    } catch {}
    try {
      delete e[t];
    } catch {}
  });
}
function Ps(s, e) {
  return e === void 0 && (e = 0), setTimeout(s, e);
}
function Hn() {
  return Date.now();
}
function Lm(s) {
  const e = Ct();
  let t;
  return (
    e.getComputedStyle && (t = e.getComputedStyle(s, null)),
    !t && s.currentStyle && (t = s.currentStyle),
    t || (t = s.style),
    t
  );
}
function Rm(s, e) {
  e === void 0 && (e = "x");
  const t = Ct();
  let n, i, r;
  const a = Lm(s);
  return (
    t.WebKitCSSMatrix
      ? ((i = a.transform || a.webkitTransform),
        i.split(",").length > 6 &&
          (i = i
            .split(", ")
            .map((o) => o.replace(",", "."))
            .join(", ")),
        (r = new t.WebKitCSSMatrix(i === "none" ? "" : i)))
      : ((r =
          a.MozTransform ||
          a.OTransform ||
          a.MsTransform ||
          a.msTransform ||
          a.transform ||
          a
            .getPropertyValue("transform")
            .replace("translate(", "matrix(1, 0, 0, 1,")),
        (n = r.toString().split(","))),
    e === "x" &&
      (t.WebKitCSSMatrix
        ? (i = r.m41)
        : n.length === 16
        ? (i = parseFloat(n[12]))
        : (i = parseFloat(n[4]))),
    e === "y" &&
      (t.WebKitCSSMatrix
        ? (i = r.m42)
        : n.length === 16
        ? (i = parseFloat(n[13]))
        : (i = parseFloat(n[5]))),
    i || 0
  );
}
function Gs(s) {
  return (
    typeof s == "object" &&
    s !== null &&
    s.constructor &&
    Object.prototype.toString.call(s).slice(8, -1) === "Object"
  );
}
function Dm(s) {
  return typeof window != "undefined" &&
    typeof window.HTMLElement != "undefined"
    ? s instanceof HTMLElement
    : s && (s.nodeType === 1 || s.nodeType === 11);
}
function $t() {
  const s = Object(arguments.length <= 0 ? void 0 : arguments[0]),
    e = ["__proto__", "constructor", "prototype"];
  for (let t = 1; t < arguments.length; t += 1) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (n != null && !Dm(n)) {
      const i = Object.keys(Object(n)).filter((r) => e.indexOf(r) < 0);
      for (let r = 0, a = i.length; r < a; r += 1) {
        const o = i[r],
          l = Object.getOwnPropertyDescriptor(n, o);
        l !== void 0 &&
          l.enumerable &&
          (Gs(s[o]) && Gs(n[o])
            ? n[o].__swiper__
              ? (s[o] = n[o])
              : $t(s[o], n[o])
            : !Gs(s[o]) && Gs(n[o])
            ? ((s[o] = {}), n[o].__swiper__ ? (s[o] = n[o]) : $t(s[o], n[o]))
            : (s[o] = n[o]));
      }
    }
  }
  return s;
}
function Hs(s, e, t) {
  s.style.setProperty(e, t);
}
function Gf(s) {
  let { swiper: e, targetPosition: t, side: n } = s;
  const i = Ct(),
    r = -e.translate;
  let a = null,
    o;
  const l = e.params.speed;
  (e.wrapperEl.style.scrollSnapType = "none"),
    i.cancelAnimationFrame(e.cssModeFrameID);
  const c = t > r ? "next" : "prev",
    u = (f, h) => (c === "next" && f >= h) || (c === "prev" && f <= h),
    d = () => {
      (o = new Date().getTime()), a === null && (a = o);
      const f = Math.max(Math.min((o - a) / l, 1), 0),
        h = 0.5 - Math.cos(f * Math.PI) / 2;
      let _ = r + h * (t - r);
      if ((u(_, t) && (_ = t), e.wrapperEl.scrollTo({ [n]: _ }), u(_, t))) {
        (e.wrapperEl.style.overflow = "hidden"),
          (e.wrapperEl.style.scrollSnapType = ""),
          setTimeout(() => {
            (e.wrapperEl.style.overflow = ""), e.wrapperEl.scrollTo({ [n]: _ });
          }),
          i.cancelAnimationFrame(e.cssModeFrameID);
        return;
      }
      e.cssModeFrameID = i.requestAnimationFrame(d);
    };
  d();
}
function En(s, e) {
  return e === void 0 && (e = ""), [...s.children].filter((t) => t.matches(e));
}
function Ra(s) {
  try {
    console.warn(s);
    return;
  } catch {}
}
function Da(s, e) {
  e === void 0 && (e = []);
  const t = document.createElement(s);
  return t.classList.add(...(Array.isArray(e) ? e : Cm(e))), t;
}
function Im(s) {
  const e = Ct(),
    t = bi(),
    n = s.getBoundingClientRect(),
    i = t.body,
    r = s.clientTop || i.clientTop || 0,
    a = s.clientLeft || i.clientLeft || 0,
    o = s === e ? e.scrollY : s.scrollTop,
    l = s === e ? e.scrollX : s.scrollLeft;
  return { top: n.top + o - r, left: n.left + l - a };
}
function Om(s, e) {
  const t = [];
  for (; s.previousElementSibling; ) {
    const n = s.previousElementSibling;
    e ? n.matches(e) && t.push(n) : t.push(n), (s = n);
  }
  return t;
}
function Nm(s, e) {
  const t = [];
  for (; s.nextElementSibling; ) {
    const n = s.nextElementSibling;
    e ? n.matches(e) && t.push(n) : t.push(n), (s = n);
  }
  return t;
}
function pi(s, e) {
  return Ct().getComputedStyle(s, null).getPropertyValue(e);
}
function Pc(s) {
  let e = s,
    t;
  if (e) {
    for (t = 0; (e = e.previousSibling) !== null; )
      e.nodeType === 1 && (t += 1);
    return t;
  }
}
function ol(s, e) {
  const t = [];
  let n = s.parentElement;
  for (; n; ) e ? n.matches(e) && t.push(n) : t.push(n), (n = n.parentElement);
  return t;
}
function Lc(s, e, t) {
  const n = Ct();
  return t
    ? s[e === "width" ? "offsetWidth" : "offsetHeight"] +
        parseFloat(
          n
            .getComputedStyle(s, null)
            .getPropertyValue(e === "width" ? "margin-right" : "margin-top")
        ) +
        parseFloat(
          n
            .getComputedStyle(s, null)
            .getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")
        )
    : s.offsetWidth;
}
let so;
function Um() {
  const s = Ct(),
    e = bi();
  return {
    smoothScroll:
      e.documentElement &&
      e.documentElement.style &&
      "scrollBehavior" in e.documentElement.style,
    touch: !!(
      "ontouchstart" in s ||
      (s.DocumentTouch && e instanceof s.DocumentTouch)
    ),
  };
}
function Hf() {
  return so || (so = Um()), so;
}
let ao;
function Fm(s) {
  let { userAgent: e } = s === void 0 ? {} : s;
  const t = Hf(),
    n = Ct(),
    i = n.navigator.platform,
    r = e || n.navigator.userAgent,
    a = { ios: !1, android: !1 },
    o = n.screen.width,
    l = n.screen.height,
    c = r.match(/(Android);?[\s\/]+([\d.]+)?/);
  let u = r.match(/(iPad).*OS\s([\d_]+)/);
  const d = r.match(/(iPod)(.*OS\s([\d_]+))?/),
    f = !u && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
    h = i === "Win32";
  let _ = i === "MacIntel";
  const m = [
    "1024x1366",
    "1366x1024",
    "834x1194",
    "1194x834",
    "834x1112",
    "1112x834",
    "768x1024",
    "1024x768",
    "820x1180",
    "1180x820",
    "810x1080",
    "1080x810",
  ];
  return (
    !u &&
      _ &&
      t.touch &&
      m.indexOf(`${o}x${l}`) >= 0 &&
      ((u = r.match(/(Version)\/([\d.]+)/)),
      u || (u = [0, 1, "13_0_0"]),
      (_ = !1)),
    c && !h && ((a.os = "android"), (a.android = !0)),
    (u || f || d) && ((a.os = "ios"), (a.ios = !0)),
    a
  );
}
function km(s) {
  return s === void 0 && (s = {}), ao || (ao = Fm(s)), ao;
}
let oo;
function zm() {
  const s = Ct();
  let e = !1;
  function t() {
    const n = s.navigator.userAgent.toLowerCase();
    return (
      n.indexOf("safari") >= 0 &&
      n.indexOf("chrome") < 0 &&
      n.indexOf("android") < 0
    );
  }
  if (t()) {
    const n = String(s.navigator.userAgent);
    if (n.includes("Version/")) {
      const [i, r] = n
        .split("Version/")[1]
        .split(" ")[0]
        .split(".")
        .map((a) => Number(a));
      e = i < 16 || (i === 16 && r < 2);
    }
  }
  return {
    isSafari: e || t(),
    needPerspectiveFix: e,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
      s.navigator.userAgent
    ),
  };
}
function Bm() {
  return oo || (oo = zm()), oo;
}
function Vm(s) {
  let { swiper: e, on: t, emit: n } = s;
  const i = Ct();
  let r = null,
    a = null;
  const o = () => {
      !e || e.destroyed || !e.initialized || (n("beforeResize"), n("resize"));
    },
    l = () => {
      !e ||
        e.destroyed ||
        !e.initialized ||
        ((r = new ResizeObserver((d) => {
          a = i.requestAnimationFrame(() => {
            const { width: f, height: h } = e;
            let _ = f,
              m = h;
            d.forEach((g) => {
              let { contentBoxSize: p, contentRect: y, target: v } = g;
              (v && v !== e.el) ||
                ((_ = y ? y.width : (p[0] || p).inlineSize),
                (m = y ? y.height : (p[0] || p).blockSize));
            }),
              (_ !== f || m !== h) && o();
          });
        })),
        r.observe(e.el));
    },
    c = () => {
      a && i.cancelAnimationFrame(a),
        r && r.unobserve && e.el && (r.unobserve(e.el), (r = null));
    },
    u = () => {
      !e || e.destroyed || !e.initialized || n("orientationchange");
    };
  t("init", () => {
    if (e.params.resizeObserver && typeof i.ResizeObserver != "undefined") {
      l();
      return;
    }
    i.addEventListener("resize", o), i.addEventListener("orientationchange", u);
  }),
    t("destroy", () => {
      c(),
        i.removeEventListener("resize", o),
        i.removeEventListener("orientationchange", u);
    });
}
function Gm(s) {
  let { swiper: e, extendParams: t, on: n, emit: i } = s;
  const r = [],
    a = Ct(),
    o = function (u, d) {
      d === void 0 && (d = {});
      const f = a.MutationObserver || a.WebkitMutationObserver,
        h = new f((_) => {
          if (e.__preventObserver__) return;
          if (_.length === 1) {
            i("observerUpdate", _[0]);
            return;
          }
          const m = function () {
            i("observerUpdate", _[0]);
          };
          a.requestAnimationFrame
            ? a.requestAnimationFrame(m)
            : a.setTimeout(m, 0);
        });
      h.observe(u, {
        attributes: typeof d.attributes == "undefined" ? !0 : d.attributes,
        childList: typeof d.childList == "undefined" ? !0 : d.childList,
        characterData:
          typeof d.characterData == "undefined" ? !0 : d.characterData,
      }),
        r.push(h);
    },
    l = () => {
      if (!!e.params.observer) {
        if (e.params.observeParents) {
          const u = ol(e.hostEl);
          for (let d = 0; d < u.length; d += 1) o(u[d]);
        }
        o(e.hostEl, { childList: e.params.observeSlideChildren }),
          o(e.wrapperEl, { attributes: !1 });
      }
    },
    c = () => {
      r.forEach((u) => {
        u.disconnect();
      }),
        r.splice(0, r.length);
    };
  t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
    n("init", l),
    n("destroy", c);
}
var Hm = {
  on(s, e, t) {
    const n = this;
    if (!n.eventsListeners || n.destroyed || typeof e != "function") return n;
    const i = t ? "unshift" : "push";
    return (
      s.split(" ").forEach((r) => {
        n.eventsListeners[r] || (n.eventsListeners[r] = []),
          n.eventsListeners[r][i](e);
      }),
      n
    );
  },
  once(s, e, t) {
    const n = this;
    if (!n.eventsListeners || n.destroyed || typeof e != "function") return n;
    function i() {
      n.off(s, i), i.__emitterProxy && delete i.__emitterProxy;
      for (var r = arguments.length, a = new Array(r), o = 0; o < r; o++)
        a[o] = arguments[o];
      e.apply(n, a);
    }
    return (i.__emitterProxy = e), n.on(s, i, t);
  },
  onAny(s, e) {
    const t = this;
    if (!t.eventsListeners || t.destroyed || typeof s != "function") return t;
    const n = e ? "unshift" : "push";
    return t.eventsAnyListeners.indexOf(s) < 0 && t.eventsAnyListeners[n](s), t;
  },
  offAny(s) {
    const e = this;
    if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
    const t = e.eventsAnyListeners.indexOf(s);
    return t >= 0 && e.eventsAnyListeners.splice(t, 1), e;
  },
  off(s, e) {
    const t = this;
    return (
      !t.eventsListeners ||
        t.destroyed ||
        !t.eventsListeners ||
        s.split(" ").forEach((n) => {
          typeof e == "undefined"
            ? (t.eventsListeners[n] = [])
            : t.eventsListeners[n] &&
              t.eventsListeners[n].forEach((i, r) => {
                (i === e || (i.__emitterProxy && i.__emitterProxy === e)) &&
                  t.eventsListeners[n].splice(r, 1);
              });
        }),
      t
    );
  },
  emit() {
    const s = this;
    if (!s.eventsListeners || s.destroyed || !s.eventsListeners) return s;
    let e, t, n;
    for (var i = arguments.length, r = new Array(i), a = 0; a < i; a++)
      r[a] = arguments[a];
    return (
      typeof r[0] == "string" || Array.isArray(r[0])
        ? ((e = r[0]), (t = r.slice(1, r.length)), (n = s))
        : ((e = r[0].events), (t = r[0].data), (n = r[0].context || s)),
      t.unshift(n),
      (Array.isArray(e) ? e : e.split(" ")).forEach((l) => {
        s.eventsAnyListeners &&
          s.eventsAnyListeners.length &&
          s.eventsAnyListeners.forEach((c) => {
            c.apply(n, [l, ...t]);
          }),
          s.eventsListeners &&
            s.eventsListeners[l] &&
            s.eventsListeners[l].forEach((c) => {
              c.apply(n, t);
            });
      }),
      s
    );
  },
};
function Wm() {
  const s = this;
  let e, t;
  const n = s.el;
  typeof s.params.width != "undefined" && s.params.width !== null
    ? (e = s.params.width)
    : (e = n.clientWidth),
    typeof s.params.height != "undefined" && s.params.height !== null
      ? (t = s.params.height)
      : (t = n.clientHeight),
    !((e === 0 && s.isHorizontal()) || (t === 0 && s.isVertical())) &&
      ((e =
        e -
        parseInt(pi(n, "padding-left") || 0, 10) -
        parseInt(pi(n, "padding-right") || 0, 10)),
      (t =
        t -
        parseInt(pi(n, "padding-top") || 0, 10) -
        parseInt(pi(n, "padding-bottom") || 0, 10)),
      Number.isNaN(e) && (e = 0),
      Number.isNaN(t) && (t = 0),
      Object.assign(s, {
        width: e,
        height: t,
        size: s.isHorizontal() ? e : t,
      }));
}
function qm() {
  const s = this;
  function e(b, R) {
    return parseFloat(b.getPropertyValue(s.getDirectionLabel(R)) || 0);
  }
  const t = s.params,
    { wrapperEl: n, slidesEl: i, size: r, rtlTranslate: a, wrongRTL: o } = s,
    l = s.virtual && t.virtual.enabled,
    c = l ? s.virtual.slides.length : s.slides.length,
    u = En(i, `.${s.params.slideClass}, swiper-slide`),
    d = l ? s.virtual.slides.length : u.length;
  let f = [];
  const h = [],
    _ = [];
  let m = t.slidesOffsetBefore;
  typeof m == "function" && (m = t.slidesOffsetBefore.call(s));
  let g = t.slidesOffsetAfter;
  typeof g == "function" && (g = t.slidesOffsetAfter.call(s));
  const p = s.snapGrid.length,
    y = s.slidesGrid.length;
  let v = t.spaceBetween,
    x = -m,
    S = 0,
    w = 0;
  if (typeof r == "undefined") return;
  typeof v == "string" && v.indexOf("%") >= 0
    ? (v = (parseFloat(v.replace("%", "")) / 100) * r)
    : typeof v == "string" && (v = parseFloat(v)),
    (s.virtualSize = -v),
    u.forEach((b) => {
      a ? (b.style.marginLeft = "") : (b.style.marginRight = ""),
        (b.style.marginBottom = ""),
        (b.style.marginTop = "");
    }),
    t.centeredSlides &&
      t.cssMode &&
      (Hs(n, "--swiper-centered-offset-before", ""),
      Hs(n, "--swiper-centered-offset-after", ""));
  const A = t.grid && t.grid.rows > 1 && s.grid;
  A ? s.grid.initSlides(u) : s.grid && s.grid.unsetSlides();
  let C;
  const M =
    t.slidesPerView === "auto" &&
    t.breakpoints &&
    Object.keys(t.breakpoints).filter(
      (b) => typeof t.breakpoints[b].slidesPerView != "undefined"
    ).length > 0;
  for (let b = 0; b < d; b += 1) {
    C = 0;
    let R;
    if (
      (u[b] && (R = u[b]),
      A && s.grid.updateSlide(b, R, u),
      !(u[b] && pi(R, "display") === "none"))
    ) {
      if (t.slidesPerView === "auto") {
        M && (u[b].style[s.getDirectionLabel("width")] = "");
        const D = getComputedStyle(R),
          P = R.style.transform,
          I = R.style.webkitTransform;
        if (
          (P && (R.style.transform = "none"),
          I && (R.style.webkitTransform = "none"),
          t.roundLengths)
        )
          C = s.isHorizontal() ? Lc(R, "width", !0) : Lc(R, "height", !0);
        else {
          const U = e(D, "width"),
            H = e(D, "padding-left"),
            Y = e(D, "padding-right"),
            B = e(D, "margin-left"),
            Q = e(D, "margin-right"),
            Z = D.getPropertyValue("box-sizing");
          if (Z && Z === "border-box") C = U + B + Q;
          else {
            const { clientWidth: me, offsetWidth: te } = R;
            C = U + H + Y + B + Q + (te - me);
          }
        }
        P && (R.style.transform = P),
          I && (R.style.webkitTransform = I),
          t.roundLengths && (C = Math.floor(C));
      } else
        (C = (r - (t.slidesPerView - 1) * v) / t.slidesPerView),
          t.roundLengths && (C = Math.floor(C)),
          u[b] && (u[b].style[s.getDirectionLabel("width")] = `${C}px`);
      u[b] && (u[b].swiperSlideSize = C),
        _.push(C),
        t.centeredSlides
          ? ((x = x + C / 2 + S / 2 + v),
            S === 0 && b !== 0 && (x = x - r / 2 - v),
            b === 0 && (x = x - r / 2 - v),
            Math.abs(x) < 1 / 1e3 && (x = 0),
            t.roundLengths && (x = Math.floor(x)),
            w % t.slidesPerGroup === 0 && f.push(x),
            h.push(x))
          : (t.roundLengths && (x = Math.floor(x)),
            (w - Math.min(s.params.slidesPerGroupSkip, w)) %
              s.params.slidesPerGroup ===
              0 && f.push(x),
            h.push(x),
            (x = x + C + v)),
        (s.virtualSize += C + v),
        (S = C),
        (w += 1);
    }
  }
  if (
    ((s.virtualSize = Math.max(s.virtualSize, r) + g),
    a &&
      o &&
      (t.effect === "slide" || t.effect === "coverflow") &&
      (n.style.width = `${s.virtualSize + v}px`),
    t.setWrapperSize &&
      (n.style[s.getDirectionLabel("width")] = `${s.virtualSize + v}px`),
    A && s.grid.updateWrapperSize(C, f),
    !t.centeredSlides)
  ) {
    const b = [];
    for (let R = 0; R < f.length; R += 1) {
      let D = f[R];
      t.roundLengths && (D = Math.floor(D)),
        f[R] <= s.virtualSize - r && b.push(D);
    }
    (f = b),
      Math.floor(s.virtualSize - r) - Math.floor(f[f.length - 1]) > 1 &&
        f.push(s.virtualSize - r);
  }
  if (l && t.loop) {
    const b = _[0] + v;
    if (t.slidesPerGroup > 1) {
      const R = Math.ceil(
          (s.virtual.slidesBefore + s.virtual.slidesAfter) / t.slidesPerGroup
        ),
        D = b * t.slidesPerGroup;
      for (let P = 0; P < R; P += 1) f.push(f[f.length - 1] + D);
    }
    for (let R = 0; R < s.virtual.slidesBefore + s.virtual.slidesAfter; R += 1)
      t.slidesPerGroup === 1 && f.push(f[f.length - 1] + b),
        h.push(h[h.length - 1] + b),
        (s.virtualSize += b);
  }
  if ((f.length === 0 && (f = [0]), v !== 0)) {
    const b =
      s.isHorizontal() && a ? "marginLeft" : s.getDirectionLabel("marginRight");
    u.filter((R, D) =>
      !t.cssMode || t.loop ? !0 : D !== u.length - 1
    ).forEach((R) => {
      R.style[b] = `${v}px`;
    });
  }
  if (t.centeredSlides && t.centeredSlidesBounds) {
    let b = 0;
    _.forEach((D) => {
      b += D + (v || 0);
    }),
      (b -= v);
    const R = b - r;
    f = f.map((D) => (D <= 0 ? -m : D > R ? R + g : D));
  }
  if (t.centerInsufficientSlides) {
    let b = 0;
    if (
      (_.forEach((R) => {
        b += R + (v || 0);
      }),
      (b -= v),
      b < r)
    ) {
      const R = (r - b) / 2;
      f.forEach((D, P) => {
        f[P] = D - R;
      }),
        h.forEach((D, P) => {
          h[P] = D + R;
        });
    }
  }
  if (
    (Object.assign(s, {
      slides: u,
      snapGrid: f,
      slidesGrid: h,
      slidesSizesGrid: _,
    }),
    t.centeredSlides && t.cssMode && !t.centeredSlidesBounds)
  ) {
    Hs(n, "--swiper-centered-offset-before", `${-f[0]}px`),
      Hs(
        n,
        "--swiper-centered-offset-after",
        `${s.size / 2 - _[_.length - 1] / 2}px`
      );
    const b = -s.snapGrid[0],
      R = -s.slidesGrid[0];
    (s.snapGrid = s.snapGrid.map((D) => D + b)),
      (s.slidesGrid = s.slidesGrid.map((D) => D + R));
  }
  if (
    (d !== c && s.emit("slidesLengthChange"),
    f.length !== p &&
      (s.params.watchOverflow && s.checkOverflow(),
      s.emit("snapGridLengthChange")),
    h.length !== y && s.emit("slidesGridLengthChange"),
    t.watchSlidesProgress && s.updateSlidesOffset(),
    s.emit("slidesUpdated"),
    !l && !t.cssMode && (t.effect === "slide" || t.effect === "fade"))
  ) {
    const b = `${t.containerModifierClass}backface-hidden`,
      R = s.el.classList.contains(b);
    d <= t.maxBackfaceHiddenSlides
      ? R || s.el.classList.add(b)
      : R && s.el.classList.remove(b);
  }
}
function Xm(s) {
  const e = this,
    t = [],
    n = e.virtual && e.params.virtual.enabled;
  let i = 0,
    r;
  typeof s == "number"
    ? e.setTransition(s)
    : s === !0 && e.setTransition(e.params.speed);
  const a = (o) => (n ? e.slides[e.getSlideIndexByData(o)] : e.slides[o]);
  if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
    if (e.params.centeredSlides)
      (e.visibleSlides || []).forEach((o) => {
        t.push(o);
      });
    else
      for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
        const o = e.activeIndex + r;
        if (o > e.slides.length && !n) break;
        t.push(a(o));
      }
  else t.push(a(e.activeIndex));
  for (r = 0; r < t.length; r += 1)
    if (typeof t[r] != "undefined") {
      const o = t[r].offsetHeight;
      i = o > i ? o : i;
    }
  (i || i === 0) && (e.wrapperEl.style.height = `${i}px`);
}
function jm() {
  const s = this,
    e = s.slides,
    t = s.isElement
      ? s.isHorizontal()
        ? s.wrapperEl.offsetLeft
        : s.wrapperEl.offsetTop
      : 0;
  for (let n = 0; n < e.length; n += 1)
    e[n].swiperSlideOffset =
      (s.isHorizontal() ? e[n].offsetLeft : e[n].offsetTop) -
      t -
      s.cssOverflowAdjustment();
}
function Ym(s) {
  s === void 0 && (s = (this && this.translate) || 0);
  const e = this,
    t = e.params,
    { slides: n, rtlTranslate: i, snapGrid: r } = e;
  if (n.length === 0) return;
  typeof n[0].swiperSlideOffset == "undefined" && e.updateSlidesOffset();
  let a = -s;
  i && (a = s),
    n.forEach((l) => {
      l.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass);
    }),
    (e.visibleSlidesIndexes = []),
    (e.visibleSlides = []);
  let o = t.spaceBetween;
  typeof o == "string" && o.indexOf("%") >= 0
    ? (o = (parseFloat(o.replace("%", "")) / 100) * e.size)
    : typeof o == "string" && (o = parseFloat(o));
  for (let l = 0; l < n.length; l += 1) {
    const c = n[l];
    let u = c.swiperSlideOffset;
    t.cssMode && t.centeredSlides && (u -= n[0].swiperSlideOffset);
    const d =
        (a + (t.centeredSlides ? e.minTranslate() : 0) - u) /
        (c.swiperSlideSize + o),
      f =
        (a - r[0] + (t.centeredSlides ? e.minTranslate() : 0) - u) /
        (c.swiperSlideSize + o),
      h = -(a - u),
      _ = h + e.slidesSizesGrid[l],
      m = h >= 0 && h <= e.size - e.slidesSizesGrid[l];
    ((h >= 0 && h < e.size - 1) ||
      (_ > 1 && _ <= e.size) ||
      (h <= 0 && _ >= e.size)) &&
      (e.visibleSlides.push(c),
      e.visibleSlidesIndexes.push(l),
      n[l].classList.add(t.slideVisibleClass)),
      m && n[l].classList.add(t.slideFullyVisibleClass),
      (c.progress = i ? -d : d),
      (c.originalProgress = i ? -f : f);
  }
}
function $m(s) {
  const e = this;
  if (typeof s == "undefined") {
    const u = e.rtlTranslate ? -1 : 1;
    s = (e && e.translate && e.translate * u) || 0;
  }
  const t = e.params,
    n = e.maxTranslate() - e.minTranslate();
  let { progress: i, isBeginning: r, isEnd: a, progressLoop: o } = e;
  const l = r,
    c = a;
  if (n === 0) (i = 0), (r = !0), (a = !0);
  else {
    i = (s - e.minTranslate()) / n;
    const u = Math.abs(s - e.minTranslate()) < 1,
      d = Math.abs(s - e.maxTranslate()) < 1;
    (r = u || i <= 0), (a = d || i >= 1), u && (i = 0), d && (i = 1);
  }
  if (t.loop) {
    const u = e.getSlideIndexByData(0),
      d = e.getSlideIndexByData(e.slides.length - 1),
      f = e.slidesGrid[u],
      h = e.slidesGrid[d],
      _ = e.slidesGrid[e.slidesGrid.length - 1],
      m = Math.abs(s);
    m >= f ? (o = (m - f) / _) : (o = (m + _ - h) / _), o > 1 && (o -= 1);
  }
  Object.assign(e, { progress: i, progressLoop: o, isBeginning: r, isEnd: a }),
    (t.watchSlidesProgress || (t.centeredSlides && t.autoHeight)) &&
      e.updateSlidesProgress(s),
    r && !l && e.emit("reachBeginning toEdge"),
    a && !c && e.emit("reachEnd toEdge"),
    ((l && !r) || (c && !a)) && e.emit("fromEdge"),
    e.emit("progress", i);
}
function Km() {
  const s = this,
    { slides: e, params: t, slidesEl: n, activeIndex: i } = s,
    r = s.virtual && t.virtual.enabled,
    a = s.grid && t.grid && t.grid.rows > 1,
    o = (d) => En(n, `.${t.slideClass}${d}, swiper-slide${d}`)[0];
  e.forEach((d) => {
    d.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass);
  });
  let l, c, u;
  if (r)
    if (t.loop) {
      let d = i - s.virtual.slidesBefore;
      d < 0 && (d = s.virtual.slides.length + d),
        d >= s.virtual.slides.length && (d -= s.virtual.slides.length),
        (l = o(`[data-swiper-slide-index="${d}"]`));
    } else l = o(`[data-swiper-slide-index="${i}"]`);
  else
    a
      ? ((l = e.filter((d) => d.column === i)[0]),
        (u = e.filter((d) => d.column === i + 1)[0]),
        (c = e.filter((d) => d.column === i - 1)[0]))
      : (l = e[i]);
  l &&
    (l.classList.add(t.slideActiveClass),
    a
      ? (u && u.classList.add(t.slideNextClass),
        c && c.classList.add(t.slidePrevClass))
      : ((u = Nm(l, `.${t.slideClass}, swiper-slide`)[0]),
        t.loop && !u && (u = e[0]),
        u && u.classList.add(t.slideNextClass),
        (c = Om(l, `.${t.slideClass}, swiper-slide`)[0]),
        t.loop && !c === 0 && (c = e[e.length - 1]),
        c && c.classList.add(t.slidePrevClass))),
    s.emitSlidesClasses();
}
const xa = (s, e) => {
    if (!s || s.destroyed || !s.params) return;
    const t = () => (s.isElement ? "swiper-slide" : `.${s.params.slideClass}`),
      n = e.closest(t());
    if (n) {
      let i = n.querySelector(`.${s.params.lazyPreloaderClass}`);
      !i &&
        s.isElement &&
        (n.shadowRoot
          ? (i = n.shadowRoot.querySelector(`.${s.params.lazyPreloaderClass}`))
          : requestAnimationFrame(() => {
              n.shadowRoot &&
                ((i = n.shadowRoot.querySelector(
                  `.${s.params.lazyPreloaderClass}`
                )),
                i && i.remove());
            })),
        i && i.remove();
    }
  },
  lo = (s, e) => {
    if (!s.slides[e]) return;
    const t = s.slides[e].querySelector('[loading="lazy"]');
    t && t.removeAttribute("loading");
  },
  ll = (s) => {
    if (!s || s.destroyed || !s.params) return;
    let e = s.params.lazyPreloadPrevNext;
    const t = s.slides.length;
    if (!t || !e || e < 0) return;
    e = Math.min(e, t);
    const n =
        s.params.slidesPerView === "auto"
          ? s.slidesPerViewDynamic()
          : Math.ceil(s.params.slidesPerView),
      i = s.activeIndex;
    if (s.params.grid && s.params.grid.rows > 1) {
      const a = i,
        o = [a - e];
      o.push(...Array.from({ length: e }).map((l, c) => a + n + c)),
        s.slides.forEach((l, c) => {
          o.includes(l.column) && lo(s, c);
        });
      return;
    }
    const r = i + n - 1;
    if (s.params.rewind || s.params.loop)
      for (let a = i - e; a <= r + e; a += 1) {
        const o = ((a % t) + t) % t;
        (o < i || o > r) && lo(s, o);
      }
    else
      for (let a = Math.max(i - e, 0); a <= Math.min(r + e, t - 1); a += 1)
        a !== i && (a > r || a < i) && lo(s, a);
  };
function Zm(s) {
  const { slidesGrid: e, params: t } = s,
    n = s.rtlTranslate ? s.translate : -s.translate;
  let i;
  for (let r = 0; r < e.length; r += 1)
    typeof e[r + 1] != "undefined"
      ? n >= e[r] && n < e[r + 1] - (e[r + 1] - e[r]) / 2
        ? (i = r)
        : n >= e[r] && n < e[r + 1] && (i = r + 1)
      : n >= e[r] && (i = r);
  return (
    t.normalizeSlideIndex && (i < 0 || typeof i == "undefined") && (i = 0), i
  );
}
function Jm(s) {
  const e = this,
    t = e.rtlTranslate ? e.translate : -e.translate,
    { snapGrid: n, params: i, activeIndex: r, realIndex: a, snapIndex: o } = e;
  let l = s,
    c;
  const u = (h) => {
    let _ = h - e.virtual.slidesBefore;
    return (
      _ < 0 && (_ = e.virtual.slides.length + _),
      _ >= e.virtual.slides.length && (_ -= e.virtual.slides.length),
      _
    );
  };
  if ((typeof l == "undefined" && (l = Zm(e)), n.indexOf(t) >= 0))
    c = n.indexOf(t);
  else {
    const h = Math.min(i.slidesPerGroupSkip, l);
    c = h + Math.floor((l - h) / i.slidesPerGroup);
  }
  if ((c >= n.length && (c = n.length - 1), l === r && !e.params.loop)) {
    c !== o && ((e.snapIndex = c), e.emit("snapIndexChange"));
    return;
  }
  if (l === r && e.params.loop && e.virtual && e.params.virtual.enabled) {
    e.realIndex = u(l);
    return;
  }
  const d = e.grid && i.grid && i.grid.rows > 1;
  let f;
  if (e.virtual && i.virtual.enabled && i.loop) f = u(l);
  else if (d) {
    const h = e.slides.filter((m) => m.column === l)[0];
    let _ = parseInt(h.getAttribute("data-swiper-slide-index"), 10);
    Number.isNaN(_) && (_ = Math.max(e.slides.indexOf(h), 0)),
      (f = Math.floor(_ / i.grid.rows));
  } else if (e.slides[l]) {
    const h = e.slides[l].getAttribute("data-swiper-slide-index");
    h ? (f = parseInt(h, 10)) : (f = l);
  } else f = l;
  Object.assign(e, {
    previousSnapIndex: o,
    snapIndex: c,
    previousRealIndex: a,
    realIndex: f,
    previousIndex: r,
    activeIndex: l,
  }),
    e.initialized && ll(e),
    e.emit("activeIndexChange"),
    e.emit("snapIndexChange"),
    (e.initialized || e.params.runCallbacksOnInit) &&
      (a !== f && e.emit("realIndexChange"), e.emit("slideChange"));
}
function Qm(s, e) {
  const t = this,
    n = t.params;
  let i = s.closest(`.${n.slideClass}, swiper-slide`);
  !i &&
    t.isElement &&
    e &&
    e.length > 1 &&
    e.includes(s) &&
    [...e.slice(e.indexOf(s) + 1, e.length)].forEach((o) => {
      !i && o.matches && o.matches(`.${n.slideClass}, swiper-slide`) && (i = o);
    });
  let r = !1,
    a;
  if (i) {
    for (let o = 0; o < t.slides.length; o += 1)
      if (t.slides[o] === i) {
        (r = !0), (a = o);
        break;
      }
  }
  if (i && r)
    (t.clickedSlide = i),
      t.virtual && t.params.virtual.enabled
        ? (t.clickedIndex = parseInt(
            i.getAttribute("data-swiper-slide-index"),
            10
          ))
        : (t.clickedIndex = a);
  else {
    (t.clickedSlide = void 0), (t.clickedIndex = void 0);
    return;
  }
  n.slideToClickedSlide &&
    t.clickedIndex !== void 0 &&
    t.clickedIndex !== t.activeIndex &&
    t.slideToClickedSlide();
}
var eg = {
  updateSize: Wm,
  updateSlides: qm,
  updateAutoHeight: Xm,
  updateSlidesOffset: jm,
  updateSlidesProgress: Ym,
  updateProgress: $m,
  updateSlidesClasses: Km,
  updateActiveIndex: Jm,
  updateClickedSlide: Qm,
};
function tg(s) {
  s === void 0 && (s = this.isHorizontal() ? "x" : "y");
  const e = this,
    { params: t, rtlTranslate: n, translate: i, wrapperEl: r } = e;
  if (t.virtualTranslate) return n ? -i : i;
  if (t.cssMode) return i;
  let a = Rm(r, s);
  return (a += e.cssOverflowAdjustment()), n && (a = -a), a || 0;
}
function ng(s, e) {
  const t = this,
    { rtlTranslate: n, params: i, wrapperEl: r, progress: a } = t;
  let o = 0,
    l = 0;
  const c = 0;
  t.isHorizontal() ? (o = n ? -s : s) : (l = s),
    i.roundLengths && ((o = Math.floor(o)), (l = Math.floor(l))),
    (t.previousTranslate = t.translate),
    (t.translate = t.isHorizontal() ? o : l),
    i.cssMode
      ? (r[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal()
          ? -o
          : -l)
      : i.virtualTranslate ||
        (t.isHorizontal()
          ? (o -= t.cssOverflowAdjustment())
          : (l -= t.cssOverflowAdjustment()),
        (r.style.transform = `translate3d(${o}px, ${l}px, ${c}px)`));
  let u;
  const d = t.maxTranslate() - t.minTranslate();
  d === 0 ? (u = 0) : (u = (s - t.minTranslate()) / d),
    u !== a && t.updateProgress(s),
    t.emit("setTranslate", t.translate, e);
}
function ig() {
  return -this.snapGrid[0];
}
function rg() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function sg(s, e, t, n, i) {
  s === void 0 && (s = 0),
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0),
    n === void 0 && (n = !0);
  const r = this,
    { params: a, wrapperEl: o } = r;
  if (r.animating && a.preventInteractionOnTransition) return !1;
  const l = r.minTranslate(),
    c = r.maxTranslate();
  let u;
  if (
    (n && s > l ? (u = l) : n && s < c ? (u = c) : (u = s),
    r.updateProgress(u),
    a.cssMode)
  ) {
    const d = r.isHorizontal();
    if (e === 0) o[d ? "scrollLeft" : "scrollTop"] = -u;
    else {
      if (!r.support.smoothScroll)
        return (
          Gf({ swiper: r, targetPosition: -u, side: d ? "left" : "top" }), !0
        );
      o.scrollTo({ [d ? "left" : "top"]: -u, behavior: "smooth" });
    }
    return !0;
  }
  return (
    e === 0
      ? (r.setTransition(0),
        r.setTranslate(u),
        t && (r.emit("beforeTransitionStart", e, i), r.emit("transitionEnd")))
      : (r.setTransition(e),
        r.setTranslate(u),
        t && (r.emit("beforeTransitionStart", e, i), r.emit("transitionStart")),
        r.animating ||
          ((r.animating = !0),
          r.onTranslateToWrapperTransitionEnd ||
            (r.onTranslateToWrapperTransitionEnd = function (f) {
              !r ||
                r.destroyed ||
                (f.target === this &&
                  (r.wrapperEl.removeEventListener(
                    "transitionend",
                    r.onTranslateToWrapperTransitionEnd
                  ),
                  (r.onTranslateToWrapperTransitionEnd = null),
                  delete r.onTranslateToWrapperTransitionEnd,
                  t && r.emit("transitionEnd")));
            }),
          r.wrapperEl.addEventListener(
            "transitionend",
            r.onTranslateToWrapperTransitionEnd
          ))),
    !0
  );
}
var ag = {
  getTranslate: tg,
  setTranslate: ng,
  minTranslate: ig,
  maxTranslate: rg,
  translateTo: sg,
};
function og(s, e) {
  const t = this;
  t.params.cssMode ||
    ((t.wrapperEl.style.transitionDuration = `${s}ms`),
    (t.wrapperEl.style.transitionDelay = s === 0 ? "0ms" : "")),
    t.emit("setTransition", s, e);
}
function Wf(s) {
  let { swiper: e, runCallbacks: t, direction: n, step: i } = s;
  const { activeIndex: r, previousIndex: a } = e;
  let o = n;
  if (
    (o || (r > a ? (o = "next") : r < a ? (o = "prev") : (o = "reset")),
    e.emit(`transition${i}`),
    t && r !== a)
  ) {
    if (o === "reset") {
      e.emit(`slideResetTransition${i}`);
      return;
    }
    e.emit(`slideChangeTransition${i}`),
      o === "next"
        ? e.emit(`slideNextTransition${i}`)
        : e.emit(`slidePrevTransition${i}`);
  }
}
function lg(s, e) {
  s === void 0 && (s = !0);
  const t = this,
    { params: n } = t;
  n.cssMode ||
    (n.autoHeight && t.updateAutoHeight(),
    Wf({ swiper: t, runCallbacks: s, direction: e, step: "Start" }));
}
function cg(s, e) {
  s === void 0 && (s = !0);
  const t = this,
    { params: n } = t;
  (t.animating = !1),
    !n.cssMode &&
      (t.setTransition(0),
      Wf({ swiper: t, runCallbacks: s, direction: e, step: "End" }));
}
var ug = { setTransition: og, transitionStart: lg, transitionEnd: cg };
function dg(s, e, t, n, i) {
  s === void 0 && (s = 0),
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0),
    typeof s == "string" && (s = parseInt(s, 10));
  const r = this;
  let a = s;
  a < 0 && (a = 0);
  const {
    params: o,
    snapGrid: l,
    slidesGrid: c,
    previousIndex: u,
    activeIndex: d,
    rtlTranslate: f,
    wrapperEl: h,
    enabled: _,
  } = r;
  if ((r.animating && o.preventInteractionOnTransition) || (!_ && !n && !i))
    return !1;
  const m = Math.min(r.params.slidesPerGroupSkip, a);
  let g = m + Math.floor((a - m) / r.params.slidesPerGroup);
  g >= l.length && (g = l.length - 1);
  const p = -l[g];
  if (o.normalizeSlideIndex)
    for (let v = 0; v < c.length; v += 1) {
      const x = -Math.floor(p * 100),
        S = Math.floor(c[v] * 100),
        w = Math.floor(c[v + 1] * 100);
      typeof c[v + 1] != "undefined"
        ? x >= S && x < w - (w - S) / 2
          ? (a = v)
          : x >= S && x < w && (a = v + 1)
        : x >= S && (a = v);
    }
  if (
    r.initialized &&
    a !== d &&
    ((!r.allowSlideNext &&
      (f
        ? p > r.translate && p > r.minTranslate()
        : p < r.translate && p < r.minTranslate())) ||
      (!r.allowSlidePrev &&
        p > r.translate &&
        p > r.maxTranslate() &&
        (d || 0) !== a))
  )
    return !1;
  a !== (u || 0) && t && r.emit("beforeSlideChangeStart"), r.updateProgress(p);
  let y;
  if (
    (a > d ? (y = "next") : a < d ? (y = "prev") : (y = "reset"),
    (f && -p === r.translate) || (!f && p === r.translate))
  )
    return (
      r.updateActiveIndex(a),
      o.autoHeight && r.updateAutoHeight(),
      r.updateSlidesClasses(),
      o.effect !== "slide" && r.setTranslate(p),
      y !== "reset" && (r.transitionStart(t, y), r.transitionEnd(t, y)),
      !1
    );
  if (o.cssMode) {
    const v = r.isHorizontal(),
      x = f ? p : -p;
    if (e === 0) {
      const S = r.virtual && r.params.virtual.enabled;
      S &&
        ((r.wrapperEl.style.scrollSnapType = "none"),
        (r._immediateVirtual = !0)),
        S && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0
          ? ((r._cssModeVirtualInitialSet = !0),
            requestAnimationFrame(() => {
              h[v ? "scrollLeft" : "scrollTop"] = x;
            }))
          : (h[v ? "scrollLeft" : "scrollTop"] = x),
        S &&
          requestAnimationFrame(() => {
            (r.wrapperEl.style.scrollSnapType = ""), (r._immediateVirtual = !1);
          });
    } else {
      if (!r.support.smoothScroll)
        return (
          Gf({ swiper: r, targetPosition: x, side: v ? "left" : "top" }), !0
        );
      h.scrollTo({ [v ? "left" : "top"]: x, behavior: "smooth" });
    }
    return !0;
  }
  return (
    r.setTransition(e),
    r.setTranslate(p),
    r.updateActiveIndex(a),
    r.updateSlidesClasses(),
    r.emit("beforeTransitionStart", e, n),
    r.transitionStart(t, y),
    e === 0
      ? r.transitionEnd(t, y)
      : r.animating ||
        ((r.animating = !0),
        r.onSlideToWrapperTransitionEnd ||
          (r.onSlideToWrapperTransitionEnd = function (x) {
            !r ||
              r.destroyed ||
              (x.target === this &&
                (r.wrapperEl.removeEventListener(
                  "transitionend",
                  r.onSlideToWrapperTransitionEnd
                ),
                (r.onSlideToWrapperTransitionEnd = null),
                delete r.onSlideToWrapperTransitionEnd,
                r.transitionEnd(t, y)));
          }),
        r.wrapperEl.addEventListener(
          "transitionend",
          r.onSlideToWrapperTransitionEnd
        )),
    !0
  );
}
function fg(s, e, t, n) {
  s === void 0 && (s = 0),
    e === void 0 && (e = this.params.speed),
    t === void 0 && (t = !0),
    typeof s == "string" && (s = parseInt(s, 10));
  const i = this,
    r = i.grid && i.params.grid && i.params.grid.rows > 1;
  let a = s;
  if (i.params.loop)
    if (i.virtual && i.params.virtual.enabled) a = a + i.virtual.slidesBefore;
    else {
      let o;
      if (r) {
        const f = a * i.params.grid.rows;
        o = i.slides.filter(
          (h) => h.getAttribute("data-swiper-slide-index") * 1 === f
        )[0].column;
      } else o = i.getSlideIndexByData(a);
      const l = r
          ? Math.ceil(i.slides.length / i.params.grid.rows)
          : i.slides.length,
        { centeredSlides: c } = i.params;
      let u = i.params.slidesPerView;
      u === "auto"
        ? (u = i.slidesPerViewDynamic())
        : ((u = Math.ceil(parseFloat(i.params.slidesPerView, 10))),
          c && u % 2 === 0 && (u = u + 1));
      let d = l - o < u;
      if ((c && (d = d || o < Math.ceil(u / 2)), d)) {
        const f = c
          ? o < i.activeIndex
            ? "prev"
            : "next"
          : o - i.activeIndex - 1 < i.params.slidesPerView
          ? "next"
          : "prev";
        i.loopFix({
          direction: f,
          slideTo: !0,
          activeSlideIndex: f === "next" ? o + 1 : o - l + 1,
          slideRealIndex: f === "next" ? i.realIndex : void 0,
        });
      }
      if (r) {
        const f = a * i.params.grid.rows;
        a = i.slides.filter(
          (h) => h.getAttribute("data-swiper-slide-index") * 1 === f
        )[0].column;
      } else a = i.getSlideIndexByData(a);
    }
  return (
    requestAnimationFrame(() => {
      i.slideTo(a, e, t, n);
    }),
    i
  );
}
function hg(s, e, t) {
  s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
  const n = this,
    { enabled: i, params: r, animating: a } = n;
  if (!i) return n;
  let o = r.slidesPerGroup;
  r.slidesPerView === "auto" &&
    r.slidesPerGroup === 1 &&
    r.slidesPerGroupAuto &&
    (o = Math.max(n.slidesPerViewDynamic("current", !0), 1));
  const l = n.activeIndex < r.slidesPerGroupSkip ? 1 : o,
    c = n.virtual && r.virtual.enabled;
  if (r.loop) {
    if (a && !c && r.loopPreventsSliding) return !1;
    if (
      (n.loopFix({ direction: "next" }),
      (n._clientLeft = n.wrapperEl.clientLeft),
      n.activeIndex === n.slides.length - 1 && r.cssMode)
    )
      return (
        requestAnimationFrame(() => {
          n.slideTo(n.activeIndex + l, s, e, t);
        }),
        !0
      );
  }
  return r.rewind && n.isEnd
    ? n.slideTo(0, s, e, t)
    : n.slideTo(n.activeIndex + l, s, e, t);
}
function pg(s, e, t) {
  s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
  const n = this,
    {
      params: i,
      snapGrid: r,
      slidesGrid: a,
      rtlTranslate: o,
      enabled: l,
      animating: c,
    } = n;
  if (!l) return n;
  const u = n.virtual && i.virtual.enabled;
  if (i.loop) {
    if (c && !u && i.loopPreventsSliding) return !1;
    n.loopFix({ direction: "prev" }), (n._clientLeft = n.wrapperEl.clientLeft);
  }
  const d = o ? n.translate : -n.translate;
  function f(p) {
    return p < 0 ? -Math.floor(Math.abs(p)) : Math.floor(p);
  }
  const h = f(d),
    _ = r.map((p) => f(p));
  let m = r[_.indexOf(h) - 1];
  if (typeof m == "undefined" && i.cssMode) {
    let p;
    r.forEach((y, v) => {
      h >= y && (p = v);
    }),
      typeof p != "undefined" && (m = r[p > 0 ? p - 1 : p]);
  }
  let g = 0;
  if (
    (typeof m != "undefined" &&
      ((g = a.indexOf(m)),
      g < 0 && (g = n.activeIndex - 1),
      i.slidesPerView === "auto" &&
        i.slidesPerGroup === 1 &&
        i.slidesPerGroupAuto &&
        ((g = g - n.slidesPerViewDynamic("previous", !0) + 1),
        (g = Math.max(g, 0)))),
    i.rewind && n.isBeginning)
  ) {
    const p =
      n.params.virtual && n.params.virtual.enabled && n.virtual
        ? n.virtual.slides.length - 1
        : n.slides.length - 1;
    return n.slideTo(p, s, e, t);
  } else if (i.loop && n.activeIndex === 0 && i.cssMode)
    return (
      requestAnimationFrame(() => {
        n.slideTo(g, s, e, t);
      }),
      !0
    );
  return n.slideTo(g, s, e, t);
}
function mg(s, e, t) {
  s === void 0 && (s = this.params.speed), e === void 0 && (e = !0);
  const n = this;
  return n.slideTo(n.activeIndex, s, e, t);
}
function gg(s, e, t, n) {
  s === void 0 && (s = this.params.speed),
    e === void 0 && (e = !0),
    n === void 0 && (n = 0.5);
  const i = this;
  let r = i.activeIndex;
  const a = Math.min(i.params.slidesPerGroupSkip, r),
    o = a + Math.floor((r - a) / i.params.slidesPerGroup),
    l = i.rtlTranslate ? i.translate : -i.translate;
  if (l >= i.snapGrid[o]) {
    const c = i.snapGrid[o],
      u = i.snapGrid[o + 1];
    l - c > (u - c) * n && (r += i.params.slidesPerGroup);
  } else {
    const c = i.snapGrid[o - 1],
      u = i.snapGrid[o];
    l - c <= (u - c) * n && (r -= i.params.slidesPerGroup);
  }
  return (
    (r = Math.max(r, 0)),
    (r = Math.min(r, i.slidesGrid.length - 1)),
    i.slideTo(r, s, e, t)
  );
}
function _g() {
  const s = this,
    { params: e, slidesEl: t } = s,
    n = e.slidesPerView === "auto" ? s.slidesPerViewDynamic() : e.slidesPerView;
  let i = s.clickedIndex,
    r;
  const a = s.isElement ? "swiper-slide" : `.${e.slideClass}`;
  if (e.loop) {
    if (s.animating) return;
    (r = parseInt(s.clickedSlide.getAttribute("data-swiper-slide-index"), 10)),
      e.centeredSlides
        ? i < s.loopedSlides - n / 2 ||
          i > s.slides.length - s.loopedSlides + n / 2
          ? (s.loopFix(),
            (i = s.getSlideIndex(
              En(t, `${a}[data-swiper-slide-index="${r}"]`)[0]
            )),
            Ps(() => {
              s.slideTo(i);
            }))
          : s.slideTo(i)
        : i > s.slides.length - n
        ? (s.loopFix(),
          (i = s.getSlideIndex(
            En(t, `${a}[data-swiper-slide-index="${r}"]`)[0]
          )),
          Ps(() => {
            s.slideTo(i);
          }))
        : s.slideTo(i);
  } else s.slideTo(i);
}
var vg = {
  slideTo: dg,
  slideToLoop: fg,
  slideNext: hg,
  slidePrev: pg,
  slideReset: mg,
  slideToClosest: gg,
  slideToClickedSlide: _g,
};
function xg(s) {
  const e = this,
    { params: t, slidesEl: n } = e;
  if (!t.loop || (e.virtual && e.params.virtual.enabled)) return;
  const i = () => {
      En(n, `.${t.slideClass}, swiper-slide`).forEach((d, f) => {
        d.setAttribute("data-swiper-slide-index", f);
      });
    },
    r = e.grid && t.grid && t.grid.rows > 1,
    a = t.slidesPerGroup * (r ? t.grid.rows : 1),
    o = e.slides.length % a !== 0,
    l = r && e.slides.length % t.grid.rows !== 0,
    c = (u) => {
      for (let d = 0; d < u; d += 1) {
        const f = e.isElement
          ? Da("swiper-slide", [t.slideBlankClass])
          : Da("div", [t.slideClass, t.slideBlankClass]);
        e.slidesEl.append(f);
      }
    };
  if (o) {
    if (t.loopAddBlankSlides) {
      const u = a - (e.slides.length % a);
      c(u), e.recalcSlides(), e.updateSlides();
    } else
      Ra(
        "Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"
      );
    i();
  } else if (l) {
    if (t.loopAddBlankSlides) {
      const u = t.grid.rows - (e.slides.length % t.grid.rows);
      c(u), e.recalcSlides(), e.updateSlides();
    } else
      Ra(
        "Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"
      );
    i();
  } else i();
  e.loopFix({
    slideRealIndex: s,
    direction: t.centeredSlides ? void 0 : "next",
  });
}
function yg(s) {
  let {
    slideRealIndex: e,
    slideTo: t = !0,
    direction: n,
    setTranslate: i,
    activeSlideIndex: r,
    byController: a,
    byMousewheel: o,
  } = s === void 0 ? {} : s;
  const l = this;
  if (!l.params.loop) return;
  l.emit("beforeLoopFix");
  const {
      slides: c,
      allowSlidePrev: u,
      allowSlideNext: d,
      slidesEl: f,
      params: h,
    } = l,
    { centeredSlides: _ } = h;
  if (
    ((l.allowSlidePrev = !0),
    (l.allowSlideNext = !0),
    l.virtual && h.virtual.enabled)
  ) {
    t &&
      (!h.centeredSlides && l.snapIndex === 0
        ? l.slideTo(l.virtual.slides.length, 0, !1, !0)
        : h.centeredSlides && l.snapIndex < h.slidesPerView
        ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0)
        : l.snapIndex === l.snapGrid.length - 1 &&
          l.slideTo(l.virtual.slidesBefore, 0, !1, !0)),
      (l.allowSlidePrev = u),
      (l.allowSlideNext = d),
      l.emit("loopFix");
    return;
  }
  let m = h.slidesPerView;
  m === "auto"
    ? (m = l.slidesPerViewDynamic())
    : ((m = Math.ceil(parseFloat(h.slidesPerView, 10))),
      _ && m % 2 === 0 && (m = m + 1));
  const g = h.slidesPerGroupAuto ? m : h.slidesPerGroup;
  let p = g;
  p % g !== 0 && (p += g - (p % g)),
    (p += h.loopAdditionalSlides),
    (l.loopedSlides = p);
  const y = l.grid && h.grid && h.grid.rows > 1;
  c.length < m + p
    ? Ra(
        "Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"
      )
    : y &&
      h.grid.fill === "row" &&
      Ra(
        "Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"
      );
  const v = [],
    x = [];
  let S = l.activeIndex;
  typeof r == "undefined"
    ? (r = l.getSlideIndex(
        c.filter((P) => P.classList.contains(h.slideActiveClass))[0]
      ))
    : (S = r);
  const w = n === "next" || !n,
    A = n === "prev" || !n;
  let C = 0,
    M = 0;
  const b = y ? Math.ceil(c.length / h.grid.rows) : c.length,
    D =
      (y ? c[r].column : r) + (_ && typeof i == "undefined" ? -m / 2 + 0.5 : 0);
  if (D < p) {
    C = Math.max(p - D, g);
    for (let P = 0; P < p - D; P += 1) {
      const I = P - Math.floor(P / b) * b;
      if (y) {
        const U = b - I - 1;
        for (let H = c.length - 1; H >= 0; H -= 1)
          c[H].column === U && v.push(H);
      } else v.push(b - I - 1);
    }
  } else if (D + m > b - p) {
    M = Math.max(D - (b - p * 2), g);
    for (let P = 0; P < M; P += 1) {
      const I = P - Math.floor(P / b) * b;
      y
        ? c.forEach((U, H) => {
            U.column === I && x.push(H);
          })
        : x.push(I);
    }
  }
  if (
    ((l.__preventObserver__ = !0),
    requestAnimationFrame(() => {
      l.__preventObserver__ = !1;
    }),
    A &&
      v.forEach((P) => {
        (c[P].swiperLoopMoveDOM = !0),
          f.prepend(c[P]),
          (c[P].swiperLoopMoveDOM = !1);
      }),
    w &&
      x.forEach((P) => {
        (c[P].swiperLoopMoveDOM = !0),
          f.append(c[P]),
          (c[P].swiperLoopMoveDOM = !1);
      }),
    l.recalcSlides(),
    h.slidesPerView === "auto"
      ? l.updateSlides()
      : y &&
        ((v.length > 0 && A) || (x.length > 0 && w)) &&
        l.slides.forEach((P, I) => {
          l.grid.updateSlide(I, P, l.slides);
        }),
    h.watchSlidesProgress && l.updateSlidesOffset(),
    t)
  ) {
    if (v.length > 0 && A) {
      if (typeof e == "undefined") {
        const P = l.slidesGrid[S],
          U = l.slidesGrid[S + C] - P;
        o
          ? l.setTranslate(l.translate - U)
          : (l.slideTo(S + C, 0, !1, !0),
            i &&
              ((l.touchEventsData.startTranslate =
                l.touchEventsData.startTranslate - U),
              (l.touchEventsData.currentTranslate =
                l.touchEventsData.currentTranslate - U)));
      } else if (i) {
        const P = y ? v.length / h.grid.rows : v.length;
        l.slideTo(l.activeIndex + P, 0, !1, !0),
          (l.touchEventsData.currentTranslate = l.translate);
      }
    } else if (x.length > 0 && w)
      if (typeof e == "undefined") {
        const P = l.slidesGrid[S],
          U = l.slidesGrid[S - M] - P;
        o
          ? l.setTranslate(l.translate - U)
          : (l.slideTo(S - M, 0, !1, !0),
            i &&
              ((l.touchEventsData.startTranslate =
                l.touchEventsData.startTranslate - U),
              (l.touchEventsData.currentTranslate =
                l.touchEventsData.currentTranslate - U)));
      } else {
        const P = y ? x.length / h.grid.rows : x.length;
        l.slideTo(l.activeIndex - P, 0, !1, !0);
      }
  }
  if (
    ((l.allowSlidePrev = u),
    (l.allowSlideNext = d),
    l.controller && l.controller.control && !a)
  ) {
    const P = {
      slideRealIndex: e,
      direction: n,
      setTranslate: i,
      activeSlideIndex: r,
      byController: !0,
    };
    Array.isArray(l.controller.control)
      ? l.controller.control.forEach((I) => {
          !I.destroyed &&
            I.params.loop &&
            I.loopFix({
              ...P,
              slideTo: I.params.slidesPerView === h.slidesPerView ? t : !1,
            });
        })
      : l.controller.control instanceof l.constructor &&
        l.controller.control.params.loop &&
        l.controller.control.loopFix({
          ...P,
          slideTo:
            l.controller.control.params.slidesPerView === h.slidesPerView
              ? t
              : !1,
        });
  }
  l.emit("loopFix");
}
function Sg() {
  const s = this,
    { params: e, slidesEl: t } = s;
  if (!e.loop || (s.virtual && s.params.virtual.enabled)) return;
  s.recalcSlides();
  const n = [];
  s.slides.forEach((i) => {
    const r =
      typeof i.swiperSlideIndex == "undefined"
        ? i.getAttribute("data-swiper-slide-index") * 1
        : i.swiperSlideIndex;
    n[r] = i;
  }),
    s.slides.forEach((i) => {
      i.removeAttribute("data-swiper-slide-index");
    }),
    n.forEach((i) => {
      t.append(i);
    }),
    s.recalcSlides(),
    s.slideTo(s.realIndex, 0);
}
var Mg = { loopCreate: xg, loopFix: yg, loopDestroy: Sg };
function bg(s) {
  const e = this;
  if (
    !e.params.simulateTouch ||
    (e.params.watchOverflow && e.isLocked) ||
    e.params.cssMode
  )
    return;
  const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
  e.isElement && (e.__preventObserver__ = !0),
    (t.style.cursor = "move"),
    (t.style.cursor = s ? "grabbing" : "grab"),
    e.isElement &&
      requestAnimationFrame(() => {
        e.__preventObserver__ = !1;
      });
}
function wg() {
  const s = this;
  (s.params.watchOverflow && s.isLocked) ||
    s.params.cssMode ||
    (s.isElement && (s.__preventObserver__ = !0),
    (s[
      s.params.touchEventsTarget === "container" ? "el" : "wrapperEl"
    ].style.cursor = ""),
    s.isElement &&
      requestAnimationFrame(() => {
        s.__preventObserver__ = !1;
      }));
}
var Tg = { setGrabCursor: bg, unsetGrabCursor: wg };
function Eg(s, e) {
  e === void 0 && (e = this);
  function t(n) {
    if (!n || n === bi() || n === Ct()) return null;
    n.assignedSlot && (n = n.assignedSlot);
    const i = n.closest(s);
    return !i && !n.getRootNode ? null : i || t(n.getRootNode().host);
  }
  return t(e);
}
function Rc(s, e, t) {
  const n = Ct(),
    { params: i } = s,
    r = i.edgeSwipeDetection,
    a = i.edgeSwipeThreshold;
  return r && (t <= a || t >= n.innerWidth - a)
    ? r === "prevent"
      ? (e.preventDefault(), !0)
      : !1
    : !0;
}
function Ag(s) {
  const e = this,
    t = bi();
  let n = s;
  n.originalEvent && (n = n.originalEvent);
  const i = e.touchEventsData;
  if (n.type === "pointerdown") {
    if (i.pointerId !== null && i.pointerId !== n.pointerId) return;
    i.pointerId = n.pointerId;
  } else
    n.type === "touchstart" &&
      n.targetTouches.length === 1 &&
      (i.touchId = n.targetTouches[0].identifier);
  if (n.type === "touchstart") {
    Rc(e, n, n.targetTouches[0].pageX);
    return;
  }
  const { params: r, touches: a, enabled: o } = e;
  if (
    !o ||
    (!r.simulateTouch && n.pointerType === "mouse") ||
    (e.animating && r.preventInteractionOnTransition)
  )
    return;
  !e.animating && r.cssMode && r.loop && e.loopFix();
  let l = n.target;
  if (
    (r.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(l)) ||
    ("which" in n && n.which === 3) ||
    ("button" in n && n.button > 0) ||
    (i.isTouched && i.isMoved)
  )
    return;
  const c = !!r.noSwipingClass && r.noSwipingClass !== "",
    u = n.composedPath ? n.composedPath() : n.path;
  c && n.target && n.target.shadowRoot && u && (l = u[0]);
  const d = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`,
    f = !!(n.target && n.target.shadowRoot);
  if (r.noSwiping && (f ? Eg(d, l) : l.closest(d))) {
    e.allowClick = !0;
    return;
  }
  if (r.swipeHandler && !l.closest(r.swipeHandler)) return;
  (a.currentX = n.pageX), (a.currentY = n.pageY);
  const h = a.currentX,
    _ = a.currentY;
  if (!Rc(e, n, h)) return;
  Object.assign(i, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0,
  }),
    (a.startX = h),
    (a.startY = _),
    (i.touchStartTime = Hn()),
    (e.allowClick = !0),
    e.updateSize(),
    (e.swipeDirection = void 0),
    r.threshold > 0 && (i.allowThresholdMove = !1);
  let m = !0;
  l.matches(i.focusableElements) &&
    ((m = !1), l.nodeName === "SELECT" && (i.isTouched = !1)),
    t.activeElement &&
      t.activeElement.matches(i.focusableElements) &&
      t.activeElement !== l &&
      t.activeElement.blur();
  const g = m && e.allowTouchMove && r.touchStartPreventDefault;
  (r.touchStartForcePreventDefault || g) &&
    !l.isContentEditable &&
    n.preventDefault(),
    r.freeMode &&
      r.freeMode.enabled &&
      e.freeMode &&
      e.animating &&
      !r.cssMode &&
      e.freeMode.onTouchStart(),
    e.emit("touchStart", n);
}
function Cg(s) {
  const e = bi(),
    t = this,
    n = t.touchEventsData,
    { params: i, touches: r, rtlTranslate: a, enabled: o } = t;
  if (!o || (!i.simulateTouch && s.pointerType === "mouse")) return;
  let l = s;
  if (
    (l.originalEvent && (l = l.originalEvent),
    l.type === "pointermove" &&
      (n.touchId !== null || l.pointerId !== n.pointerId))
  )
    return;
  let c;
  if (l.type === "touchmove") {
    if (
      ((c = [...l.changedTouches].filter((w) => w.identifier === n.touchId)[0]),
      !c || c.identifier !== n.touchId)
    )
      return;
  } else c = l;
  if (!n.isTouched) {
    n.startMoving && n.isScrolling && t.emit("touchMoveOpposite", l);
    return;
  }
  const u = c.pageX,
    d = c.pageY;
  if (l.preventedByNestedSwiper) {
    (r.startX = u), (r.startY = d);
    return;
  }
  if (!t.allowTouchMove) {
    l.target.matches(n.focusableElements) || (t.allowClick = !1),
      n.isTouched &&
        (Object.assign(r, { startX: u, startY: d, currentX: u, currentY: d }),
        (n.touchStartTime = Hn()));
    return;
  }
  if (i.touchReleaseOnEdges && !i.loop) {
    if (t.isVertical()) {
      if (
        (d < r.startY && t.translate <= t.maxTranslate()) ||
        (d > r.startY && t.translate >= t.minTranslate())
      ) {
        (n.isTouched = !1), (n.isMoved = !1);
        return;
      }
    } else if (
      (u < r.startX && t.translate <= t.maxTranslate()) ||
      (u > r.startX && t.translate >= t.minTranslate())
    )
      return;
  }
  if (
    e.activeElement &&
    l.target === e.activeElement &&
    l.target.matches(n.focusableElements)
  ) {
    (n.isMoved = !0), (t.allowClick = !1);
    return;
  }
  n.allowTouchCallbacks && t.emit("touchMove", l),
    (r.previousX = r.currentX),
    (r.previousY = r.currentY),
    (r.currentX = u),
    (r.currentY = d);
  const f = r.currentX - r.startX,
    h = r.currentY - r.startY;
  if (t.params.threshold && Math.sqrt(f ** 2 + h ** 2) < t.params.threshold)
    return;
  if (typeof n.isScrolling == "undefined") {
    let w;
    (t.isHorizontal() && r.currentY === r.startY) ||
    (t.isVertical() && r.currentX === r.startX)
      ? (n.isScrolling = !1)
      : f * f + h * h >= 25 &&
        ((w = (Math.atan2(Math.abs(h), Math.abs(f)) * 180) / Math.PI),
        (n.isScrolling = t.isHorizontal()
          ? w > i.touchAngle
          : 90 - w > i.touchAngle));
  }
  if (
    (n.isScrolling && t.emit("touchMoveOpposite", l),
    typeof n.startMoving == "undefined" &&
      (r.currentX !== r.startX || r.currentY !== r.startY) &&
      (n.startMoving = !0),
    n.isScrolling)
  ) {
    n.isTouched = !1;
    return;
  }
  if (!n.startMoving) return;
  (t.allowClick = !1),
    !i.cssMode && l.cancelable && l.preventDefault(),
    i.touchMoveStopPropagation && !i.nested && l.stopPropagation();
  let _ = t.isHorizontal() ? f : h,
    m = t.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY;
  i.oneWayMovement &&
    ((_ = Math.abs(_) * (a ? 1 : -1)), (m = Math.abs(m) * (a ? 1 : -1))),
    (r.diff = _),
    (_ *= i.touchRatio),
    a && ((_ = -_), (m = -m));
  const g = t.touchesDirection;
  (t.swipeDirection = _ > 0 ? "prev" : "next"),
    (t.touchesDirection = m > 0 ? "prev" : "next");
  const p = t.params.loop && !i.cssMode,
    y =
      (t.touchesDirection === "next" && t.allowSlideNext) ||
      (t.touchesDirection === "prev" && t.allowSlidePrev);
  if (!n.isMoved) {
    if (
      (p && y && t.loopFix({ direction: t.swipeDirection }),
      (n.startTranslate = t.getTranslate()),
      t.setTransition(0),
      t.animating)
    ) {
      const w = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0,
      });
      t.wrapperEl.dispatchEvent(w);
    }
    (n.allowMomentumBounce = !1),
      i.grabCursor &&
        (t.allowSlideNext === !0 || t.allowSlidePrev === !0) &&
        t.setGrabCursor(!0),
      t.emit("sliderFirstMove", l);
  }
  let v;
  if (
    (new Date().getTime(),
    n.isMoved &&
      n.allowThresholdMove &&
      g !== t.touchesDirection &&
      p &&
      y &&
      Math.abs(_) >= 1)
  ) {
    Object.assign(r, {
      startX: u,
      startY: d,
      currentX: u,
      currentY: d,
      startTranslate: n.currentTranslate,
    }),
      (n.loopSwapReset = !0),
      (n.startTranslate = n.currentTranslate);
    return;
  }
  t.emit("sliderMove", l),
    (n.isMoved = !0),
    (n.currentTranslate = _ + n.startTranslate);
  let x = !0,
    S = i.resistanceRatio;
  if (
    (i.touchReleaseOnEdges && (S = 0),
    _ > 0
      ? (p &&
          y &&
          !v &&
          n.allowThresholdMove &&
          n.currentTranslate >
            (i.centeredSlides
              ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1]
              : t.minTranslate()) &&
          t.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0,
          }),
        n.currentTranslate > t.minTranslate() &&
          ((x = !1),
          i.resistance &&
            (n.currentTranslate =
              t.minTranslate() -
              1 +
              (-t.minTranslate() + n.startTranslate + _) ** S)))
      : _ < 0 &&
        (p &&
          y &&
          !v &&
          n.allowThresholdMove &&
          n.currentTranslate <
            (i.centeredSlides
              ? t.maxTranslate() +
                t.slidesSizesGrid[t.slidesSizesGrid.length - 1]
              : t.maxTranslate()) &&
          t.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex:
              t.slides.length -
              (i.slidesPerView === "auto"
                ? t.slidesPerViewDynamic()
                : Math.ceil(parseFloat(i.slidesPerView, 10))),
          }),
        n.currentTranslate < t.maxTranslate() &&
          ((x = !1),
          i.resistance &&
            (n.currentTranslate =
              t.maxTranslate() +
              1 -
              (t.maxTranslate() - n.startTranslate - _) ** S))),
    x && (l.preventedByNestedSwiper = !0),
    !t.allowSlideNext &&
      t.swipeDirection === "next" &&
      n.currentTranslate < n.startTranslate &&
      (n.currentTranslate = n.startTranslate),
    !t.allowSlidePrev &&
      t.swipeDirection === "prev" &&
      n.currentTranslate > n.startTranslate &&
      (n.currentTranslate = n.startTranslate),
    !t.allowSlidePrev &&
      !t.allowSlideNext &&
      (n.currentTranslate = n.startTranslate),
    i.threshold > 0)
  )
    if (Math.abs(_) > i.threshold || n.allowThresholdMove) {
      if (!n.allowThresholdMove) {
        (n.allowThresholdMove = !0),
          (r.startX = r.currentX),
          (r.startY = r.currentY),
          (n.currentTranslate = n.startTranslate),
          (r.diff = t.isHorizontal()
            ? r.currentX - r.startX
            : r.currentY - r.startY);
        return;
      }
    } else {
      n.currentTranslate = n.startTranslate;
      return;
    }
  !i.followFinger ||
    i.cssMode ||
    (((i.freeMode && i.freeMode.enabled && t.freeMode) ||
      i.watchSlidesProgress) &&
      (t.updateActiveIndex(), t.updateSlidesClasses()),
    i.freeMode && i.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(),
    t.updateProgress(n.currentTranslate),
    t.setTranslate(n.currentTranslate));
}
function Pg(s) {
  const e = this,
    t = e.touchEventsData;
  let n = s;
  n.originalEvent && (n = n.originalEvent);
  let i;
  if (n.type === "touchend" || n.type === "touchcancel") {
    if (
      ((i = [...n.changedTouches].filter((S) => S.identifier === t.touchId)[0]),
      !i || i.identifier !== t.touchId)
    )
      return;
  } else {
    if (t.touchId !== null || n.pointerId !== t.pointerId) return;
    i = n;
  }
  if (
    ["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(
      n.type
    ) &&
    !(
      ["pointercancel", "contextmenu"].includes(n.type) &&
      (e.browser.isSafari || e.browser.isWebView)
    )
  )
    return;
  (t.pointerId = null), (t.touchId = null);
  const {
    params: a,
    touches: o,
    rtlTranslate: l,
    slidesGrid: c,
    enabled: u,
  } = e;
  if (!u || (!a.simulateTouch && n.pointerType === "mouse")) return;
  if (
    (t.allowTouchCallbacks && e.emit("touchEnd", n),
    (t.allowTouchCallbacks = !1),
    !t.isTouched)
  ) {
    t.isMoved && a.grabCursor && e.setGrabCursor(!1),
      (t.isMoved = !1),
      (t.startMoving = !1);
    return;
  }
  a.grabCursor &&
    t.isMoved &&
    t.isTouched &&
    (e.allowSlideNext === !0 || e.allowSlidePrev === !0) &&
    e.setGrabCursor(!1);
  const d = Hn(),
    f = d - t.touchStartTime;
  if (e.allowClick) {
    const S = n.path || (n.composedPath && n.composedPath());
    e.updateClickedSlide((S && S[0]) || n.target, S),
      e.emit("tap click", n),
      f < 300 &&
        d - t.lastClickTime < 300 &&
        e.emit("doubleTap doubleClick", n);
  }
  if (
    ((t.lastClickTime = Hn()),
    Ps(() => {
      e.destroyed || (e.allowClick = !0);
    }),
    !t.isTouched ||
      !t.isMoved ||
      !e.swipeDirection ||
      (o.diff === 0 && !t.loopSwapReset) ||
      (t.currentTranslate === t.startTranslate && !t.loopSwapReset))
  ) {
    (t.isTouched = !1), (t.isMoved = !1), (t.startMoving = !1);
    return;
  }
  (t.isTouched = !1), (t.isMoved = !1), (t.startMoving = !1);
  let h;
  if (
    (a.followFinger
      ? (h = l ? e.translate : -e.translate)
      : (h = -t.currentTranslate),
    a.cssMode)
  )
    return;
  if (a.freeMode && a.freeMode.enabled) {
    e.freeMode.onTouchEnd({ currentPos: h });
    return;
  }
  const _ = h >= -e.maxTranslate() && !e.params.loop;
  let m = 0,
    g = e.slidesSizesGrid[0];
  for (
    let S = 0;
    S < c.length;
    S += S < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup
  ) {
    const w = S < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
    typeof c[S + w] != "undefined"
      ? (_ || (h >= c[S] && h < c[S + w])) && ((m = S), (g = c[S + w] - c[S]))
      : (_ || h >= c[S]) && ((m = S), (g = c[c.length - 1] - c[c.length - 2]));
  }
  let p = null,
    y = null;
  a.rewind &&
    (e.isBeginning
      ? (y =
          a.virtual && a.virtual.enabled && e.virtual
            ? e.virtual.slides.length - 1
            : e.slides.length - 1)
      : e.isEnd && (p = 0));
  const v = (h - c[m]) / g,
    x = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
  if (f > a.longSwipesMs) {
    if (!a.longSwipes) {
      e.slideTo(e.activeIndex);
      return;
    }
    e.swipeDirection === "next" &&
      (v >= a.longSwipesRatio
        ? e.slideTo(a.rewind && e.isEnd ? p : m + x)
        : e.slideTo(m)),
      e.swipeDirection === "prev" &&
        (v > 1 - a.longSwipesRatio
          ? e.slideTo(m + x)
          : y !== null && v < 0 && Math.abs(v) > a.longSwipesRatio
          ? e.slideTo(y)
          : e.slideTo(m));
  } else {
    if (!a.shortSwipes) {
      e.slideTo(e.activeIndex);
      return;
    }
    e.navigation &&
    (n.target === e.navigation.nextEl || n.target === e.navigation.prevEl)
      ? n.target === e.navigation.nextEl
        ? e.slideTo(m + x)
        : e.slideTo(m)
      : (e.swipeDirection === "next" && e.slideTo(p !== null ? p : m + x),
        e.swipeDirection === "prev" && e.slideTo(y !== null ? y : m));
  }
}
function Dc() {
  const s = this,
    { params: e, el: t } = s;
  if (t && t.offsetWidth === 0) return;
  e.breakpoints && s.setBreakpoint();
  const { allowSlideNext: n, allowSlidePrev: i, snapGrid: r } = s,
    a = s.virtual && s.params.virtual.enabled;
  (s.allowSlideNext = !0),
    (s.allowSlidePrev = !0),
    s.updateSize(),
    s.updateSlides(),
    s.updateSlidesClasses();
  const o = a && e.loop;
  (e.slidesPerView === "auto" || e.slidesPerView > 1) &&
  s.isEnd &&
  !s.isBeginning &&
  !s.params.centeredSlides &&
  !o
    ? s.slideTo(s.slides.length - 1, 0, !1, !0)
    : s.params.loop && !a
    ? s.slideToLoop(s.realIndex, 0, !1, !0)
    : s.slideTo(s.activeIndex, 0, !1, !0),
    s.autoplay &&
      s.autoplay.running &&
      s.autoplay.paused &&
      (clearTimeout(s.autoplay.resizeTimeout),
      (s.autoplay.resizeTimeout = setTimeout(() => {
        s.autoplay &&
          s.autoplay.running &&
          s.autoplay.paused &&
          s.autoplay.resume();
      }, 500))),
    (s.allowSlidePrev = i),
    (s.allowSlideNext = n),
    s.params.watchOverflow && r !== s.snapGrid && s.checkOverflow();
}
function Lg(s) {
  const e = this;
  !e.enabled ||
    e.allowClick ||
    (e.params.preventClicks && s.preventDefault(),
    e.params.preventClicksPropagation &&
      e.animating &&
      (s.stopPropagation(), s.stopImmediatePropagation()));
}
function Rg() {
  const s = this,
    { wrapperEl: e, rtlTranslate: t, enabled: n } = s;
  if (!n) return;
  (s.previousTranslate = s.translate),
    s.isHorizontal()
      ? (s.translate = -e.scrollLeft)
      : (s.translate = -e.scrollTop),
    s.translate === 0 && (s.translate = 0),
    s.updateActiveIndex(),
    s.updateSlidesClasses();
  let i;
  const r = s.maxTranslate() - s.minTranslate();
  r === 0 ? (i = 0) : (i = (s.translate - s.minTranslate()) / r),
    i !== s.progress && s.updateProgress(t ? -s.translate : s.translate),
    s.emit("setTranslate", s.translate, !1);
}
function Dg(s) {
  const e = this;
  xa(e, s.target),
    !(
      e.params.cssMode ||
      (e.params.slidesPerView !== "auto" && !e.params.autoHeight)
    ) && e.update();
}
function Ig() {
  const s = this;
  s.documentTouchHandlerProceeded ||
    ((s.documentTouchHandlerProceeded = !0),
    s.params.touchReleaseOnEdges && (s.el.style.touchAction = "auto"));
}
const qf = (s, e) => {
  const t = bi(),
    { params: n, el: i, wrapperEl: r, device: a } = s,
    o = !!n.nested,
    l = e === "on" ? "addEventListener" : "removeEventListener",
    c = e;
  t[l]("touchstart", s.onDocumentTouchStart, { passive: !1, capture: o }),
    i[l]("touchstart", s.onTouchStart, { passive: !1 }),
    i[l]("pointerdown", s.onTouchStart, { passive: !1 }),
    t[l]("touchmove", s.onTouchMove, { passive: !1, capture: o }),
    t[l]("pointermove", s.onTouchMove, { passive: !1, capture: o }),
    t[l]("touchend", s.onTouchEnd, { passive: !0 }),
    t[l]("pointerup", s.onTouchEnd, { passive: !0 }),
    t[l]("pointercancel", s.onTouchEnd, { passive: !0 }),
    t[l]("touchcancel", s.onTouchEnd, { passive: !0 }),
    t[l]("pointerout", s.onTouchEnd, { passive: !0 }),
    t[l]("pointerleave", s.onTouchEnd, { passive: !0 }),
    t[l]("contextmenu", s.onTouchEnd, { passive: !0 }),
    (n.preventClicks || n.preventClicksPropagation) &&
      i[l]("click", s.onClick, !0),
    n.cssMode && r[l]("scroll", s.onScroll),
    n.updateOnWindowResize
      ? s[c](
          a.ios || a.android
            ? "resize orientationchange observerUpdate"
            : "resize observerUpdate",
          Dc,
          !0
        )
      : s[c]("observerUpdate", Dc, !0),
    i[l]("load", s.onLoad, { capture: !0 });
};
function Og() {
  const s = this,
    { params: e } = s;
  (s.onTouchStart = Ag.bind(s)),
    (s.onTouchMove = Cg.bind(s)),
    (s.onTouchEnd = Pg.bind(s)),
    (s.onDocumentTouchStart = Ig.bind(s)),
    e.cssMode && (s.onScroll = Rg.bind(s)),
    (s.onClick = Lg.bind(s)),
    (s.onLoad = Dg.bind(s)),
    qf(s, "on");
}
function Ng() {
  qf(this, "off");
}
var Ug = { attachEvents: Og, detachEvents: Ng };
const Ic = (s, e) => s.grid && e.grid && e.grid.rows > 1;
function Fg() {
  const s = this,
    { realIndex: e, initialized: t, params: n, el: i } = s,
    r = n.breakpoints;
  if (!r || (r && Object.keys(r).length === 0)) return;
  const a = s.getBreakpoint(r, s.params.breakpointsBase, s.el);
  if (!a || s.currentBreakpoint === a) return;
  const l = (a in r ? r[a] : void 0) || s.originalParams,
    c = Ic(s, n),
    u = Ic(s, l),
    d = n.enabled;
  c && !u
    ? (i.classList.remove(
        `${n.containerModifierClass}grid`,
        `${n.containerModifierClass}grid-column`
      ),
      s.emitContainerClasses())
    : !c &&
      u &&
      (i.classList.add(`${n.containerModifierClass}grid`),
      ((l.grid.fill && l.grid.fill === "column") ||
        (!l.grid.fill && n.grid.fill === "column")) &&
        i.classList.add(`${n.containerModifierClass}grid-column`),
      s.emitContainerClasses()),
    ["navigation", "pagination", "scrollbar"].forEach((p) => {
      if (typeof l[p] == "undefined") return;
      const y = n[p] && n[p].enabled,
        v = l[p] && l[p].enabled;
      y && !v && s[p].disable(), !y && v && s[p].enable();
    });
  const f = l.direction && l.direction !== n.direction,
    h = n.loop && (l.slidesPerView !== n.slidesPerView || f),
    _ = n.loop;
  f && t && s.changeDirection(), $t(s.params, l);
  const m = s.params.enabled,
    g = s.params.loop;
  Object.assign(s, {
    allowTouchMove: s.params.allowTouchMove,
    allowSlideNext: s.params.allowSlideNext,
    allowSlidePrev: s.params.allowSlidePrev,
  }),
    d && !m ? s.disable() : !d && m && s.enable(),
    (s.currentBreakpoint = a),
    s.emit("_beforeBreakpoint", l),
    t &&
      (h
        ? (s.loopDestroy(), s.loopCreate(e), s.updateSlides())
        : !_ && g
        ? (s.loopCreate(e), s.updateSlides())
        : _ && !g && s.loopDestroy()),
    s.emit("breakpoint", l);
}
function kg(s, e, t) {
  if ((e === void 0 && (e = "window"), !s || (e === "container" && !t))) return;
  let n = !1;
  const i = Ct(),
    r = e === "window" ? i.innerHeight : t.clientHeight,
    a = Object.keys(s).map((o) => {
      if (typeof o == "string" && o.indexOf("@") === 0) {
        const l = parseFloat(o.substr(1));
        return { value: r * l, point: o };
      }
      return { value: o, point: o };
    });
  a.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10));
  for (let o = 0; o < a.length; o += 1) {
    const { point: l, value: c } = a[o];
    e === "window"
      ? i.matchMedia(`(min-width: ${c}px)`).matches && (n = l)
      : c <= t.clientWidth && (n = l);
  }
  return n || "max";
}
var zg = { setBreakpoint: Fg, getBreakpoint: kg };
function Bg(s, e) {
  const t = [];
  return (
    s.forEach((n) => {
      typeof n == "object"
        ? Object.keys(n).forEach((i) => {
            n[i] && t.push(e + i);
          })
        : typeof n == "string" && t.push(e + n);
    }),
    t
  );
}
function Vg() {
  const s = this,
    { classNames: e, params: t, rtl: n, el: i, device: r } = s,
    a = Bg(
      [
        "initialized",
        t.direction,
        { "free-mode": s.params.freeMode && t.freeMode.enabled },
        { autoheight: t.autoHeight },
        { rtl: n },
        { grid: t.grid && t.grid.rows > 1 },
        {
          "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column",
        },
        { android: r.android },
        { ios: r.ios },
        { "css-mode": t.cssMode },
        { centered: t.cssMode && t.centeredSlides },
        { "watch-progress": t.watchSlidesProgress },
      ],
      t.containerModifierClass
    );
  e.push(...a), i.classList.add(...e), s.emitContainerClasses();
}
function Gg() {
  const s = this,
    { el: e, classNames: t } = s;
  e.classList.remove(...t), s.emitContainerClasses();
}
var Hg = { addClasses: Vg, removeClasses: Gg };
function Wg() {
  const s = this,
    { isLocked: e, params: t } = s,
    { slidesOffsetBefore: n } = t;
  if (n) {
    const i = s.slides.length - 1,
      r = s.slidesGrid[i] + s.slidesSizesGrid[i] + n * 2;
    s.isLocked = s.size > r;
  } else s.isLocked = s.snapGrid.length === 1;
  t.allowSlideNext === !0 && (s.allowSlideNext = !s.isLocked),
    t.allowSlidePrev === !0 && (s.allowSlidePrev = !s.isLocked),
    e && e !== s.isLocked && (s.isEnd = !1),
    e !== s.isLocked && s.emit(s.isLocked ? "lock" : "unlock");
}
var qg = { checkOverflow: Wg },
  Oc = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: 0.85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1,
  };
function Xg(s, e) {
  return function (n) {
    n === void 0 && (n = {});
    const i = Object.keys(n)[0],
      r = n[i];
    if (typeof r != "object" || r === null) {
      $t(e, n);
      return;
    }
    if (
      (s[i] === !0 && (s[i] = { enabled: !0 }),
      i === "navigation" &&
        s[i] &&
        s[i].enabled &&
        !s[i].prevEl &&
        !s[i].nextEl &&
        (s[i].auto = !0),
      ["pagination", "scrollbar"].indexOf(i) >= 0 &&
        s[i] &&
        s[i].enabled &&
        !s[i].el &&
        (s[i].auto = !0),
      !(i in s && "enabled" in r))
    ) {
      $t(e, n);
      return;
    }
    typeof s[i] == "object" && !("enabled" in s[i]) && (s[i].enabled = !0),
      s[i] || (s[i] = { enabled: !1 }),
      $t(e, n);
  };
}
const co = {
    eventsEmitter: Hm,
    update: eg,
    translate: ag,
    transition: ug,
    slide: vg,
    loop: Mg,
    grabCursor: Tg,
    events: Ug,
    breakpoints: zg,
    checkOverflow: qg,
    classes: Hg,
  },
  uo = {};
class on {
  constructor() {
    let e, t;
    for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)
      i[r] = arguments[r];
    i.length === 1 &&
    i[0].constructor &&
    Object.prototype.toString.call(i[0]).slice(8, -1) === "Object"
      ? (t = i[0])
      : ([e, t] = i),
      t || (t = {}),
      (t = $t({}, t)),
      e && !t.el && (t.el = e);
    const a = bi();
    if (
      t.el &&
      typeof t.el == "string" &&
      a.querySelectorAll(t.el).length > 1
    ) {
      const u = [];
      return (
        a.querySelectorAll(t.el).forEach((d) => {
          const f = $t({}, t, { el: d });
          u.push(new on(f));
        }),
        u
      );
    }
    const o = this;
    (o.__swiper__ = !0),
      (o.support = Hf()),
      (o.device = km({ userAgent: t.userAgent })),
      (o.browser = Bm()),
      (o.eventsListeners = {}),
      (o.eventsAnyListeners = []),
      (o.modules = [...o.__modules__]),
      t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules);
    const l = {};
    o.modules.forEach((u) => {
      u({
        params: t,
        swiper: o,
        extendParams: Xg(t, l),
        on: o.on.bind(o),
        once: o.once.bind(o),
        off: o.off.bind(o),
        emit: o.emit.bind(o),
      });
    });
    const c = $t({}, Oc, l);
    return (
      (o.params = $t({}, c, uo, t)),
      (o.originalParams = $t({}, o.params)),
      (o.passedParams = $t({}, t)),
      o.params &&
        o.params.on &&
        Object.keys(o.params.on).forEach((u) => {
          o.on(u, o.params.on[u]);
        }),
      o.params && o.params.onAny && o.onAny(o.params.onAny),
      Object.assign(o, {
        enabled: o.params.enabled,
        el: e,
        classNames: [],
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal() {
          return o.params.direction === "horizontal";
        },
        isVertical() {
          return o.params.direction === "vertical";
        },
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        allowSlideNext: o.params.allowSlideNext,
        allowSlidePrev: o.params.allowSlidePrev,
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: o.params.focusableElements,
          lastClickTime: 0,
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null,
        },
        allowClick: !0,
        allowTouchMove: o.params.allowTouchMove,
        touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 },
        imagesToLoad: [],
        imagesLoaded: 0,
      }),
      o.emit("_swiper"),
      o.params.init && o.init(),
      o
    );
  }
  getDirectionLabel(e) {
    return this.isHorizontal()
      ? e
      : {
          width: "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          marginRight: "marginBottom",
        }[e];
  }
  getSlideIndex(e) {
    const { slidesEl: t, params: n } = this,
      i = En(t, `.${n.slideClass}, swiper-slide`),
      r = Pc(i[0]);
    return Pc(e) - r;
  }
  getSlideIndexByData(e) {
    return this.getSlideIndex(
      this.slides.filter(
        (t) => t.getAttribute("data-swiper-slide-index") * 1 === e
      )[0]
    );
  }
  recalcSlides() {
    const e = this,
      { slidesEl: t, params: n } = e;
    e.slides = En(t, `.${n.slideClass}, swiper-slide`);
  }
  enable() {
    const e = this;
    e.enabled ||
      ((e.enabled = !0),
      e.params.grabCursor && e.setGrabCursor(),
      e.emit("enable"));
  }
  disable() {
    const e = this;
    !e.enabled ||
      ((e.enabled = !1),
      e.params.grabCursor && e.unsetGrabCursor(),
      e.emit("disable"));
  }
  setProgress(e, t) {
    const n = this;
    e = Math.min(Math.max(e, 0), 1);
    const i = n.minTranslate(),
      a = (n.maxTranslate() - i) * e + i;
    n.translateTo(a, typeof t == "undefined" ? 0 : t),
      n.updateActiveIndex(),
      n.updateSlidesClasses();
  }
  emitContainerClasses() {
    const e = this;
    if (!e.params._emitClasses || !e.el) return;
    const t = e.el.className
      .split(" ")
      .filter(
        (n) =>
          n.indexOf("swiper") === 0 ||
          n.indexOf(e.params.containerModifierClass) === 0
      );
    e.emit("_containerClasses", t.join(" "));
  }
  getSlideClasses(e) {
    const t = this;
    return t.destroyed
      ? ""
      : e.className
          .split(" ")
          .filter(
            (n) =>
              n.indexOf("swiper-slide") === 0 ||
              n.indexOf(t.params.slideClass) === 0
          )
          .join(" ");
  }
  emitSlidesClasses() {
    const e = this;
    if (!e.params._emitClasses || !e.el) return;
    const t = [];
    e.slides.forEach((n) => {
      const i = e.getSlideClasses(n);
      t.push({ slideEl: n, classNames: i }), e.emit("_slideClass", n, i);
    }),
      e.emit("_slideClasses", t);
  }
  slidesPerViewDynamic(e, t) {
    e === void 0 && (e = "current"), t === void 0 && (t = !1);
    const n = this,
      {
        params: i,
        slides: r,
        slidesGrid: a,
        slidesSizesGrid: o,
        size: l,
        activeIndex: c,
      } = n;
    let u = 1;
    if (typeof i.slidesPerView == "number") return i.slidesPerView;
    if (i.centeredSlides) {
      let d = r[c] ? r[c].swiperSlideSize : 0,
        f;
      for (let h = c + 1; h < r.length; h += 1)
        r[h] &&
          !f &&
          ((d += r[h].swiperSlideSize), (u += 1), d > l && (f = !0));
      for (let h = c - 1; h >= 0; h -= 1)
        r[h] &&
          !f &&
          ((d += r[h].swiperSlideSize), (u += 1), d > l && (f = !0));
    } else if (e === "current")
      for (let d = c + 1; d < r.length; d += 1)
        (t ? a[d] + o[d] - a[c] < l : a[d] - a[c] < l) && (u += 1);
    else for (let d = c - 1; d >= 0; d -= 1) a[c] - a[d] < l && (u += 1);
    return u;
  }
  update() {
    const e = this;
    if (!e || e.destroyed) return;
    const { snapGrid: t, params: n } = e;
    n.breakpoints && e.setBreakpoint(),
      [...e.el.querySelectorAll('[loading="lazy"]')].forEach((a) => {
        a.complete && xa(e, a);
      }),
      e.updateSize(),
      e.updateSlides(),
      e.updateProgress(),
      e.updateSlidesClasses();
    function i() {
      const a = e.rtlTranslate ? e.translate * -1 : e.translate,
        o = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate());
      e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses();
    }
    let r;
    if (n.freeMode && n.freeMode.enabled && !n.cssMode)
      i(), n.autoHeight && e.updateAutoHeight();
    else {
      if (
        (n.slidesPerView === "auto" || n.slidesPerView > 1) &&
        e.isEnd &&
        !n.centeredSlides
      ) {
        const a = e.virtual && n.virtual.enabled ? e.virtual.slides : e.slides;
        r = e.slideTo(a.length - 1, 0, !1, !0);
      } else r = e.slideTo(e.activeIndex, 0, !1, !0);
      r || i();
    }
    n.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
  }
  changeDirection(e, t) {
    t === void 0 && (t = !0);
    const n = this,
      i = n.params.direction;
    return (
      e || (e = i === "horizontal" ? "vertical" : "horizontal"),
      e === i ||
        (e !== "horizontal" && e !== "vertical") ||
        (n.el.classList.remove(`${n.params.containerModifierClass}${i}`),
        n.el.classList.add(`${n.params.containerModifierClass}${e}`),
        n.emitContainerClasses(),
        (n.params.direction = e),
        n.slides.forEach((r) => {
          e === "vertical" ? (r.style.width = "") : (r.style.height = "");
        }),
        n.emit("changeDirection"),
        t && n.update()),
      n
    );
  }
  changeLanguageDirection(e) {
    const t = this;
    (t.rtl && e === "rtl") ||
      (!t.rtl && e === "ltr") ||
      ((t.rtl = e === "rtl"),
      (t.rtlTranslate = t.params.direction === "horizontal" && t.rtl),
      t.rtl
        ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
          (t.el.dir = "rtl"))
        : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
          (t.el.dir = "ltr")),
      t.update());
  }
  mount(e) {
    const t = this;
    if (t.mounted) return !0;
    let n = e || t.params.el;
    if ((typeof n == "string" && (n = document.querySelector(n)), !n))
      return !1;
    (n.swiper = t),
      n.parentNode &&
        n.parentNode.host &&
        n.parentNode.host.nodeName === "SWIPER-CONTAINER" &&
        (t.isElement = !0);
    const i = () =>
      `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
    let a = (() =>
      n && n.shadowRoot && n.shadowRoot.querySelector
        ? n.shadowRoot.querySelector(i())
        : En(n, i())[0])();
    return (
      !a &&
        t.params.createElements &&
        ((a = Da("div", t.params.wrapperClass)),
        n.append(a),
        En(n, `.${t.params.slideClass}`).forEach((o) => {
          a.append(o);
        })),
      Object.assign(t, {
        el: n,
        wrapperEl: a,
        slidesEl:
          t.isElement && !n.parentNode.host.slideSlots ? n.parentNode.host : a,
        hostEl: t.isElement ? n.parentNode.host : n,
        mounted: !0,
        rtl: n.dir.toLowerCase() === "rtl" || pi(n, "direction") === "rtl",
        rtlTranslate:
          t.params.direction === "horizontal" &&
          (n.dir.toLowerCase() === "rtl" || pi(n, "direction") === "rtl"),
        wrongRTL: pi(a, "display") === "-webkit-box",
      }),
      !0
    );
  }
  init(e) {
    const t = this;
    if (t.initialized || t.mount(e) === !1) return t;
    t.emit("beforeInit"),
      t.params.breakpoints && t.setBreakpoint(),
      t.addClasses(),
      t.updateSize(),
      t.updateSlides(),
      t.params.watchOverflow && t.checkOverflow(),
      t.params.grabCursor && t.enabled && t.setGrabCursor(),
      t.params.loop && t.virtual && t.params.virtual.enabled
        ? t.slideTo(
            t.params.initialSlide + t.virtual.slidesBefore,
            0,
            t.params.runCallbacksOnInit,
            !1,
            !0
          )
        : t.slideTo(
            t.params.initialSlide,
            0,
            t.params.runCallbacksOnInit,
            !1,
            !0
          ),
      t.params.loop && t.loopCreate(),
      t.attachEvents();
    const i = [...t.el.querySelectorAll('[loading="lazy"]')];
    return (
      t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
      i.forEach((r) => {
        r.complete
          ? xa(t, r)
          : r.addEventListener("load", (a) => {
              xa(t, a.target);
            });
      }),
      ll(t),
      (t.initialized = !0),
      ll(t),
      t.emit("init"),
      t.emit("afterInit"),
      t
    );
  }
  destroy(e, t) {
    e === void 0 && (e = !0), t === void 0 && (t = !0);
    const n = this,
      { params: i, el: r, wrapperEl: a, slides: o } = n;
    return (
      typeof n.params == "undefined" ||
        n.destroyed ||
        (n.emit("beforeDestroy"),
        (n.initialized = !1),
        n.detachEvents(),
        i.loop && n.loopDestroy(),
        t &&
          (n.removeClasses(),
          r.removeAttribute("style"),
          a.removeAttribute("style"),
          o &&
            o.length &&
            o.forEach((l) => {
              l.classList.remove(
                i.slideVisibleClass,
                i.slideFullyVisibleClass,
                i.slideActiveClass,
                i.slideNextClass,
                i.slidePrevClass
              ),
                l.removeAttribute("style"),
                l.removeAttribute("data-swiper-slide-index");
            })),
        n.emit("destroy"),
        Object.keys(n.eventsListeners).forEach((l) => {
          n.off(l);
        }),
        e !== !1 && ((n.el.swiper = null), Pm(n)),
        (n.destroyed = !0)),
      null
    );
  }
  static extendDefaults(e) {
    $t(uo, e);
  }
  static get extendedDefaults() {
    return uo;
  }
  static get defaults() {
    return Oc;
  }
  static installModule(e) {
    on.prototype.__modules__ || (on.prototype.__modules__ = []);
    const t = on.prototype.__modules__;
    typeof e == "function" && t.indexOf(e) < 0 && t.push(e);
  }
  static use(e) {
    return Array.isArray(e)
      ? (e.forEach((t) => on.installModule(t)), on)
      : (on.installModule(e), on);
  }
}
Object.keys(co).forEach((s) => {
  Object.keys(co[s]).forEach((e) => {
    on.prototype[e] = co[s][e];
  });
});
on.use([Vm, Gm]);
function jg(s) {
  let { swiper: e, extendParams: t, on: n, emit: i } = s;
  const r = bi(),
    a = Ct();
  (e.keyboard = { enabled: !1 }),
    t({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } });
  function o(u) {
    if (!e.enabled) return;
    const { rtlTranslate: d } = e;
    let f = u;
    f.originalEvent && (f = f.originalEvent);
    const h = f.keyCode || f.charCode,
      _ = e.params.keyboard.pageUpDown,
      m = _ && h === 33,
      g = _ && h === 34,
      p = h === 37,
      y = h === 39,
      v = h === 38,
      x = h === 40;
    if (
      (!e.allowSlideNext &&
        ((e.isHorizontal() && y) || (e.isVertical() && x) || g)) ||
      (!e.allowSlidePrev &&
        ((e.isHorizontal() && p) || (e.isVertical() && v) || m))
    )
      return !1;
    if (
      !(f.shiftKey || f.altKey || f.ctrlKey || f.metaKey) &&
      !(
        r.activeElement &&
        r.activeElement.nodeName &&
        (r.activeElement.nodeName.toLowerCase() === "input" ||
          r.activeElement.nodeName.toLowerCase() === "textarea")
      )
    ) {
      if (e.params.keyboard.onlyInViewport && (m || g || p || y || v || x)) {
        let S = !1;
        if (
          ol(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 &&
          ol(e.el, `.${e.params.slideActiveClass}`).length === 0
        )
          return;
        const w = e.el,
          A = w.clientWidth,
          C = w.clientHeight,
          M = a.innerWidth,
          b = a.innerHeight,
          R = Im(w);
        d && (R.left -= w.scrollLeft);
        const D = [
          [R.left, R.top],
          [R.left + A, R.top],
          [R.left, R.top + C],
          [R.left + A, R.top + C],
        ];
        for (let P = 0; P < D.length; P += 1) {
          const I = D[P];
          if (I[0] >= 0 && I[0] <= M && I[1] >= 0 && I[1] <= b) {
            if (I[0] === 0 && I[1] === 0) continue;
            S = !0;
          }
        }
        if (!S) return;
      }
      e.isHorizontal()
        ? ((m || g || p || y) &&
            (f.preventDefault ? f.preventDefault() : (f.returnValue = !1)),
          (((g || y) && !d) || ((m || p) && d)) && e.slideNext(),
          (((m || p) && !d) || ((g || y) && d)) && e.slidePrev())
        : ((m || g || v || x) &&
            (f.preventDefault ? f.preventDefault() : (f.returnValue = !1)),
          (g || x) && e.slideNext(),
          (m || v) && e.slidePrev()),
        i("keyPress", h);
    }
  }
  function l() {
    e.keyboard.enabled ||
      (r.addEventListener("keydown", o), (e.keyboard.enabled = !0));
  }
  function c() {
    !e.keyboard.enabled ||
      (r.removeEventListener("keydown", o), (e.keyboard.enabled = !1));
  }
  n("init", () => {
    e.params.keyboard.enabled && l();
  }),
    n("destroy", () => {
      e.keyboard.enabled && c();
    }),
    Object.assign(e.keyboard, { enable: l, disable: c });
}
function Yg(s) {
  let { swiper: e, extendParams: t, on: n, emit: i } = s;
  const r = Ct();
  t({
    mousewheel: {
      enabled: !1,
      releaseOnEdges: !1,
      invert: !1,
      forceToAxis: !1,
      sensitivity: 1,
      eventsTarget: "container",
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: "swiper-no-mousewheel",
    },
  }),
    (e.mousewheel = { enabled: !1 });
  let a,
    o = Hn(),
    l;
  const c = [];
  function u(v) {
    let A = 0,
      C = 0,
      M = 0,
      b = 0;
    return (
      "detail" in v && (C = v.detail),
      "wheelDelta" in v && (C = -v.wheelDelta / 120),
      "wheelDeltaY" in v && (C = -v.wheelDeltaY / 120),
      "wheelDeltaX" in v && (A = -v.wheelDeltaX / 120),
      "axis" in v && v.axis === v.HORIZONTAL_AXIS && ((A = C), (C = 0)),
      (M = A * 10),
      (b = C * 10),
      "deltaY" in v && (b = v.deltaY),
      "deltaX" in v && (M = v.deltaX),
      v.shiftKey && !M && ((M = b), (b = 0)),
      (M || b) &&
        v.deltaMode &&
        (v.deltaMode === 1 ? ((M *= 40), (b *= 40)) : ((M *= 800), (b *= 800))),
      M && !A && (A = M < 1 ? -1 : 1),
      b && !C && (C = b < 1 ? -1 : 1),
      { spinX: A, spinY: C, pixelX: M, pixelY: b }
    );
  }
  function d() {
    !e.enabled || (e.mouseEntered = !0);
  }
  function f() {
    !e.enabled || (e.mouseEntered = !1);
  }
  function h(v) {
    return (e.params.mousewheel.thresholdDelta &&
      v.delta < e.params.mousewheel.thresholdDelta) ||
      (e.params.mousewheel.thresholdTime &&
        Hn() - o < e.params.mousewheel.thresholdTime)
      ? !1
      : v.delta >= 6 && Hn() - o < 60
      ? !0
      : (v.direction < 0
          ? (!e.isEnd || e.params.loop) &&
            !e.animating &&
            (e.slideNext(), i("scroll", v.raw))
          : (!e.isBeginning || e.params.loop) &&
            !e.animating &&
            (e.slidePrev(), i("scroll", v.raw)),
        (o = new r.Date().getTime()),
        !1);
  }
  function _(v) {
    const x = e.params.mousewheel;
    if (v.direction < 0) {
      if (e.isEnd && !e.params.loop && x.releaseOnEdges) return !0;
    } else if (e.isBeginning && !e.params.loop && x.releaseOnEdges) return !0;
    return !1;
  }
  function m(v) {
    let x = v,
      S = !0;
    if (
      !e.enabled ||
      v.target.closest(`.${e.params.mousewheel.noMousewheelClass}`)
    )
      return;
    const w = e.params.mousewheel;
    e.params.cssMode && x.preventDefault();
    let A = e.el;
    e.params.mousewheel.eventsTarget !== "container" &&
      (A = document.querySelector(e.params.mousewheel.eventsTarget));
    const C = A && A.contains(x.target);
    if (!e.mouseEntered && !C && !w.releaseOnEdges) return !0;
    x.originalEvent && (x = x.originalEvent);
    let M = 0;
    const b = e.rtlTranslate ? -1 : 1,
      R = u(x);
    if (w.forceToAxis)
      if (e.isHorizontal())
        if (Math.abs(R.pixelX) > Math.abs(R.pixelY)) M = -R.pixelX * b;
        else return !0;
      else if (Math.abs(R.pixelY) > Math.abs(R.pixelX)) M = -R.pixelY;
      else return !0;
    else
      M = Math.abs(R.pixelX) > Math.abs(R.pixelY) ? -R.pixelX * b : -R.pixelY;
    if (M === 0) return !0;
    w.invert && (M = -M);
    let D = e.getTranslate() + M * w.sensitivity;
    if (
      (D >= e.minTranslate() && (D = e.minTranslate()),
      D <= e.maxTranslate() && (D = e.maxTranslate()),
      (S = e.params.loop
        ? !0
        : !(D === e.minTranslate() || D === e.maxTranslate())),
      S && e.params.nested && x.stopPropagation(),
      !e.params.freeMode || !e.params.freeMode.enabled)
    ) {
      const P = {
        time: Hn(),
        delta: Math.abs(M),
        direction: Math.sign(M),
        raw: v,
      };
      c.length >= 2 && c.shift();
      const I = c.length ? c[c.length - 1] : void 0;
      if (
        (c.push(P),
        I
          ? (P.direction !== I.direction ||
              P.delta > I.delta ||
              P.time > I.time + 150) &&
            h(P)
          : h(P),
        _(P))
      )
        return !0;
    } else {
      const P = { time: Hn(), delta: Math.abs(M), direction: Math.sign(M) },
        I =
          l &&
          P.time < l.time + 500 &&
          P.delta <= l.delta &&
          P.direction === l.direction;
      if (!I) {
        l = void 0;
        let U = e.getTranslate() + M * w.sensitivity;
        const H = e.isBeginning,
          Y = e.isEnd;
        if (
          (U >= e.minTranslate() && (U = e.minTranslate()),
          U <= e.maxTranslate() && (U = e.maxTranslate()),
          e.setTransition(0),
          e.setTranslate(U),
          e.updateProgress(),
          e.updateActiveIndex(),
          e.updateSlidesClasses(),
          ((!H && e.isBeginning) || (!Y && e.isEnd)) && e.updateSlidesClasses(),
          e.params.loop &&
            e.loopFix({
              direction: P.direction < 0 ? "next" : "prev",
              byMousewheel: !0,
            }),
          e.params.freeMode.sticky)
        ) {
          clearTimeout(a), (a = void 0), c.length >= 15 && c.shift();
          const B = c.length ? c[c.length - 1] : void 0,
            Q = c[0];
          if (
            (c.push(P), B && (P.delta > B.delta || P.direction !== B.direction))
          )
            c.splice(0);
          else if (
            c.length >= 15 &&
            P.time - Q.time < 500 &&
            Q.delta - P.delta >= 1 &&
            P.delta <= 6
          ) {
            const Z = M > 0 ? 0.8 : 0.2;
            (l = P),
              c.splice(0),
              (a = Ps(() => {
                e.slideToClosest(e.params.speed, !0, void 0, Z);
              }, 0));
          }
          a ||
            (a = Ps(() => {
              (l = P),
                c.splice(0),
                e.slideToClosest(e.params.speed, !0, void 0, 0.5);
            }, 500));
        }
        if (
          (I || i("scroll", x),
          e.params.autoplay &&
            e.params.autoplayDisableOnInteraction &&
            e.autoplay.stop(),
          w.releaseOnEdges &&
            (U === e.minTranslate() || U === e.maxTranslate()))
        )
          return !0;
      }
    }
    return x.preventDefault ? x.preventDefault() : (x.returnValue = !1), !1;
  }
  function g(v) {
    let x = e.el;
    e.params.mousewheel.eventsTarget !== "container" &&
      (x = document.querySelector(e.params.mousewheel.eventsTarget)),
      x[v]("mouseenter", d),
      x[v]("mouseleave", f),
      x[v]("wheel", m);
  }
  function p() {
    return e.params.cssMode
      ? (e.wrapperEl.removeEventListener("wheel", m), !0)
      : e.mousewheel.enabled
      ? !1
      : (g("addEventListener"), (e.mousewheel.enabled = !0), !0);
  }
  function y() {
    return e.params.cssMode
      ? (e.wrapperEl.addEventListener(event, m), !0)
      : e.mousewheel.enabled
      ? (g("removeEventListener"), (e.mousewheel.enabled = !1), !0)
      : !1;
  }
  n("init", () => {
    !e.params.mousewheel.enabled && e.params.cssMode && y(),
      e.params.mousewheel.enabled && p();
  }),
    n("destroy", () => {
      e.params.cssMode && p(), e.mousewheel.enabled && y();
    }),
    Object.assign(e.mousewheel, { enable: p, disable: y });
}
function $g(s, e, t, n) {
  return (
    s.params.createElements &&
      Object.keys(n).forEach((i) => {
        if (!t[i] && t.auto === !0) {
          let r = En(s.el, `.${n[i]}`)[0];
          r || ((r = Da("div", n[i])), (r.className = n[i]), s.el.append(r)),
            (t[i] = r),
            (e[i] = r);
        }
      }),
    t
  );
}
function Kg(s) {
  let { swiper: e, extendParams: t, on: n, emit: i } = s;
  t({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: !1,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled",
    },
  }),
    (e.navigation = { nextEl: null, prevEl: null });
  const r = (m) => (Array.isArray(m) ? m : [m]).filter((g) => !!g);
  function a(m) {
    let g;
    return m &&
      typeof m == "string" &&
      e.isElement &&
      ((g = e.el.querySelector(m)), g)
      ? g
      : (m &&
          (typeof m == "string" && (g = [...document.querySelectorAll(m)]),
          e.params.uniqueNavElements &&
            typeof m == "string" &&
            g.length > 1 &&
            e.el.querySelectorAll(m).length === 1 &&
            (g = e.el.querySelector(m))),
        m && !g ? m : g);
  }
  function o(m, g) {
    const p = e.params.navigation;
    (m = r(m)),
      m.forEach((y) => {
        y &&
          (y.classList[g ? "add" : "remove"](...p.disabledClass.split(" ")),
          y.tagName === "BUTTON" && (y.disabled = g),
          e.params.watchOverflow &&
            e.enabled &&
            y.classList[e.isLocked ? "add" : "remove"](p.lockClass));
      });
  }
  function l() {
    const { nextEl: m, prevEl: g } = e.navigation;
    if (e.params.loop) {
      o(g, !1), o(m, !1);
      return;
    }
    o(g, e.isBeginning && !e.params.rewind), o(m, e.isEnd && !e.params.rewind);
  }
  function c(m) {
    m.preventDefault(),
      !(e.isBeginning && !e.params.loop && !e.params.rewind) &&
        (e.slidePrev(), i("navigationPrev"));
  }
  function u(m) {
    m.preventDefault(),
      !(e.isEnd && !e.params.loop && !e.params.rewind) &&
        (e.slideNext(), i("navigationNext"));
  }
  function d() {
    const m = e.params.navigation;
    if (
      ((e.params.navigation = $g(
        e,
        e.originalParams.navigation,
        e.params.navigation,
        { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }
      )),
      !(m.nextEl || m.prevEl))
    )
      return;
    let g = a(m.nextEl),
      p = a(m.prevEl);
    Object.assign(e.navigation, { nextEl: g, prevEl: p }),
      (g = r(g)),
      (p = r(p));
    const y = (v, x) => {
      v && v.addEventListener("click", x === "next" ? u : c),
        !e.enabled && v && v.classList.add(...m.lockClass.split(" "));
    };
    g.forEach((v) => y(v, "next")), p.forEach((v) => y(v, "prev"));
  }
  function f() {
    let { nextEl: m, prevEl: g } = e.navigation;
    (m = r(m)), (g = r(g));
    const p = (y, v) => {
      y.removeEventListener("click", v === "next" ? u : c),
        y.classList.remove(...e.params.navigation.disabledClass.split(" "));
    };
    m.forEach((y) => p(y, "next")), g.forEach((y) => p(y, "prev"));
  }
  n("init", () => {
    e.params.navigation.enabled === !1 ? _() : (d(), l());
  }),
    n("toEdge fromEdge lock unlock", () => {
      l();
    }),
    n("destroy", () => {
      f();
    }),
    n("enable disable", () => {
      let { nextEl: m, prevEl: g } = e.navigation;
      if (((m = r(m)), (g = r(g)), e.enabled)) {
        l();
        return;
      }
      [...m, ...g]
        .filter((p) => !!p)
        .forEach((p) => p.classList.add(e.params.navigation.lockClass));
    }),
    n("click", (m, g) => {
      let { nextEl: p, prevEl: y } = e.navigation;
      (p = r(p)), (y = r(y));
      const v = g.target;
      if (e.params.navigation.hideOnClick && !y.includes(v) && !p.includes(v)) {
        if (
          e.pagination &&
          e.params.pagination &&
          e.params.pagination.clickable &&
          (e.pagination.el === v || e.pagination.el.contains(v))
        )
          return;
        let x;
        p.length
          ? (x = p[0].classList.contains(e.params.navigation.hiddenClass))
          : y.length &&
            (x = y[0].classList.contains(e.params.navigation.hiddenClass)),
          i(x === !0 ? "navigationShow" : "navigationHide"),
          [...p, ...y]
            .filter((S) => !!S)
            .forEach((S) =>
              S.classList.toggle(e.params.navigation.hiddenClass)
            );
      }
    });
  const h = () => {
      e.el.classList.remove(
        ...e.params.navigation.navigationDisabledClass.split(" ")
      ),
        d(),
        l();
    },
    _ = () => {
      e.el.classList.add(
        ...e.params.navigation.navigationDisabledClass.split(" ")
      ),
        f();
    };
  Object.assign(e.navigation, {
    enable: h,
    disable: _,
    update: l,
    init: d,
    destroy: f,
  });
}
function Ws() {
  function s() {
    new on(".swiper", {
      modules: [Kg, jg, Yg],
      slidesPerView: 1.25,
      centeredSlides: !0,
      spaceBetween: 20,
      slideToClickedSlide: !0,
      mousewheel: { forceToAxis: !0 },
      keyboard: { enabled: !0, onlyInViewport: !1 },
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
      breakpoints: {
        480: { slidesPerView: 2, spaceBetween: 20 },
        768: { slidesPerView: 3, spaceBetween: 40 },
        992: { slidesPerView: 4, spaceBetween: 40 },
      },
    });
  }
  s();
  function e(t) {
    let n = Wn.timeline({ paused: !0 }),
      i = $('.team_card-bio-wrapper[data-team-member="' + t + '"]'),
      r = i.find(".team_card-bio-mask"),
      a = i.find(".bio_close"),
      o = $(".page-wrapper");
    n.set(i, { display: "flex" }),
      n.from(r, { xPercent: 100, duration: 0.8, ease: "power2.out" }),
      $('.team_card-wrapper[data-team-member="' + t + '"]')
        .find(".btn.cc--bio")
        .on("click", () => {
          o.css("z-index", 99), n.restart().play();
        }),
      a.on("click", () => {
        n.timeScale(1.5),
          n.reverse(),
          setTimeout(() => {
            o.css("z-index", 2);
          }, 1500);
      });
  }
  $(".team_card-wrapper").each(function () {
    const t = $(this).attr("data-team-member");
    e(t);
  });
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const jl = "151",
  Zg = 0,
  Nc = 1,
  Jg = 2,
  Xf = 1,
  jf = 2,
  hs = 3,
  Zn = 0,
  Gt = 1,
  wn = 2,
  xi = 0,
  Ir = 1,
  Uc = 2,
  Fc = 3,
  kc = 4,
  Qg = 5,
  Tr = 100,
  e_ = 101,
  t_ = 102,
  zc = 103,
  Bc = 104,
  n_ = 200,
  i_ = 201,
  r_ = 202,
  s_ = 203,
  Yf = 204,
  $f = 205,
  a_ = 206,
  o_ = 207,
  l_ = 208,
  c_ = 209,
  u_ = 210,
  d_ = 0,
  f_ = 1,
  h_ = 2,
  cl = 3,
  p_ = 4,
  m_ = 5,
  g_ = 6,
  __ = 7,
  Kf = 0,
  v_ = 1,
  x_ = 2,
  jn = 0,
  y_ = 1,
  Zf = 2,
  S_ = 3,
  M_ = 4,
  b_ = 5,
  Jf = 300,
  Gr = 301,
  Hr = 302,
  ul = 303,
  dl = 304,
  ka = 306,
  Wr = 1e3,
  ln = 1001,
  Ia = 1002,
  gt = 1003,
  fl = 1004,
  ya = 1005,
  Ft = 1006,
  Qf = 1007,
  Ki = 1008,
  Zi = 1009,
  w_ = 1010,
  T_ = 1011,
  eh = 1012,
  E_ = 1013,
  Gi = 1014,
  mi = 1015,
  Ls = 1016,
  A_ = 1017,
  C_ = 1018,
  Or = 1020,
  P_ = 1021,
  cn = 1023,
  L_ = 1024,
  R_ = 1025,
  ji = 1026,
  qr = 1027,
  D_ = 1028,
  I_ = 1029,
  O_ = 1030,
  N_ = 1031,
  U_ = 1033,
  fo = 33776,
  ho = 33777,
  po = 33778,
  mo = 33779,
  Vc = 35840,
  Gc = 35841,
  Hc = 35842,
  Wc = 35843,
  F_ = 36196,
  qc = 37492,
  Xc = 37496,
  jc = 37808,
  Yc = 37809,
  $c = 37810,
  Kc = 37811,
  Zc = 37812,
  Jc = 37813,
  Qc = 37814,
  eu = 37815,
  tu = 37816,
  nu = 37817,
  iu = 37818,
  ru = 37819,
  su = 37820,
  au = 37821,
  go = 36492,
  k_ = 36283,
  ou = 36284,
  lu = 36285,
  cu = 36286,
  Rs = 2300,
  Xr = 2301,
  _o = 2302,
  uu = 2400,
  du = 2401,
  fu = 2402,
  z_ = 2500,
  B_ = 0,
  th = 1,
  hl = 2,
  Ji = 3e3,
  ze = 3001,
  V_ = 3200,
  G_ = 3201,
  nh = 0,
  H_ = 1,
  Sn = "srgb",
  Ds = "srgb-linear",
  ih = "display-p3",
  vo = 7680,
  W_ = 519,
  pl = 35044,
  hu = "300 es",
  ml = 1035;
class Kr {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, a = i.length; r < a; r++) i[r].call(this, e);
      e.target = null;
    }
  }
}
const Mt = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let pu = 1234567;
const xs = Math.PI / 180,
  jr = 180 / Math.PI;
function vn() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Mt[s & 255] +
    Mt[(s >> 8) & 255] +
    Mt[(s >> 16) & 255] +
    Mt[(s >> 24) & 255] +
    "-" +
    Mt[e & 255] +
    Mt[(e >> 8) & 255] +
    "-" +
    Mt[((e >> 16) & 15) | 64] +
    Mt[(e >> 24) & 255] +
    "-" +
    Mt[(t & 63) | 128] +
    Mt[(t >> 8) & 255] +
    "-" +
    Mt[(t >> 16) & 255] +
    Mt[(t >> 24) & 255] +
    Mt[n & 255] +
    Mt[(n >> 8) & 255] +
    Mt[(n >> 16) & 255] +
    Mt[(n >> 24) & 255]
  ).toLowerCase();
}
function wt(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Yl(s, e) {
  return ((s % e) + e) % e;
}
function q_(s, e, t, n, i) {
  return n + ((s - e) * (i - n)) / (t - e);
}
function X_(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function ys(s, e, t) {
  return (1 - t) * s + t * e;
}
function j_(s, e, t, n) {
  return ys(s, e, 1 - Math.exp(-t * n));
}
function Y_(s, e = 1) {
  return e - Math.abs(Yl(s, e * 2) - e);
}
function $_(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * (3 - 2 * s));
}
function K_(s, e, t) {
  return s <= e
    ? 0
    : s >= t
    ? 1
    : ((s = (s - e) / (t - e)), s * s * s * (s * (s * 6 - 15) + 10));
}
function Z_(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function J_(s, e) {
  return s + Math.random() * (e - s);
}
function Q_(s) {
  return s * (0.5 - Math.random());
}
function e0(s) {
  s !== void 0 && (pu = s);
  let e = (pu += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function t0(s) {
  return s * xs;
}
function n0(s) {
  return s * jr;
}
function gl(s) {
  return (s & (s - 1)) === 0 && s !== 0;
}
function rh(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function sh(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function i0(s, e, t, n, i) {
  const r = Math.cos,
    a = Math.sin,
    o = r(t / 2),
    l = a(t / 2),
    c = r((e + n) / 2),
    u = a((e + n) / 2),
    d = r((e - n) / 2),
    f = a((e - n) / 2),
    h = r((n - e) / 2),
    _ = a((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(o * u, l * d, l * f, o * c);
      break;
    case "YZY":
      s.set(l * f, o * u, l * d, o * c);
      break;
    case "ZXZ":
      s.set(l * d, l * f, o * u, o * c);
      break;
    case "XZX":
      s.set(o * u, l * _, l * h, o * c);
      break;
    case "YXY":
      s.set(l * h, o * u, l * _, o * c);
      break;
    case "ZYZ":
      s.set(l * _, l * h, o * u, o * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function qn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Xe(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const r0 = {
  DEG2RAD: xs,
  RAD2DEG: jr,
  generateUUID: vn,
  clamp: wt,
  euclideanModulo: Yl,
  mapLinear: q_,
  inverseLerp: X_,
  lerp: ys,
  damp: j_,
  pingpong: Y_,
  smoothstep: $_,
  smootherstep: K_,
  randInt: Z_,
  randFloat: J_,
  randFloatSpread: Q_,
  seededRandom: e0,
  degToRad: t0,
  radToDeg: n0,
  isPowerOfTwo: gl,
  ceilPowerOfTwo: rh,
  floorPowerOfTwo: sh,
  setQuaternionFromProperEuler: i0,
  normalize: Xe,
  denormalize: qn,
};
class Ne {
  constructor(e = 0, t = 0) {
    (Ne.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(wt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = this.x - e.x,
      a = this.y - e.y;
    return (this.x = r * n - a * i + e.x), (this.y = r * i + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ie {
  constructor() {
    (Ie.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(e, t, n, i, r, a, o, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = i),
      (u[2] = o),
      (u[3] = t),
      (u[4] = r),
      (u[5] = l),
      (u[6] = n),
      (u[7] = a),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      a = n[0],
      o = n[3],
      l = n[6],
      c = n[1],
      u = n[4],
      d = n[7],
      f = n[2],
      h = n[5],
      _ = n[8],
      m = i[0],
      g = i[3],
      p = i[6],
      y = i[1],
      v = i[4],
      x = i[7],
      S = i[2],
      w = i[5],
      A = i[8];
    return (
      (r[0] = a * m + o * y + l * S),
      (r[3] = a * g + o * v + l * w),
      (r[6] = a * p + o * x + l * A),
      (r[1] = c * m + u * y + d * S),
      (r[4] = c * g + u * v + d * w),
      (r[7] = c * p + u * x + d * A),
      (r[2] = f * m + h * y + _ * S),
      (r[5] = f * g + h * v + _ * w),
      (r[8] = f * p + h * x + _ * A),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * a * u - t * o * c - n * r * u + n * o * l + i * r * c - i * a * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = u * a - o * c,
      f = o * l - u * r,
      h = c * r - a * l,
      _ = t * d + n * f + i * h;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / _;
    return (
      (e[0] = d * m),
      (e[1] = (i * c - u * n) * m),
      (e[2] = (o * n - i * a) * m),
      (e[3] = f * m),
      (e[4] = (u * t - i * l) * m),
      (e[5] = (i * r - o * t) * m),
      (e[6] = h * m),
      (e[7] = (n * l - c * t) * m),
      (e[8] = (a * t - n * r) * m),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, r, a, o) {
    const l = Math.cos(r),
      c = Math.sin(r);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * a + c * o) + a + e,
        -i * c,
        i * l,
        -i * (-c * a + l * o) + o + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(xo.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(xo.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(xo.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const xo = new Ie();
function ah(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return !0;
  return !1;
}
function Is(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function za(s) {
  return typeof structuredClone == "function"
    ? structuredClone(s)
    : JSON.parse(JSON.stringify(s));
}
function Nr(s) {
  return s < 0.04045
    ? s * 0.0773993808
    : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function yo(s) {
  return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
const s0 = new Ie().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  a0 = new Ie().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function o0(s) {
  return s.convertSRGBToLinear().applyMatrix3(a0);
}
function l0(s) {
  return s.applyMatrix3(s0).convertLinearToSRGB();
}
const c0 = { [Ds]: (s) => s, [Sn]: (s) => s.convertSRGBToLinear(), [ih]: o0 },
  u0 = { [Ds]: (s) => s, [Sn]: (s) => s.convertLinearToSRGB(), [ih]: l0 },
  qt = {
    enabled: !1,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(s) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !s);
    },
    get workingColorSpace() {
      return Ds;
    },
    set workingColorSpace(s) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (s, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return s;
      const n = c0[e],
        i = u0[t];
      if (n === void 0 || i === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return i(n(s));
    },
    fromWorkingColorSpace: function (s, e) {
      return this.convert(s, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (s, e) {
      return this.convert(s, e, this.workingColorSpace);
    },
  };
let sr;
class oh {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      sr === void 0 && (sr = Is("canvas")),
        (sr.width = e.width),
        (sr.height = e.height);
      const n = sr.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = sr);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement != "undefined" &&
        e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement != "undefined" &&
        e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
    ) {
      const t = Is("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        r = i.data;
      for (let a = 0; a < r.length; a++) r[a] = Nr(r[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Nr(t[n] / 255) * 255))
          : (t[n] = Nr(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class lh {
  constructor(e = null) {
    (this.isSource = !0),
      (this.uuid = vn()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let a = 0, o = i.length; a < o; a++)
          i[a].isDataTexture ? r.push(So(i[a].image)) : r.push(So(i[a]));
      } else r = So(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function So(s) {
  return (typeof HTMLImageElement != "undefined" &&
    s instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement != "undefined" &&
      s instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap != "undefined" && s instanceof ImageBitmap)
    ? oh.getDataURL(s)
    : s.data
    ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let d0 = 0;
class yt extends Kr {
  constructor(
    e = yt.DEFAULT_IMAGE,
    t = yt.DEFAULT_MAPPING,
    n = ln,
    i = ln,
    r = Ft,
    a = Ki,
    o = cn,
    l = Zi,
    c = yt.DEFAULT_ANISOTROPY,
    u = Ji
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: d0++ }),
      (this.uuid = vn()),
      (this.name = ""),
      (this.source = new lh(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = r),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new Ne(0, 0)),
      (this.repeat = new Ne(1, 1)),
      (this.center = new Ne(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Ie()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = za(e.userData)),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Jf) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Wr:
          e.x = e.x - Math.floor(e.x);
          break;
        case ln:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Ia:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Wr:
          e.y = e.y - Math.floor(e.y);
          break;
        case ln:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Ia:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
yt.DEFAULT_IMAGE = null;
yt.DEFAULT_MAPPING = Jf;
yt.DEFAULT_ANISOTROPY = 1;
class Ye {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (Ye.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r),
      (this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r),
      (this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r),
      (this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const l = e.elements,
      c = l[0],
      u = l[4],
      d = l[8],
      f = l[1],
      h = l[5],
      _ = l[9],
      m = l[2],
      g = l[6],
      p = l[10];
    if (
      Math.abs(u - f) < 0.01 &&
      Math.abs(d - m) < 0.01 &&
      Math.abs(_ - g) < 0.01
    ) {
      if (
        Math.abs(u + f) < 0.1 &&
        Math.abs(d + m) < 0.1 &&
        Math.abs(_ + g) < 0.1 &&
        Math.abs(c + h + p - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const v = (c + 1) / 2,
        x = (h + 1) / 2,
        S = (p + 1) / 2,
        w = (u + f) / 4,
        A = (d + m) / 4,
        C = (_ + g) / 4;
      return (
        v > x && v > S
          ? v < 0.01
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(v)), (i = w / n), (r = A / n))
          : x > S
          ? x < 0.01
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(x)), (n = w / i), (r = C / i))
          : S < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(S)), (n = A / r), (i = C / r)),
        this.set(n, i, r, t),
        this
      );
    }
    let y = Math.sqrt(
      (g - _) * (g - _) + (d - m) * (d - m) + (f - u) * (f - u)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (g - _) / y),
      (this.y = (d - m) / y),
      (this.z = (f - u) / y),
      (this.w = Math.acos((c + h + p - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Qi extends Kr {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Ye(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Ye(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    (this.texture = new yt(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Ft),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null),
      (this.samples = n.samples !== void 0 ? n.samples : 0);
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new lh(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ch extends yt {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = gt),
      (this.minFilter = gt),
      (this.wrapR = ln),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class f0 extends yt {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = gt),
      (this.minFilter = gt),
      (this.wrapR = ln),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class wi {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, r, a, o) {
    let l = n[i + 0],
      c = n[i + 1],
      u = n[i + 2],
      d = n[i + 3];
    const f = r[a + 0],
      h = r[a + 1],
      _ = r[a + 2],
      m = r[a + 3];
    if (o === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d);
      return;
    }
    if (o === 1) {
      (e[t + 0] = f), (e[t + 1] = h), (e[t + 2] = _), (e[t + 3] = m);
      return;
    }
    if (d !== m || l !== f || c !== h || u !== _) {
      let g = 1 - o;
      const p = l * f + c * h + u * _ + d * m,
        y = p >= 0 ? 1 : -1,
        v = 1 - p * p;
      if (v > Number.EPSILON) {
        const S = Math.sqrt(v),
          w = Math.atan2(S, p * y);
        (g = Math.sin(g * w) / S), (o = Math.sin(o * w) / S);
      }
      const x = o * y;
      if (
        ((l = l * g + f * x),
        (c = c * g + h * x),
        (u = u * g + _ * x),
        (d = d * g + m * x),
        g === 1 - o)
      ) {
        const S = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
        (l *= S), (c *= S), (u *= S), (d *= S);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, a) {
    const o = n[i],
      l = n[i + 1],
      c = n[i + 2],
      u = n[i + 3],
      d = r[a],
      f = r[a + 1],
      h = r[a + 2],
      _ = r[a + 3];
    return (
      (e[t] = o * _ + u * d + l * h - c * f),
      (e[t + 1] = l * _ + u * f + c * d - o * h),
      (e[t + 2] = c * _ + u * h + o * f - l * d),
      (e[t + 3] = u * _ - o * d - l * f - c * h),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const n = e._x,
      i = e._y,
      r = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(n / 2),
      u = o(i / 2),
      d = o(r / 2),
      f = l(n / 2),
      h = l(i / 2),
      _ = l(r / 2);
    switch (a) {
      case "XYZ":
        (this._x = f * u * d + c * h * _),
          (this._y = c * h * d - f * u * _),
          (this._z = c * u * _ + f * h * d),
          (this._w = c * u * d - f * h * _);
        break;
      case "YXZ":
        (this._x = f * u * d + c * h * _),
          (this._y = c * h * d - f * u * _),
          (this._z = c * u * _ - f * h * d),
          (this._w = c * u * d + f * h * _);
        break;
      case "ZXY":
        (this._x = f * u * d - c * h * _),
          (this._y = c * h * d + f * u * _),
          (this._z = c * u * _ + f * h * d),
          (this._w = c * u * d - f * h * _);
        break;
      case "ZYX":
        (this._x = f * u * d - c * h * _),
          (this._y = c * h * d + f * u * _),
          (this._z = c * u * _ - f * h * d),
          (this._w = c * u * d + f * h * _);
        break;
      case "YZX":
        (this._x = f * u * d + c * h * _),
          (this._y = c * h * d + f * u * _),
          (this._z = c * u * _ - f * h * d),
          (this._w = c * u * d - f * h * _);
        break;
      case "XZY":
        (this._x = f * u * d - c * h * _),
          (this._y = c * h * d - f * u * _),
          (this._z = c * u * _ + f * h * d),
          (this._w = c * u * d + f * h * _);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      r = t[8],
      a = t[1],
      o = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      d = t[10],
      f = n + o + d;
    if (f > 0) {
      const h = 0.5 / Math.sqrt(f + 1);
      (this._w = 0.25 / h),
        (this._x = (u - l) * h),
        (this._y = (r - c) * h),
        (this._z = (a - i) * h);
    } else if (n > o && n > d) {
      const h = 2 * Math.sqrt(1 + n - o - d);
      (this._w = (u - l) / h),
        (this._x = 0.25 * h),
        (this._y = (i + a) / h),
        (this._z = (r + c) / h);
    } else if (o > d) {
      const h = 2 * Math.sqrt(1 + o - n - d);
      (this._w = (r - c) / h),
        (this._x = (i + a) / h),
        (this._y = 0.25 * h),
        (this._z = (l + u) / h);
    } else {
      const h = 2 * Math.sqrt(1 + d - n - o);
      (this._w = (a - i) / h),
        (this._x = (r + c) / h),
        (this._y = (l + u) / h),
        (this._z = 0.25 * h);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(wt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      r = e._z,
      a = e._w,
      o = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = n * u + a * o + i * c - r * l),
      (this._y = i * u + a * l + r * o - n * c),
      (this._z = r * u + a * c + n * l - i * o),
      (this._w = a * u - n * o - i * l - r * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      r = this._z,
      a = this._w;
    let o = a * e._w + n * e._x + i * e._y + r * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = i), (this._z = r), this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const h = 1 - t;
      return (
        (this._w = h * a + t * this._w),
        (this._x = h * n + t * this._x),
        (this._y = h * i + t * this._y),
        (this._z = h * r + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, o),
      d = Math.sin((1 - t) * u) / c,
      f = Math.sin(t * u) / c;
    return (
      (this._w = a * d + this._w * f),
      (this._x = n * d + this._x * f),
      (this._y = i * d + this._y * f),
      (this._z = r * d + this._z * f),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class N {
  constructor(e = 0, t = 0, n = 0) {
    (N.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(mu.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(mu.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * n + r[6] * i),
      (this.y = r[1] * t + r[4] * n + r[7] * i),
      (this.z = r[2] * t + r[5] * n + r[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements,
      a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a),
      (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a),
      (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = l * t + a * i - o * n,
      u = l * n + o * t - r * i,
      d = l * i + r * n - a * t,
      f = -r * t - a * n - o * i;
    return (
      (this.x = c * l + f * -r + u * -o - d * -a),
      (this.y = u * l + f * -a + d * -r - c * -o),
      (this.z = d * l + f * -o + c * -a - u * -r),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[4] * n + r[8] * i),
      (this.y = r[1] * t + r[5] * n + r[9] * i),
      (this.z = r[2] * t + r[6] * n + r[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      r = e.z,
      a = t.x,
      o = t.y,
      l = t.z;
    return (
      (this.x = i * l - r * o),
      (this.y = r * a - n * l),
      (this.z = n * o - i * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Mo.copy(this).projectOnVector(e), this.sub(Mo);
  }
  reflect(e) {
    return this.sub(Mo.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(wt(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(t)), (this.y = n * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Mo = new N(),
  mu = new wi();
class Jn {
  constructor(
    e = new N(1 / 0, 1 / 0, 1 / 0),
    t = new N(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(On.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(On.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = On.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        ar.copy(e.boundingBox),
        ar.applyMatrix4(e.matrixWorld),
        this.union(ar);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const r = i.attributes.position;
          for (let a = 0, o = r.count; a < o; a++)
            On.fromBufferAttribute(r, a).applyMatrix4(e.matrixWorld),
              this.expandByPoint(On);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            ar.copy(i.boundingBox),
            ar.applyMatrix4(e.matrixWorld),
            this.union(ar);
    }
    const n = e.children;
    for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, On),
      On.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(ns),
      qs.subVectors(this.max, ns),
      or.subVectors(e.a, ns),
      lr.subVectors(e.b, ns),
      cr.subVectors(e.c, ns),
      ti.subVectors(lr, or),
      ni.subVectors(cr, lr),
      Li.subVectors(or, cr);
    let t = [
      0,
      -ti.z,
      ti.y,
      0,
      -ni.z,
      ni.y,
      0,
      -Li.z,
      Li.y,
      ti.z,
      0,
      -ti.x,
      ni.z,
      0,
      -ni.x,
      Li.z,
      0,
      -Li.x,
      -ti.y,
      ti.x,
      0,
      -ni.y,
      ni.x,
      0,
      -Li.y,
      Li.x,
      0,
    ];
    return !bo(t, or, lr, cr, qs) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !bo(t, or, lr, cr, qs))
      ? !1
      : (Xs.crossVectors(ti, ni),
        (t = [Xs.x, Xs.y, Xs.z]),
        bo(t, or, lr, cr, qs));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, On).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(On).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (In[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        In[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        In[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        In[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        In[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        In[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        In[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        In[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(In),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const In = [
    new N(),
    new N(),
    new N(),
    new N(),
    new N(),
    new N(),
    new N(),
    new N(),
  ],
  On = new N(),
  ar = new Jn(),
  or = new N(),
  lr = new N(),
  cr = new N(),
  ti = new N(),
  ni = new N(),
  Li = new N(),
  ns = new N(),
  qs = new N(),
  Xs = new N(),
  Ri = new N();
function bo(s, e, t, n, i) {
  for (let r = 0, a = s.length - 3; r <= a; r += 3) {
    Ri.fromArray(s, r);
    const o =
        i.x * Math.abs(Ri.x) + i.y * Math.abs(Ri.y) + i.z * Math.abs(Ri.z),
      l = e.dot(Ri),
      c = t.dot(Ri),
      u = n.dot(Ri);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
  }
  return !0;
}
const h0 = new Jn(),
  is = new N(),
  wo = new N();
class Qn {
  constructor(e = new N(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : h0.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, a = e.length; r < a; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    is.subVectors(e, this.center);
    const t = is.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(is, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (wo.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(is.copy(e.center).add(wo)),
            this.expandByPoint(is.copy(e.center).sub(wo))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Nn = new N(),
  To = new N(),
  js = new N(),
  ii = new N(),
  Eo = new N(),
  Ys = new N(),
  Ao = new N();
class Ba {
  constructor(e = new N(), t = new N(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Nn)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Nn.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Nn.copy(this.origin).addScaledVector(this.direction, t),
        Nn.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    To.copy(e).add(t).multiplyScalar(0.5),
      js.copy(t).sub(e).normalize(),
      ii.copy(this.origin).sub(To);
    const r = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(js),
      o = ii.dot(this.direction),
      l = -ii.dot(js),
      c = ii.lengthSq(),
      u = Math.abs(1 - a * a);
    let d, f, h, _;
    if (u > 0)
      if (((d = a * l - o), (f = a * o - l), (_ = r * u), d >= 0))
        if (f >= -_)
          if (f <= _) {
            const m = 1 / u;
            (d *= m),
              (f *= m),
              (h = d * (d + a * f + 2 * o) + f * (a * d + f + 2 * l) + c);
          } else
            (f = r),
              (d = Math.max(0, -(a * f + o))),
              (h = -d * d + f * (f + 2 * l) + c);
        else
          (f = -r),
            (d = Math.max(0, -(a * f + o))),
            (h = -d * d + f * (f + 2 * l) + c);
      else
        f <= -_
          ? ((d = Math.max(0, -(-a * r + o))),
            (f = d > 0 ? -r : Math.min(Math.max(-r, -l), r)),
            (h = -d * d + f * (f + 2 * l) + c))
          : f <= _
          ? ((d = 0),
            (f = Math.min(Math.max(-r, -l), r)),
            (h = f * (f + 2 * l) + c))
          : ((d = Math.max(0, -(a * r + o))),
            (f = d > 0 ? r : Math.min(Math.max(-r, -l), r)),
            (h = -d * d + f * (f + 2 * l) + c));
    else
      (f = a > 0 ? -r : r),
        (d = Math.max(0, -(a * f + o))),
        (h = -d * d + f * (f + 2 * l) + c);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, d),
      i && i.copy(To).addScaledVector(js, f),
      h
    );
  }
  intersectSphere(e, t) {
    Nn.subVectors(e.center, this.origin);
    const n = Nn.dot(this.direction),
      i = Nn.dot(Nn) - n * n,
      r = e.radius * e.radius;
    if (i > r) return null;
    const a = Math.sqrt(r - i),
      o = n - a,
      l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, a, o, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      d = 1 / this.direction.z,
      f = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - f.x) * c), (i = (e.max.x - f.x) * c))
        : ((n = (e.max.x - f.x) * c), (i = (e.min.x - f.x) * c)),
      u >= 0
        ? ((r = (e.min.y - f.y) * u), (a = (e.max.y - f.y) * u))
        : ((r = (e.max.y - f.y) * u), (a = (e.min.y - f.y) * u)),
      n > a ||
      r > i ||
      ((r > n || isNaN(n)) && (n = r),
      (a < i || isNaN(i)) && (i = a),
      d >= 0
        ? ((o = (e.min.z - f.z) * d), (l = (e.max.z - f.z) * d))
        : ((o = (e.max.z - f.z) * d), (l = (e.min.z - f.z) * d)),
      n > l || o > i) ||
      ((o > n || n !== n) && (n = o), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Nn) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    Eo.subVectors(t, e), Ys.subVectors(n, e), Ao.crossVectors(Eo, Ys);
    let a = this.direction.dot(Ao),
      o;
    if (a > 0) {
      if (i) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    ii.subVectors(this.origin, e);
    const l = o * this.direction.dot(Ys.crossVectors(ii, Ys));
    if (l < 0) return null;
    const c = o * this.direction.dot(Eo.cross(ii));
    if (c < 0 || l + c > a) return null;
    const u = -o * ii.dot(Ao);
    return u < 0 ? null : this.at(u / a, r);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Le {
  constructor() {
    (Le.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  set(e, t, n, i, r, a, o, l, c, u, d, f, h, _, m, g) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[4] = t),
      (p[8] = n),
      (p[12] = i),
      (p[1] = r),
      (p[5] = a),
      (p[9] = o),
      (p[13] = l),
      (p[2] = c),
      (p[6] = u),
      (p[10] = d),
      (p[14] = f),
      (p[3] = h),
      (p[7] = _),
      (p[11] = m),
      (p[15] = g),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Le().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / ur.setFromMatrixColumn(e, 0).length(),
      r = 1 / ur.setFromMatrixColumn(e, 1).length(),
      a = 1 / ur.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * r),
      (t[5] = n[5] * r),
      (t[6] = n[6] * r),
      (t[7] = 0),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z,
      a = Math.cos(n),
      o = Math.sin(n),
      l = Math.cos(i),
      c = Math.sin(i),
      u = Math.cos(r),
      d = Math.sin(r);
    if (e.order === "XYZ") {
      const f = a * u,
        h = a * d,
        _ = o * u,
        m = o * d;
      (t[0] = l * u),
        (t[4] = -l * d),
        (t[8] = c),
        (t[1] = h + _ * c),
        (t[5] = f - m * c),
        (t[9] = -o * l),
        (t[2] = m - f * c),
        (t[6] = _ + h * c),
        (t[10] = a * l);
    } else if (e.order === "YXZ") {
      const f = l * u,
        h = l * d,
        _ = c * u,
        m = c * d;
      (t[0] = f + m * o),
        (t[4] = _ * o - h),
        (t[8] = a * c),
        (t[1] = a * d),
        (t[5] = a * u),
        (t[9] = -o),
        (t[2] = h * o - _),
        (t[6] = m + f * o),
        (t[10] = a * l);
    } else if (e.order === "ZXY") {
      const f = l * u,
        h = l * d,
        _ = c * u,
        m = c * d;
      (t[0] = f - m * o),
        (t[4] = -a * d),
        (t[8] = _ + h * o),
        (t[1] = h + _ * o),
        (t[5] = a * u),
        (t[9] = m - f * o),
        (t[2] = -a * c),
        (t[6] = o),
        (t[10] = a * l);
    } else if (e.order === "ZYX") {
      const f = a * u,
        h = a * d,
        _ = o * u,
        m = o * d;
      (t[0] = l * u),
        (t[4] = _ * c - h),
        (t[8] = f * c + m),
        (t[1] = l * d),
        (t[5] = m * c + f),
        (t[9] = h * c - _),
        (t[2] = -c),
        (t[6] = o * l),
        (t[10] = a * l);
    } else if (e.order === "YZX") {
      const f = a * l,
        h = a * c,
        _ = o * l,
        m = o * c;
      (t[0] = l * u),
        (t[4] = m - f * d),
        (t[8] = _ * d + h),
        (t[1] = d),
        (t[5] = a * u),
        (t[9] = -o * u),
        (t[2] = -c * u),
        (t[6] = h * d + _),
        (t[10] = f - m * d);
    } else if (e.order === "XZY") {
      const f = a * l,
        h = a * c,
        _ = o * l,
        m = o * c;
      (t[0] = l * u),
        (t[4] = -d),
        (t[8] = c * u),
        (t[1] = f * d + m),
        (t[5] = a * u),
        (t[9] = h * d - _),
        (t[2] = _ * d - h),
        (t[6] = o * u),
        (t[10] = m * d + f);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(p0, e, m0);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      Xt.subVectors(e, t),
      Xt.lengthSq() === 0 && (Xt.z = 1),
      Xt.normalize(),
      ri.crossVectors(n, Xt),
      ri.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (Xt.x += 1e-4) : (Xt.z += 1e-4),
        Xt.normalize(),
        ri.crossVectors(n, Xt)),
      ri.normalize(),
      $s.crossVectors(Xt, ri),
      (i[0] = ri.x),
      (i[4] = $s.x),
      (i[8] = Xt.x),
      (i[1] = ri.y),
      (i[5] = $s.y),
      (i[9] = Xt.y),
      (i[2] = ri.z),
      (i[6] = $s.z),
      (i[10] = Xt.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      r = this.elements,
      a = n[0],
      o = n[4],
      l = n[8],
      c = n[12],
      u = n[1],
      d = n[5],
      f = n[9],
      h = n[13],
      _ = n[2],
      m = n[6],
      g = n[10],
      p = n[14],
      y = n[3],
      v = n[7],
      x = n[11],
      S = n[15],
      w = i[0],
      A = i[4],
      C = i[8],
      M = i[12],
      b = i[1],
      R = i[5],
      D = i[9],
      P = i[13],
      I = i[2],
      U = i[6],
      H = i[10],
      Y = i[14],
      B = i[3],
      Q = i[7],
      Z = i[11],
      me = i[15];
    return (
      (r[0] = a * w + o * b + l * I + c * B),
      (r[4] = a * A + o * R + l * U + c * Q),
      (r[8] = a * C + o * D + l * H + c * Z),
      (r[12] = a * M + o * P + l * Y + c * me),
      (r[1] = u * w + d * b + f * I + h * B),
      (r[5] = u * A + d * R + f * U + h * Q),
      (r[9] = u * C + d * D + f * H + h * Z),
      (r[13] = u * M + d * P + f * Y + h * me),
      (r[2] = _ * w + m * b + g * I + p * B),
      (r[6] = _ * A + m * R + g * U + p * Q),
      (r[10] = _ * C + m * D + g * H + p * Z),
      (r[14] = _ * M + m * P + g * Y + p * me),
      (r[3] = y * w + v * b + x * I + S * B),
      (r[7] = y * A + v * R + x * U + S * Q),
      (r[11] = y * C + v * D + x * H + S * Z),
      (r[15] = y * M + v * P + x * Y + S * me),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      r = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      d = e[6],
      f = e[10],
      h = e[14],
      _ = e[3],
      m = e[7],
      g = e[11],
      p = e[15];
    return (
      _ *
        (+r * l * d -
          i * c * d -
          r * o * f +
          n * c * f +
          i * o * h -
          n * l * h) +
      m *
        (+t * l * h -
          t * c * f +
          r * a * f -
          i * a * h +
          i * c * u -
          r * l * u) +
      g *
        (+t * c * d -
          t * o * h -
          r * a * d +
          n * a * h +
          r * o * u -
          n * c * u) +
      p *
        (-i * o * u - t * l * d + t * o * f + i * a * d - n * a * f + n * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      r = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = e[9],
      f = e[10],
      h = e[11],
      _ = e[12],
      m = e[13],
      g = e[14],
      p = e[15],
      y = d * g * c - m * f * c + m * l * h - o * g * h - d * l * p + o * f * p,
      v = _ * f * c - u * g * c - _ * l * h + a * g * h + u * l * p - a * f * p,
      x = u * m * c - _ * d * c + _ * o * h - a * m * h - u * o * p + a * d * p,
      S = _ * d * l - u * m * l - _ * o * f + a * m * f + u * o * g - a * d * g,
      w = t * y + n * v + i * x + r * S;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / w;
    return (
      (e[0] = y * A),
      (e[1] =
        (m * f * r -
          d * g * r -
          m * i * h +
          n * g * h +
          d * i * p -
          n * f * p) *
        A),
      (e[2] =
        (o * g * r -
          m * l * r +
          m * i * c -
          n * g * c -
          o * i * p +
          n * l * p) *
        A),
      (e[3] =
        (d * l * r -
          o * f * r -
          d * i * c +
          n * f * c +
          o * i * h -
          n * l * h) *
        A),
      (e[4] = v * A),
      (e[5] =
        (u * g * r -
          _ * f * r +
          _ * i * h -
          t * g * h -
          u * i * p +
          t * f * p) *
        A),
      (e[6] =
        (_ * l * r -
          a * g * r -
          _ * i * c +
          t * g * c +
          a * i * p -
          t * l * p) *
        A),
      (e[7] =
        (a * f * r -
          u * l * r +
          u * i * c -
          t * f * c -
          a * i * h +
          t * l * h) *
        A),
      (e[8] = x * A),
      (e[9] =
        (_ * d * r -
          u * m * r -
          _ * n * h +
          t * m * h +
          u * n * p -
          t * d * p) *
        A),
      (e[10] =
        (a * m * r -
          _ * o * r +
          _ * n * c -
          t * m * c -
          a * n * p +
          t * o * p) *
        A),
      (e[11] =
        (u * o * r -
          a * d * r -
          u * n * c +
          t * d * c +
          a * n * h -
          t * o * h) *
        A),
      (e[12] = S * A),
      (e[13] =
        (u * m * i -
          _ * d * i +
          _ * n * f -
          t * m * f -
          u * n * g +
          t * d * g) *
        A),
      (e[14] =
        (_ * o * i -
          a * m * i -
          _ * n * l +
          t * m * l +
          a * n * g -
          t * o * g) *
        A),
      (e[15] =
        (a * d * i -
          u * o * i +
          u * n * l -
          t * d * l -
          a * n * f +
          t * o * f) *
        A),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      r = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= r),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= r),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= r),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      r = 1 - n,
      a = e.x,
      o = e.y,
      l = e.z,
      c = r * a,
      u = r * o;
    return (
      this.set(
        c * a + n,
        c * o - i * l,
        c * l + i * o,
        0,
        c * o + i * l,
        u * o + n,
        u * l - i * a,
        0,
        c * l - i * o,
        u * l + i * a,
        r * l * l + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, r, a) {
    return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      r = t._x,
      a = t._y,
      o = t._z,
      l = t._w,
      c = r + r,
      u = a + a,
      d = o + o,
      f = r * c,
      h = r * u,
      _ = r * d,
      m = a * u,
      g = a * d,
      p = o * d,
      y = l * c,
      v = l * u,
      x = l * d,
      S = n.x,
      w = n.y,
      A = n.z;
    return (
      (i[0] = (1 - (m + p)) * S),
      (i[1] = (h + x) * S),
      (i[2] = (_ - v) * S),
      (i[3] = 0),
      (i[4] = (h - x) * w),
      (i[5] = (1 - (f + p)) * w),
      (i[6] = (g + y) * w),
      (i[7] = 0),
      (i[8] = (_ + v) * A),
      (i[9] = (g - y) * A),
      (i[10] = (1 - (f + m)) * A),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = ur.set(i[0], i[1], i[2]).length();
    const a = ur.set(i[4], i[5], i[6]).length(),
      o = ur.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      pn.copy(this);
    const c = 1 / r,
      u = 1 / a,
      d = 1 / o;
    return (
      (pn.elements[0] *= c),
      (pn.elements[1] *= c),
      (pn.elements[2] *= c),
      (pn.elements[4] *= u),
      (pn.elements[5] *= u),
      (pn.elements[6] *= u),
      (pn.elements[8] *= d),
      (pn.elements[9] *= d),
      (pn.elements[10] *= d),
      t.setFromRotationMatrix(pn),
      (n.x = r),
      (n.y = a),
      (n.z = o),
      this
    );
  }
  makePerspective(e, t, n, i, r, a) {
    const o = this.elements,
      l = (2 * r) / (t - e),
      c = (2 * r) / (n - i),
      u = (t + e) / (t - e),
      d = (n + i) / (n - i),
      f = -(a + r) / (a - r),
      h = (-2 * a * r) / (a - r);
    return (
      (o[0] = l),
      (o[4] = 0),
      (o[8] = u),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = c),
      (o[9] = d),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = f),
      (o[14] = h),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, r, a) {
    const o = this.elements,
      l = 1 / (t - e),
      c = 1 / (n - i),
      u = 1 / (a - r),
      d = (t + e) * l,
      f = (n + i) * c,
      h = (a + r) * u;
    return (
      (o[0] = 2 * l),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -d),
      (o[1] = 0),
      (o[5] = 2 * c),
      (o[9] = 0),
      (o[13] = -f),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = -2 * u),
      (o[14] = -h),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const ur = new N(),
  pn = new Le(),
  p0 = new N(0, 0, 0),
  m0 = new N(1, 1, 1),
  ri = new N(),
  $s = new N(),
  Xt = new N(),
  gu = new Le(),
  _u = new wi();
class Va {
  constructor(e = 0, t = 0, n = 0, i = Va.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      r = i[0],
      a = i[4],
      o = i[8],
      l = i[1],
      c = i[5],
      u = i[9],
      d = i[2],
      f = i[6],
      h = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(wt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-u, h)), (this._z = Math.atan2(-a, r)))
            : ((this._x = Math.atan2(f, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-wt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(o, h)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(wt(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(-d, h)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-wt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(f, h)), (this._z = Math.atan2(l, r)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin(wt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-d, r)))
            : ((this._x = 0), (this._y = Math.atan2(o, h)));
        break;
      case "XZY":
        (this._z = Math.asin(-wt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(f, c)), (this._y = Math.atan2(o, r)))
            : ((this._x = Math.atan2(-u, h)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      gu.makeRotationFromQuaternion(e), this.setFromRotationMatrix(gu, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return _u.setFromEuler(this), this.setFromQuaternion(_u, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Va.DEFAULT_ORDER = "XYZ";
class $l {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let g0 = 0;
const vu = new N(),
  dr = new wi(),
  Un = new Le(),
  Ks = new N(),
  rs = new N(),
  _0 = new N(),
  v0 = new wi(),
  xu = new N(1, 0, 0),
  yu = new N(0, 1, 0),
  Su = new N(0, 0, 1),
  x0 = { type: "added" },
  Mu = { type: "removed" };
class Qe extends Kr {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: g0++ }),
      (this.uuid = vn()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Qe.DEFAULT_UP.clone());
    const e = new N(),
      t = new Va(),
      n = new wi(),
      i = new N(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Le() },
        normalMatrix: { value: new Ie() },
      }),
      (this.matrix = new Le()),
      (this.matrixWorld = new Le()),
      (this.matrixAutoUpdate = Qe.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Qe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new $l()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return dr.setFromAxisAngle(e, t), this.quaternion.multiply(dr), this;
  }
  rotateOnWorldAxis(e, t) {
    return dr.setFromAxisAngle(e, t), this.quaternion.premultiply(dr), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(xu, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(yu, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Su, e);
  }
  translateOnAxis(e, t) {
    return (
      vu.copy(e).applyQuaternion(this.quaternion),
      this.position.add(vu.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(xu, e);
  }
  translateY(e) {
    return this.translateOnAxis(yu, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Su, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Un.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? Ks.copy(e) : Ks.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      rs.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Un.lookAt(rs, Ks, this.up)
        : Un.lookAt(Ks, rs, this.up),
      this.quaternion.setFromRotationMatrix(Un),
      i &&
        (Un.extractRotation(i.matrixWorld),
        dr.setFromRotationMatrix(Un),
        this.quaternion.premultiply(dr.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(x0))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Mu)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(Mu);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Un.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Un.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Un),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t) {
    let n = [];
    this[e] === t && n.push(this);
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectsByProperty(e, t);
      a.length > 0 && (n = n.concat(a));
    }
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rs, e, _0), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(rs, v0, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 &&
        n !== null &&
        n.matrixWorldAutoUpdate === !0 &&
        n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let r = 0, a = i.length; r < a; r++) {
        const o = i[r];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function r(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c];
            r(e.shapes, d);
          }
        else r(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (r(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(r(e.materials, this.material[l]));
        i.material = o;
      } else i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        i.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        u = a(e.images),
        d = a(e.shapes),
        f = a(e.skeletons),
        h = a(e.animations),
        _ = a(e.nodes);
      o.length > 0 && (n.geometries = o),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        u.length > 0 && (n.images = u),
        d.length > 0 && (n.shapes = d),
        f.length > 0 && (n.skeletons = f),
        h.length > 0 && (n.animations = h),
        _.length > 0 && (n.nodes = _);
    }
    return (n.object = i), n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = za(e.userData)),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Qe.DEFAULT_UP = new N(0, 1, 0);
Qe.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Qe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const mn = new N(),
  Fn = new N(),
  Co = new N(),
  kn = new N(),
  fr = new N(),
  hr = new N(),
  bu = new N(),
  Po = new N(),
  Lo = new N(),
  Ro = new N();
let Zs = !1;
class _n {
  constructor(e = new N(), t = new N(), n = new N()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), mn.subVectors(e, t), i.cross(mn);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, r) {
    mn.subVectors(i, t), Fn.subVectors(n, t), Co.subVectors(e, t);
    const a = mn.dot(mn),
      o = mn.dot(Fn),
      l = mn.dot(Co),
      c = Fn.dot(Fn),
      u = Fn.dot(Co),
      d = a * c - o * o;
    if (d === 0) return r.set(-2, -1, -1);
    const f = 1 / d,
      h = (c * l - o * u) * f,
      _ = (a * u - o * l) * f;
    return r.set(1 - h - _, _, h);
  }
  static containsPoint(e, t, n, i) {
    return (
      this.getBarycoord(e, t, n, i, kn),
      kn.x >= 0 && kn.y >= 0 && kn.x + kn.y <= 1
    );
  }
  static getUV(e, t, n, i, r, a, o, l) {
    return (
      Zs === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Zs = !0)),
      this.getInterpolation(e, t, n, i, r, a, o, l)
    );
  }
  static getInterpolation(e, t, n, i, r, a, o, l) {
    return (
      this.getBarycoord(e, t, n, i, kn),
      l.setScalar(0),
      l.addScaledVector(r, kn.x),
      l.addScaledVector(a, kn.y),
      l.addScaledVector(o, kn.z),
      l
    );
  }
  static isFrontFacing(e, t, n, i) {
    return mn.subVectors(n, t), Fn.subVectors(e, t), mn.cross(Fn).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      mn.subVectors(this.c, this.b),
      Fn.subVectors(this.a, this.b),
      mn.cross(Fn).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return _n.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return _n.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, r) {
    return (
      Zs === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Zs = !0)),
      _n.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
    );
  }
  getInterpolation(e, t, n, i, r) {
    return _n.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return _n.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return _n.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      r = this.c;
    let a, o;
    fr.subVectors(i, n), hr.subVectors(r, n), Po.subVectors(e, n);
    const l = fr.dot(Po),
      c = hr.dot(Po);
    if (l <= 0 && c <= 0) return t.copy(n);
    Lo.subVectors(e, i);
    const u = fr.dot(Lo),
      d = hr.dot(Lo);
    if (u >= 0 && d <= u) return t.copy(i);
    const f = l * d - u * c;
    if (f <= 0 && l >= 0 && u <= 0)
      return (a = l / (l - u)), t.copy(n).addScaledVector(fr, a);
    Ro.subVectors(e, r);
    const h = fr.dot(Ro),
      _ = hr.dot(Ro);
    if (_ >= 0 && h <= _) return t.copy(r);
    const m = h * c - l * _;
    if (m <= 0 && c >= 0 && _ <= 0)
      return (o = c / (c - _)), t.copy(n).addScaledVector(hr, o);
    const g = u * _ - h * d;
    if (g <= 0 && d - u >= 0 && h - _ >= 0)
      return (
        bu.subVectors(r, i),
        (o = (d - u) / (d - u + (h - _))),
        t.copy(i).addScaledVector(bu, o)
      );
    const p = 1 / (g + m + f);
    return (
      (a = m * p),
      (o = f * p),
      t.copy(n).addScaledVector(fr, a).addScaledVector(hr, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let y0 = 0;
class Pn extends Kr {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: y0++ }),
      (this.uuid = vn()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Ir),
      (this.side = Zn),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = Yf),
      (this.blendDst = $f),
      (this.blendEquation = Tr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = cl),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = W_),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = vo),
      (this.stencilZFail = vo),
      (this.stencilZPass = vo),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ir && (n.blending = this.blending),
      this.side !== Zn && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(r) {
      const a = [];
      for (const o in r) {
        const l = r[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const r = i(e.textures),
        a = i(e.images);
      r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = za(e.userData)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const uh = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  gn = { h: 0, s: 0, l: 0 },
  Js = { h: 0, s: 0, l: 0 };
function Do(s, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? s + (e - s) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? s + (e - s) * 6 * (2 / 3 - t)
      : s
  );
}
class Te {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Sn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      qt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = qt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      qt.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = qt.workingColorSpace) {
    if (((e = Yl(e, 1)), (t = wt(t, 0, 1)), (n = wt(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - r;
      (this.r = Do(a, r, e + 1 / 3)),
        (this.g = Do(a, r, e)),
        (this.b = Do(a, r, e - 1 / 3));
    }
    return qt.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Sn) {
    function n(r) {
      r !== void 0 &&
        parseFloat(r) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let r;
      const a = i[1],
        o = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (r =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
              qt.toWorkingColorSpace(this, t),
              n(r[4]),
              this
            );
          if (
            (r =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
              qt.toWorkingColorSpace(this, t),
              n(r[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (r =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          ) {
            const l = parseFloat(r[1]) / 360,
              c = parseFloat(r[2]) / 100,
              u = parseFloat(r[3]) / 100;
            return n(r[4]), this.setHSL(l, c, u, t);
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const r = i[1],
        a = r.length;
      if (a === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (a === 6) return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Sn) {
    const n = uh[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Nr(e.r)), (this.g = Nr(e.g)), (this.b = Nr(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = yo(e.r)), (this.g = yo(e.g)), (this.b = yo(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Sn) {
    return (
      qt.fromWorkingColorSpace(bt.copy(this), e),
      (wt(bt.r * 255, 0, 255) << 16) ^
        (wt(bt.g * 255, 0, 255) << 8) ^
        (wt(bt.b * 255, 0, 255) << 0)
    );
  }
  getHexString(e = Sn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = qt.workingColorSpace) {
    qt.fromWorkingColorSpace(bt.copy(this), t);
    const n = bt.r,
      i = bt.g,
      r = bt.b,
      a = Math.max(n, i, r),
      o = Math.min(n, i, r);
    let l, c;
    const u = (o + a) / 2;
    if (o === a) (l = 0), (c = 0);
    else {
      const d = a - o;
      switch (((c = u <= 0.5 ? d / (a + o) : d / (2 - a - o)), a)) {
        case n:
          l = (i - r) / d + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - n) / d + 2;
          break;
        case r:
          l = (n - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, t = qt.workingColorSpace) {
    return (
      qt.fromWorkingColorSpace(bt.copy(this), t),
      (e.r = bt.r),
      (e.g = bt.g),
      (e.b = bt.b),
      e
    );
  }
  getStyle(e = Sn) {
    qt.fromWorkingColorSpace(bt.copy(this), e);
    const t = bt.r,
      n = bt.g,
      i = bt.b;
    return e !== Sn
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${(t * 255) | 0},${(n * 255) | 0},${(i * 255) | 0})`;
  }
  offsetHSL(e, t, n) {
    return (
      this.getHSL(gn),
      (gn.h += e),
      (gn.s += t),
      (gn.l += n),
      this.setHSL(gn.h, gn.s, gn.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(gn), e.getHSL(Js);
    const n = ys(gn.h, Js.h, t),
      i = ys(gn.s, Js.s, t),
      r = ys(gn.l, Js.l, t);
    return this.setHSL(n, i, r), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      r = e.elements;
    return (
      (this.r = r[0] * t + r[3] * n + r[6] * i),
      (this.g = r[1] * t + r[4] * n + r[7] * i),
      (this.b = r[2] * t + r[5] * n + r[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const bt = new Te();
Te.NAMES = uh;
class gi extends Pn {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Te(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Kf),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const ot = new N(),
  Qs = new Ne();
class Nt {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = pl),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Qs.fromBufferAttribute(this, t),
          Qs.applyMatrix3(e),
          this.setXY(t, Qs.x, Qs.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        ot.fromBufferAttribute(this, t),
          ot.applyMatrix3(e),
          this.setXYZ(t, ot.x, ot.y, ot.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ot.fromBufferAttribute(this, t),
        ot.applyMatrix4(e),
        this.setXYZ(t, ot.x, ot.y, ot.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ot.fromBufferAttribute(this, t),
        ot.applyNormalMatrix(e),
        this.setXYZ(t, ot.x, ot.y, ot.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ot.fromBufferAttribute(this, t),
        ot.transformDirection(e),
        this.setXYZ(t, ot.x, ot.y, ot.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Xe(t, this.array)), (n = Xe(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array)),
        (r = Xe(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = r),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== pl && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class dh extends Nt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class fh extends Nt {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class Yn extends Nt {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let S0 = 0;
const nn = new Le(),
  Io = new Qe(),
  pr = new N(),
  jt = new Jn(),
  ss = new Jn(),
  mt = new N();
class Rn extends Kr {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: S0++ }),
      (this.uuid = vn()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (ah(e) ? fh : dh)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Ie().getNormalMatrix(e);
      n.applyNormalMatrix(r), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return nn.makeRotationFromQuaternion(e), this.applyMatrix4(nn), this;
  }
  rotateX(e) {
    return nn.makeRotationX(e), this.applyMatrix4(nn), this;
  }
  rotateY(e) {
    return nn.makeRotationY(e), this.applyMatrix4(nn), this;
  }
  rotateZ(e) {
    return nn.makeRotationZ(e), this.applyMatrix4(nn), this;
  }
  translate(e, t, n) {
    return nn.makeTranslation(e, t, n), this.applyMatrix4(nn), this;
  }
  scale(e, t, n) {
    return nn.makeScale(e, t, n), this.applyMatrix4(nn), this;
  }
  lookAt(e) {
    return Io.lookAt(e), Io.updateMatrix(), this.applyMatrix4(Io.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(pr).negate(),
      this.translate(pr.x, pr.y, pr.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new Yn(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Jn());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new N(-1 / 0, -1 / 0, -1 / 0),
          new N(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          jt.setFromBufferAttribute(r),
            this.morphTargetsRelative
              ? (mt.addVectors(this.boundingBox.min, jt.min),
                this.boundingBox.expandByPoint(mt),
                mt.addVectors(this.boundingBox.max, jt.max),
                this.boundingBox.expandByPoint(mt))
              : (this.boundingBox.expandByPoint(jt.min),
                this.boundingBox.expandByPoint(jt.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Qn());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new N(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((jt.setFromBufferAttribute(e), t))
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r];
          ss.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (mt.addVectors(jt.min, ss.min),
                jt.expandByPoint(mt),
                mt.addVectors(jt.max, ss.max),
                jt.expandByPoint(mt))
              : (jt.expandByPoint(ss.min), jt.expandByPoint(ss.max));
        }
      jt.getCenter(n);
      let i = 0;
      for (let r = 0, a = e.count; r < a; r++)
        mt.fromBufferAttribute(e, r),
          (i = Math.max(i, n.distanceToSquared(mt)));
      if (t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r],
            l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            mt.fromBufferAttribute(o, c),
              l && (pr.fromBufferAttribute(e, c), mt.add(pr)),
              (i = Math.max(i, n.distanceToSquared(mt)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = e.array,
      i = t.position.array,
      r = t.normal.array,
      a = t.uv.array,
      o = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Nt(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      u = [];
    for (let b = 0; b < o; b++) (c[b] = new N()), (u[b] = new N());
    const d = new N(),
      f = new N(),
      h = new N(),
      _ = new Ne(),
      m = new Ne(),
      g = new Ne(),
      p = new N(),
      y = new N();
    function v(b, R, D) {
      d.fromArray(i, b * 3),
        f.fromArray(i, R * 3),
        h.fromArray(i, D * 3),
        _.fromArray(a, b * 2),
        m.fromArray(a, R * 2),
        g.fromArray(a, D * 2),
        f.sub(d),
        h.sub(d),
        m.sub(_),
        g.sub(_);
      const P = 1 / (m.x * g.y - g.x * m.y);
      !isFinite(P) ||
        (p
          .copy(f)
          .multiplyScalar(g.y)
          .addScaledVector(h, -m.y)
          .multiplyScalar(P),
        y
          .copy(h)
          .multiplyScalar(m.x)
          .addScaledVector(f, -g.x)
          .multiplyScalar(P),
        c[b].add(p),
        c[R].add(p),
        c[D].add(p),
        u[b].add(y),
        u[R].add(y),
        u[D].add(y));
    }
    let x = this.groups;
    x.length === 0 && (x = [{ start: 0, count: n.length }]);
    for (let b = 0, R = x.length; b < R; ++b) {
      const D = x[b],
        P = D.start,
        I = D.count;
      for (let U = P, H = P + I; U < H; U += 3) v(n[U + 0], n[U + 1], n[U + 2]);
    }
    const S = new N(),
      w = new N(),
      A = new N(),
      C = new N();
    function M(b) {
      A.fromArray(r, b * 3), C.copy(A);
      const R = c[b];
      S.copy(R),
        S.sub(A.multiplyScalar(A.dot(R))).normalize(),
        w.crossVectors(C, R);
      const P = w.dot(u[b]) < 0 ? -1 : 1;
      (l[b * 4] = S.x),
        (l[b * 4 + 1] = S.y),
        (l[b * 4 + 2] = S.z),
        (l[b * 4 + 3] = P);
    }
    for (let b = 0, R = x.length; b < R; ++b) {
      const D = x[b],
        P = D.start,
        I = D.count;
      for (let U = P, H = P + I; U < H; U += 3)
        M(n[U + 0]), M(n[U + 1]), M(n[U + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new Nt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let f = 0, h = n.count; f < h; f++) n.setXYZ(f, 0, 0, 0);
      const i = new N(),
        r = new N(),
        a = new N(),
        o = new N(),
        l = new N(),
        c = new N(),
        u = new N(),
        d = new N();
      if (e)
        for (let f = 0, h = e.count; f < h; f += 3) {
          const _ = e.getX(f + 0),
            m = e.getX(f + 1),
            g = e.getX(f + 2);
          i.fromBufferAttribute(t, _),
            r.fromBufferAttribute(t, m),
            a.fromBufferAttribute(t, g),
            u.subVectors(a, r),
            d.subVectors(i, r),
            u.cross(d),
            o.fromBufferAttribute(n, _),
            l.fromBufferAttribute(n, m),
            c.fromBufferAttribute(n, g),
            o.add(u),
            l.add(u),
            c.add(u),
            n.setXYZ(_, o.x, o.y, o.z),
            n.setXYZ(m, l.x, l.y, l.z),
            n.setXYZ(g, c.x, c.y, c.z);
        }
      else
        for (let f = 0, h = t.count; f < h; f += 3)
          i.fromBufferAttribute(t, f + 0),
            r.fromBufferAttribute(t, f + 1),
            a.fromBufferAttribute(t, f + 2),
            u.subVectors(a, r),
            d.subVectors(i, r),
            u.cross(d),
            n.setXYZ(f + 0, u.x, u.y, u.z),
            n.setXYZ(f + 1, u.x, u.y, u.z),
            n.setXYZ(f + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      mt.fromBufferAttribute(e, t),
        mt.normalize(),
        e.setXYZ(t, mt.x, mt.y, mt.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        u = o.itemSize,
        d = o.normalized,
        f = new c.constructor(l.length * u);
      let h = 0,
        _ = 0;
      for (let m = 0, g = l.length; m < g; m++) {
        o.isInterleavedBufferAttribute
          ? (h = l[m] * o.data.stride + o.offset)
          : (h = l[m] * u);
        for (let p = 0; p < u; p++) f[_++] = c[h++];
      }
      return new Nt(f, u, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Rn(),
      n = this.index.array,
      i = this.attributes;
    for (const o in i) {
      const l = i[o],
        c = e(l, n);
      t.setAttribute(o, c);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const l = [],
        c = r[o];
      for (let u = 0, d = c.length; u < d; u++) {
        const f = c[u],
          h = e(f, n);
        l.push(h);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let d = 0, f = c.length; d < f; d++) {
        const h = c[d];
        u.push(h.toJSON(e.data));
      }
      u.length > 0 && ((i[l] = u), (r = !0));
    }
    r &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(t));
    }
    const r = e.morphAttributes;
    for (const c in r) {
      const u = [],
        d = r[c];
      for (let f = 0, h = d.length; f < h; f++) u.push(d[f].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const d = a[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = za(e.userData)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const wu = new Le(),
  yn = new Ba(),
  ea = new Qn(),
  Tu = new N(),
  mr = new N(),
  gr = new N(),
  _r = new N(),
  Oo = new N(),
  ta = new N(),
  na = new Ne(),
  ia = new Ne(),
  ra = new Ne(),
  Eu = new N(),
  Au = new N(),
  Cu = new N(),
  sa = new N(),
  aa = new N();
class Jt extends Qe {
  constructor(e = new Rn(), t = new gi()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = r);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      r = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const o = this.morphTargetInfluences;
    if (r && o) {
      ta.set(0, 0, 0);
      for (let l = 0, c = r.length; l < c; l++) {
        const u = o[l],
          d = r[l];
        u !== 0 &&
          (Oo.fromBufferAttribute(d, e),
          a ? ta.addScaledVector(Oo, u) : ta.addScaledVector(Oo.sub(t), u));
      }
      t.add(ta);
    }
    return this.isSkinnedMesh && this.applyBoneTransform(e, t), t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    if (
      i === void 0 ||
      (n.boundingSphere === null && n.computeBoundingSphere(),
      ea.copy(n.boundingSphere),
      ea.applyMatrix4(r),
      yn.copy(e.ray).recast(e.near),
      ea.containsPoint(yn.origin) === !1 &&
        (yn.intersectSphere(ea, Tu) === null ||
          yn.origin.distanceToSquared(Tu) > (e.far - e.near) ** 2)) ||
      (wu.copy(r).invert(),
      yn.copy(e.ray).applyMatrix4(wu),
      n.boundingBox !== null && yn.intersectsBox(n.boundingBox) === !1)
    )
      return;
    let a;
    const o = n.index,
      l = n.attributes.position,
      c = n.attributes.uv,
      u = n.attributes.uv2,
      d = n.attributes.normal,
      f = n.groups,
      h = n.drawRange;
    if (o !== null)
      if (Array.isArray(i))
        for (let _ = 0, m = f.length; _ < m; _++) {
          const g = f[_],
            p = i[g.materialIndex],
            y = Math.max(g.start, h.start),
            v = Math.min(
              o.count,
              Math.min(g.start + g.count, h.start + h.count)
            );
          for (let x = y, S = v; x < S; x += 3) {
            const w = o.getX(x),
              A = o.getX(x + 1),
              C = o.getX(x + 2);
            (a = oa(this, p, e, yn, c, u, d, w, A, C)),
              a &&
                ((a.faceIndex = Math.floor(x / 3)),
                (a.face.materialIndex = g.materialIndex),
                t.push(a));
          }
        }
      else {
        const _ = Math.max(0, h.start),
          m = Math.min(o.count, h.start + h.count);
        for (let g = _, p = m; g < p; g += 3) {
          const y = o.getX(g),
            v = o.getX(g + 1),
            x = o.getX(g + 2);
          (a = oa(this, i, e, yn, c, u, d, y, v, x)),
            a && ((a.faceIndex = Math.floor(g / 3)), t.push(a));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(i))
        for (let _ = 0, m = f.length; _ < m; _++) {
          const g = f[_],
            p = i[g.materialIndex],
            y = Math.max(g.start, h.start),
            v = Math.min(
              l.count,
              Math.min(g.start + g.count, h.start + h.count)
            );
          for (let x = y, S = v; x < S; x += 3) {
            const w = x,
              A = x + 1,
              C = x + 2;
            (a = oa(this, p, e, yn, c, u, d, w, A, C)),
              a &&
                ((a.faceIndex = Math.floor(x / 3)),
                (a.face.materialIndex = g.materialIndex),
                t.push(a));
          }
        }
      else {
        const _ = Math.max(0, h.start),
          m = Math.min(l.count, h.start + h.count);
        for (let g = _, p = m; g < p; g += 3) {
          const y = g,
            v = g + 1,
            x = g + 2;
          (a = oa(this, i, e, yn, c, u, d, y, v, x)),
            a && ((a.faceIndex = Math.floor(g / 3)), t.push(a));
        }
      }
  }
}
function M0(s, e, t, n, i, r, a, o) {
  let l;
  if (
    (e.side === Gt
      ? (l = n.intersectTriangle(a, r, i, !0, o))
      : (l = n.intersectTriangle(i, r, a, e.side === Zn, o)),
    l === null)
  )
    return null;
  aa.copy(o), aa.applyMatrix4(s.matrixWorld);
  const c = t.ray.origin.distanceTo(aa);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: aa.clone(), object: s };
}
function oa(s, e, t, n, i, r, a, o, l, c) {
  s.getVertexPosition(o, mr),
    s.getVertexPosition(l, gr),
    s.getVertexPosition(c, _r);
  const u = M0(s, e, t, n, mr, gr, _r, sa);
  if (u) {
    i &&
      (na.fromBufferAttribute(i, o),
      ia.fromBufferAttribute(i, l),
      ra.fromBufferAttribute(i, c),
      (u.uv = _n.getInterpolation(sa, mr, gr, _r, na, ia, ra, new Ne()))),
      r &&
        (na.fromBufferAttribute(r, o),
        ia.fromBufferAttribute(r, l),
        ra.fromBufferAttribute(r, c),
        (u.uv2 = _n.getInterpolation(sa, mr, gr, _r, na, ia, ra, new Ne()))),
      a &&
        (Eu.fromBufferAttribute(a, o),
        Au.fromBufferAttribute(a, l),
        Cu.fromBufferAttribute(a, c),
        (u.normal = _n.getInterpolation(sa, mr, gr, _r, Eu, Au, Cu, new N())),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = { a: o, b: l, c, normal: new N(), materialIndex: 0 };
    _n.getNormal(mr, gr, _r, d.normal), (u.face = d);
  }
  return u;
}
class Fs extends Rn {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: a,
      });
    const o = this;
    (i = Math.floor(i)), (r = Math.floor(r)), (a = Math.floor(a));
    const l = [],
      c = [],
      u = [],
      d = [];
    let f = 0,
      h = 0;
    _("z", "y", "x", -1, -1, n, t, e, a, r, 0),
      _("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
      _("x", "z", "y", 1, 1, e, n, t, i, a, 2),
      _("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
      _("x", "y", "z", 1, -1, e, t, n, i, r, 4),
      _("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
      this.setIndex(l),
      this.setAttribute("position", new Yn(c, 3)),
      this.setAttribute("normal", new Yn(u, 3)),
      this.setAttribute("uv", new Yn(d, 2));
    function _(m, g, p, y, v, x, S, w, A, C, M) {
      const b = x / A,
        R = S / C,
        D = x / 2,
        P = S / 2,
        I = w / 2,
        U = A + 1,
        H = C + 1;
      let Y = 0,
        B = 0;
      const Q = new N();
      for (let Z = 0; Z < H; Z++) {
        const me = Z * R - P;
        for (let te = 0; te < U; te++) {
          const V = te * b - D;
          (Q[m] = V * y),
            (Q[g] = me * v),
            (Q[p] = I),
            c.push(Q.x, Q.y, Q.z),
            (Q[m] = 0),
            (Q[g] = 0),
            (Q[p] = w > 0 ? 1 : -1),
            u.push(Q.x, Q.y, Q.z),
            d.push(te / A),
            d.push(1 - Z / C),
            (Y += 1);
        }
      }
      for (let Z = 0; Z < C; Z++)
        for (let me = 0; me < A; me++) {
          const te = f + me + U * Z,
            V = f + me + U * (Z + 1),
            K = f + (me + 1) + U * (Z + 1),
            ie = f + (me + 1) + U * Z;
          l.push(te, V, ie), l.push(V, K, ie), (B += 6);
        }
      o.addGroup(h, B, M), (h += B), (f += Y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Fs(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Yr(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function Dt(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = Yr(s[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function b0(s) {
  const e = [];
  for (let t = 0; t < s.length; t++) e.push(s[t].clone());
  return e;
}
function hh(s) {
  return s.getRenderTarget() === null && s.outputEncoding === ze ? Sn : Ds;
}
const w0 = { clone: Yr, merge: Dt };
var T0 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  E0 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class er extends Pn {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = T0),
      (this.fragmentShader = E0),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Yr(e.uniforms)),
      (this.uniformsGroups = b0(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture
        ? (t.uniforms[i] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (t.uniforms[i] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (t.uniforms[i] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (t.uniforms[i] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (t.uniforms[i] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: a.toArray() })
        : (t.uniforms[i] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class ph extends Qe {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Le()),
      (this.projectionMatrix = new Le()),
      (this.projectionMatrixInverse = new Le());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class It extends ph {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = jr * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(xs * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return jr * 2 * Math.atan(Math.tan(xs * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, r, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(xs * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      r = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (r += (a.offsetX * i) / l),
        (t -= (a.offsetY * n) / c),
        (i *= a.width / l),
        (n *= a.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (r += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const vr = -90,
  xr = 1;
class A0 extends Qe {
  constructor(e, t, n) {
    super(), (this.type = "CubeCamera"), (this.renderTarget = n);
    const i = new It(vr, xr, e, t);
    (i.layers = this.layers), i.up.set(0, 1, 0), i.lookAt(1, 0, 0), this.add(i);
    const r = new It(vr, xr, e, t);
    (r.layers = this.layers),
      r.up.set(0, 1, 0),
      r.lookAt(-1, 0, 0),
      this.add(r);
    const a = new It(vr, xr, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(0, 1, 0),
      this.add(a);
    const o = new It(vr, xr, e, t);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(0, -1, 0),
      this.add(o);
    const l = new It(vr, xr, e, t);
    (l.layers = this.layers), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
    const c = new It(vr, xr, e, t);
    (c.layers = this.layers),
      c.up.set(0, 1, 0),
      c.lookAt(0, 0, -1),
      this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget,
      [i, r, a, o, l, c] = this.children,
      u = e.getRenderTarget(),
      d = e.toneMapping,
      f = e.xr.enabled;
    (e.toneMapping = jn), (e.xr.enabled = !1);
    const h = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(t, i),
      e.setRenderTarget(n, 1),
      e.render(t, r),
      e.setRenderTarget(n, 2),
      e.render(t, a),
      e.setRenderTarget(n, 3),
      e.render(t, o),
      e.setRenderTarget(n, 4),
      e.render(t, l),
      (n.texture.generateMipmaps = h),
      e.setRenderTarget(n, 5),
      e.render(t, c),
      e.setRenderTarget(u),
      (e.toneMapping = d),
      (e.xr.enabled = f),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class mh extends yt {
  constructor(e, t, n, i, r, a, o, l, c, u) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Gr),
      super(e, t, n, i, r, a, o, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class C0 extends Qi {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    (this.texture = new mh(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ft);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Fs(5, 5, 5),
      r = new er({
        name: "CubemapFromEquirect",
        uniforms: Yr(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Gt,
        blending: xi,
      });
    r.uniforms.tEquirect.value = t;
    const a = new Jt(i, r),
      o = t.minFilter;
    return (
      t.minFilter === Ki && (t.minFilter = Ft),
      new A0(1, 10, this).update(e, a),
      (t.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
const No = new N(),
  P0 = new N(),
  L0 = new Ie();
class Ni {
  constructor(e = new N(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = No.subVectors(n, t).cross(P0.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(No),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || L0.getNormalMatrix(e),
      i = this.coplanarPoint(No).applyMatrix4(e),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Di = new Qn(),
  la = new N();
class Kl {
  constructor(
    e = new Ni(),
    t = new Ni(),
    n = new Ni(),
    i = new Ni(),
    r = new Ni(),
    a = new Ni()
  ) {
    this.planes = [e, t, n, i, r, a];
  }
  set(e, t, n, i, r, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(n),
      o[3].copy(i),
      o[4].copy(r),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      n = e.elements,
      i = n[0],
      r = n[1],
      a = n[2],
      o = n[3],
      l = n[4],
      c = n[5],
      u = n[6],
      d = n[7],
      f = n[8],
      h = n[9],
      _ = n[10],
      m = n[11],
      g = n[12],
      p = n[13],
      y = n[14],
      v = n[15];
    return (
      t[0].setComponents(o - i, d - l, m - f, v - g).normalize(),
      t[1].setComponents(o + i, d + l, m + f, v + g).normalize(),
      t[2].setComponents(o + r, d + c, m + h, v + p).normalize(),
      t[3].setComponents(o - r, d - c, m - h, v - p).normalize(),
      t[4].setComponents(o - a, d - u, m - _, v - y).normalize(),
      t[5].setComponents(o + a, d + u, m + _, v + y).normalize(),
      this
    );
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Di.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Di.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Di);
  }
  intersectsSprite(e) {
    return (
      Di.center.set(0, 0, 0),
      (Di.radius = 0.7071067811865476),
      Di.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Di)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((la.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (la.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (la.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(la) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function gh() {
  let s = null,
    e = !1,
    t = null,
    n = null;
  function i(r, a) {
    t(r, a), (n = s.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = s.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      s.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (r) {
      t = r;
    },
    setContext: function (r) {
      s = r;
    },
  };
}
function R0(s, e) {
  const t = e.isWebGL2,
    n = new WeakMap();
  function i(c, u) {
    const d = c.array,
      f = c.usage,
      h = s.createBuffer();
    s.bindBuffer(u, h), s.bufferData(u, d, f), c.onUploadCallback();
    let _;
    if (d instanceof Float32Array) _ = 5126;
    else if (d instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t) _ = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else _ = 5123;
    else if (d instanceof Int16Array) _ = 5122;
    else if (d instanceof Uint32Array) _ = 5125;
    else if (d instanceof Int32Array) _ = 5124;
    else if (d instanceof Int8Array) _ = 5120;
    else if (d instanceof Uint8Array) _ = 5121;
    else if (d instanceof Uint8ClampedArray) _ = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: h,
      type: _,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function r(c, u, d) {
    const f = u.array,
      h = u.updateRange;
    s.bindBuffer(d, c),
      h.count === -1
        ? s.bufferSubData(d, 0, f)
        : (t
            ? s.bufferSubData(
                d,
                h.offset * f.BYTES_PER_ELEMENT,
                f,
                h.offset,
                h.count
              )
            : s.bufferSubData(
                d,
                h.offset * f.BYTES_PER_ELEMENT,
                f.subarray(h.offset, h.offset + h.count)
              ),
          (h.count = -1)),
      u.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = n.get(c);
    u && (s.deleteBuffer(u.buffer), n.delete(c));
  }
  function l(c, u) {
    if (c.isGLBufferAttribute) {
      const f = n.get(c);
      (!f || f.version < c.version) &&
        n.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const d = n.get(c);
    d === void 0
      ? n.set(c, i(c, u))
      : d.version < c.version && (r(d.buffer, c, u), (d.version = c.version));
  }
  return { get: a, remove: o, update: l };
}
class Ga extends Rn {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const r = e / 2,
      a = t / 2,
      o = Math.floor(n),
      l = Math.floor(i),
      c = o + 1,
      u = l + 1,
      d = e / o,
      f = t / l,
      h = [],
      _ = [],
      m = [],
      g = [];
    for (let p = 0; p < u; p++) {
      const y = p * f - a;
      for (let v = 0; v < c; v++) {
        const x = v * d - r;
        _.push(x, -y, 0), m.push(0, 0, 1), g.push(v / o), g.push(1 - p / l);
      }
    }
    for (let p = 0; p < l; p++)
      for (let y = 0; y < o; y++) {
        const v = y + c * p,
          x = y + c * (p + 1),
          S = y + 1 + c * (p + 1),
          w = y + 1 + c * p;
        h.push(v, x, w), h.push(x, S, w);
      }
    this.setIndex(h),
      this.setAttribute("position", new Yn(_, 3)),
      this.setAttribute("normal", new Yn(m, 3)),
      this.setAttribute("uv", new Yn(g, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ga(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var D0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  I0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  O0 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  N0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  U0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  F0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  k0 = "vec3 transformed = vec3( position );",
  z0 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  B0 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  V0 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  G0 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  H0 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  W0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  q0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  X0 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  j0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Y0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  $0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  K0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  Z0 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  J0 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Q0 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  ev = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  tv = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  nv = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  iv = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  rv = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  sv = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  av = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  ov = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  lv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  cv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  uv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  dv = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fv = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  hv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  pv = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  mv = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  gv = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  _v = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  vv = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  xv = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  yv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Sv = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  Mv = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  bv = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  wv = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Tv = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Ev = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`,
  Av = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Cv = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Pv = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Lv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  Rv = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Dv = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Iv = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  Ov = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  Nv = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Uv = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Fv = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  kv = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  zv = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Bv = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Vv = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Gv = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  Hv = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  Wv = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  qv = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  Xv = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  jv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Yv = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  $v = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Kv = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Zv = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  Jv = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  Qv = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  ex = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  tx = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  nx = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  ix = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  rx = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  sx = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  ax = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  ox = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  lx = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  cx = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  ux = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  dx = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  fx = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  hx = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  px = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  mx = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  gx = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  _x = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  vx = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  xx = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  yx = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  Sx = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  Mx = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  bx = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  wx = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_UV2
	attribute vec2 uv2;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Tx = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  Ex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Ax = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  Cx = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  Px = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Lx = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  Rx = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Dx = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  Ix = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  Ox = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  Nx = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Ux = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Fx = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  kx = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  zx = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Bx = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Vx = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Gx = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Hx = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Wx = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  qx = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  Xx = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  jx = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Yx = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  $x = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Kx = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Zx = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  Jx = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Qx = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  ey = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ty = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  ny = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  iy = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  ry = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  sy = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ay = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Ae = {
    alphamap_fragment: D0,
    alphamap_pars_fragment: I0,
    alphatest_fragment: O0,
    alphatest_pars_fragment: N0,
    aomap_fragment: U0,
    aomap_pars_fragment: F0,
    begin_vertex: k0,
    beginnormal_vertex: z0,
    bsdfs: B0,
    iridescence_fragment: V0,
    bumpmap_pars_fragment: G0,
    clipping_planes_fragment: H0,
    clipping_planes_pars_fragment: W0,
    clipping_planes_pars_vertex: q0,
    clipping_planes_vertex: X0,
    color_fragment: j0,
    color_pars_fragment: Y0,
    color_pars_vertex: $0,
    color_vertex: K0,
    common: Z0,
    cube_uv_reflection_fragment: J0,
    defaultnormal_vertex: Q0,
    displacementmap_pars_vertex: ev,
    displacementmap_vertex: tv,
    emissivemap_fragment: nv,
    emissivemap_pars_fragment: iv,
    encodings_fragment: rv,
    encodings_pars_fragment: sv,
    envmap_fragment: av,
    envmap_common_pars_fragment: ov,
    envmap_pars_fragment: lv,
    envmap_pars_vertex: cv,
    envmap_physical_pars_fragment: Sv,
    envmap_vertex: uv,
    fog_vertex: dv,
    fog_pars_vertex: fv,
    fog_fragment: hv,
    fog_pars_fragment: pv,
    gradientmap_pars_fragment: mv,
    lightmap_fragment: gv,
    lightmap_pars_fragment: _v,
    lights_lambert_fragment: vv,
    lights_lambert_pars_fragment: xv,
    lights_pars_begin: yv,
    lights_toon_fragment: Mv,
    lights_toon_pars_fragment: bv,
    lights_phong_fragment: wv,
    lights_phong_pars_fragment: Tv,
    lights_physical_fragment: Ev,
    lights_physical_pars_fragment: Av,
    lights_fragment_begin: Cv,
    lights_fragment_maps: Pv,
    lights_fragment_end: Lv,
    logdepthbuf_fragment: Rv,
    logdepthbuf_pars_fragment: Dv,
    logdepthbuf_pars_vertex: Iv,
    logdepthbuf_vertex: Ov,
    map_fragment: Nv,
    map_pars_fragment: Uv,
    map_particle_fragment: Fv,
    map_particle_pars_fragment: kv,
    metalnessmap_fragment: zv,
    metalnessmap_pars_fragment: Bv,
    morphcolor_vertex: Vv,
    morphnormal_vertex: Gv,
    morphtarget_pars_vertex: Hv,
    morphtarget_vertex: Wv,
    normal_fragment_begin: qv,
    normal_fragment_maps: Xv,
    normal_pars_fragment: jv,
    normal_pars_vertex: Yv,
    normal_vertex: $v,
    normalmap_pars_fragment: Kv,
    clearcoat_normal_fragment_begin: Zv,
    clearcoat_normal_fragment_maps: Jv,
    clearcoat_pars_fragment: Qv,
    iridescence_pars_fragment: ex,
    output_fragment: tx,
    packing: nx,
    premultiplied_alpha_fragment: ix,
    project_vertex: rx,
    dithering_fragment: sx,
    dithering_pars_fragment: ax,
    roughnessmap_fragment: ox,
    roughnessmap_pars_fragment: lx,
    shadowmap_pars_fragment: cx,
    shadowmap_pars_vertex: ux,
    shadowmap_vertex: dx,
    shadowmask_pars_fragment: fx,
    skinbase_vertex: hx,
    skinning_pars_vertex: px,
    skinning_vertex: mx,
    skinnormal_vertex: gx,
    specularmap_fragment: _x,
    specularmap_pars_fragment: vx,
    tonemapping_fragment: xx,
    tonemapping_pars_fragment: yx,
    transmission_fragment: Sx,
    transmission_pars_fragment: Mx,
    uv_pars_fragment: bx,
    uv_pars_vertex: wx,
    uv_vertex: Tx,
    worldpos_vertex: Ex,
    background_vert: Ax,
    background_frag: Cx,
    backgroundCube_vert: Px,
    backgroundCube_frag: Lx,
    cube_vert: Rx,
    cube_frag: Dx,
    depth_vert: Ix,
    depth_frag: Ox,
    distanceRGBA_vert: Nx,
    distanceRGBA_frag: Ux,
    equirect_vert: Fx,
    equirect_frag: kx,
    linedashed_vert: zx,
    linedashed_frag: Bx,
    meshbasic_vert: Vx,
    meshbasic_frag: Gx,
    meshlambert_vert: Hx,
    meshlambert_frag: Wx,
    meshmatcap_vert: qx,
    meshmatcap_frag: Xx,
    meshnormal_vert: jx,
    meshnormal_frag: Yx,
    meshphong_vert: $x,
    meshphong_frag: Kx,
    meshphysical_vert: Zx,
    meshphysical_frag: Jx,
    meshtoon_vert: Qx,
    meshtoon_frag: ey,
    points_vert: ty,
    points_frag: ny,
    shadow_vert: iy,
    shadow_frag: ry,
    sprite_vert: sy,
    sprite_frag: ay,
  },
  re = {
    common: {
      diffuse: { value: new Te(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Ie() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Ie() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Ie() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Ie() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Ie() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Ie() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Ie() },
      normalScale: { value: new Ne(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Ie() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Ie() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Ie() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Ie() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Te(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Te(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Ie() },
    },
    sprite: {
      diffuse: { value: new Te(16777215) },
      opacity: { value: 1 },
      center: { value: new Ne(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Ie() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
  },
  Mn = {
    basic: {
      uniforms: Dt([
        re.common,
        re.specularmap,
        re.envmap,
        re.aomap,
        re.lightmap,
        re.fog,
      ]),
      vertexShader: Ae.meshbasic_vert,
      fragmentShader: Ae.meshbasic_frag,
    },
    lambert: {
      uniforms: Dt([
        re.common,
        re.specularmap,
        re.envmap,
        re.aomap,
        re.lightmap,
        re.emissivemap,
        re.bumpmap,
        re.normalmap,
        re.displacementmap,
        re.fog,
        re.lights,
        { emissive: { value: new Te(0) } },
      ]),
      vertexShader: Ae.meshlambert_vert,
      fragmentShader: Ae.meshlambert_frag,
    },
    phong: {
      uniforms: Dt([
        re.common,
        re.specularmap,
        re.envmap,
        re.aomap,
        re.lightmap,
        re.emissivemap,
        re.bumpmap,
        re.normalmap,
        re.displacementmap,
        re.fog,
        re.lights,
        {
          emissive: { value: new Te(0) },
          specular: { value: new Te(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ae.meshphong_vert,
      fragmentShader: Ae.meshphong_frag,
    },
    standard: {
      uniforms: Dt([
        re.common,
        re.envmap,
        re.aomap,
        re.lightmap,
        re.emissivemap,
        re.bumpmap,
        re.normalmap,
        re.displacementmap,
        re.roughnessmap,
        re.metalnessmap,
        re.fog,
        re.lights,
        {
          emissive: { value: new Te(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ae.meshphysical_vert,
      fragmentShader: Ae.meshphysical_frag,
    },
    toon: {
      uniforms: Dt([
        re.common,
        re.aomap,
        re.lightmap,
        re.emissivemap,
        re.bumpmap,
        re.normalmap,
        re.displacementmap,
        re.gradientmap,
        re.fog,
        re.lights,
        { emissive: { value: new Te(0) } },
      ]),
      vertexShader: Ae.meshtoon_vert,
      fragmentShader: Ae.meshtoon_frag,
    },
    matcap: {
      uniforms: Dt([
        re.common,
        re.bumpmap,
        re.normalmap,
        re.displacementmap,
        re.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ae.meshmatcap_vert,
      fragmentShader: Ae.meshmatcap_frag,
    },
    points: {
      uniforms: Dt([re.points, re.fog]),
      vertexShader: Ae.points_vert,
      fragmentShader: Ae.points_frag,
    },
    dashed: {
      uniforms: Dt([
        re.common,
        re.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ae.linedashed_vert,
      fragmentShader: Ae.linedashed_frag,
    },
    depth: {
      uniforms: Dt([re.common, re.displacementmap]),
      vertexShader: Ae.depth_vert,
      fragmentShader: Ae.depth_frag,
    },
    normal: {
      uniforms: Dt([
        re.common,
        re.bumpmap,
        re.normalmap,
        re.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ae.meshnormal_vert,
      fragmentShader: Ae.meshnormal_frag,
    },
    sprite: {
      uniforms: Dt([re.sprite, re.fog]),
      vertexShader: Ae.sprite_vert,
      fragmentShader: Ae.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Ie() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ae.background_vert,
      fragmentShader: Ae.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ae.backgroundCube_vert,
      fragmentShader: Ae.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Ae.cube_vert,
      fragmentShader: Ae.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ae.equirect_vert,
      fragmentShader: Ae.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Dt([
        re.common,
        re.displacementmap,
        {
          referencePosition: { value: new N() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ae.distanceRGBA_vert,
      fragmentShader: Ae.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Dt([
        re.lights,
        re.fog,
        { color: { value: new Te(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ae.shadow_vert,
      fragmentShader: Ae.shadow_frag,
    },
  };
Mn.physical = {
  uniforms: Dt([
    Mn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Ie() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Ie() },
      clearcoatNormalScale: { value: new Ne(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Ie() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Ie() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Ie() },
      sheen: { value: 0 },
      sheenColor: { value: new Te(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Ie() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Ie() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Ie() },
      transmissionSamplerSize: { value: new Ne() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Ie() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Te(0) },
      specularColor: { value: new Te(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Ie() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Ie() },
    },
  ]),
  vertexShader: Ae.meshphysical_vert,
  fragmentShader: Ae.meshphysical_frag,
};
const ca = { r: 0, b: 0, g: 0 };
function oy(s, e, t, n, i, r, a) {
  const o = new Te(0);
  let l = r === !0 ? 0 : 1,
    c,
    u,
    d = null,
    f = 0,
    h = null;
  function _(g, p) {
    let y = !1,
      v = p.isScene === !0 ? p.background : null;
    v && v.isTexture && (v = (p.backgroundBlurriness > 0 ? t : e).get(v));
    const x = s.xr,
      S = x.getSession && x.getSession();
    S && S.environmentBlendMode === "additive" && (v = null),
      v === null ? m(o, l) : v && v.isColor && (m(v, 1), (y = !0)),
      (s.autoClear || y) &&
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
      v && (v.isCubeTexture || v.mapping === ka)
        ? (u === void 0 &&
            ((u = new Jt(
              new Fs(1, 1, 1),
              new er({
                name: "BackgroundCubeMaterial",
                uniforms: Yr(Mn.backgroundCube.uniforms),
                vertexShader: Mn.backgroundCube.vertexShader,
                fragmentShader: Mn.backgroundCube.fragmentShader,
                side: Gt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (w, A, C) {
              this.matrixWorld.copyPosition(C.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(u)),
          (u.material.uniforms.envMap.value = v),
          (u.material.uniforms.flipEnvMap.value =
            v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
          (u.material.uniforms.backgroundBlurriness.value =
            p.backgroundBlurriness),
          (u.material.uniforms.backgroundIntensity.value =
            p.backgroundIntensity),
          (u.material.toneMapped = v.encoding !== ze),
          (d !== v || f !== v.version || h !== s.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (d = v),
            (f = v.version),
            (h = s.toneMapping)),
          u.layers.enableAll(),
          g.unshift(u, u.geometry, u.material, 0, 0, null))
        : v &&
          v.isTexture &&
          (c === void 0 &&
            ((c = new Jt(
              new Ga(2, 2),
              new er({
                name: "BackgroundMaterial",
                uniforms: Yr(Mn.background.uniforms),
                vertexShader: Mn.background.vertexShader,
                fragmentShader: Mn.background.fragmentShader,
                side: Zn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(c)),
          (c.material.uniforms.t2D.value = v),
          (c.material.uniforms.backgroundIntensity.value =
            p.backgroundIntensity),
          (c.material.toneMapped = v.encoding !== ze),
          v.matrixAutoUpdate === !0 && v.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(v.matrix),
          (d !== v || f !== v.version || h !== s.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (d = v),
            (f = v.version),
            (h = s.toneMapping)),
          c.layers.enableAll(),
          g.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function m(g, p) {
    g.getRGB(ca, hh(s)), n.buffers.color.setClear(ca.r, ca.g, ca.b, p, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (g, p = 1) {
      o.set(g), (l = p), m(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (g) {
      (l = g), m(o, l);
    },
    render: _,
  };
}
function ly(s, e, t, n) {
  const i = s.getParameter(34921),
    r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = n.isWebGL2 || r !== null,
    o = {},
    l = g(null);
  let c = l,
    u = !1;
  function d(I, U, H, Y, B) {
    let Q = !1;
    if (a) {
      const Z = m(Y, H, U);
      c !== Z && ((c = Z), h(c.object)),
        (Q = p(I, Y, H, B)),
        Q && y(I, Y, H, B);
    } else {
      const Z = U.wireframe === !0;
      (c.geometry !== Y.id || c.program !== H.id || c.wireframe !== Z) &&
        ((c.geometry = Y.id), (c.program = H.id), (c.wireframe = Z), (Q = !0));
    }
    B !== null && t.update(B, 34963),
      (Q || u) &&
        ((u = !1),
        C(I, U, H, Y),
        B !== null && s.bindBuffer(34963, t.get(B).buffer));
  }
  function f() {
    return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
  }
  function h(I) {
    return n.isWebGL2 ? s.bindVertexArray(I) : r.bindVertexArrayOES(I);
  }
  function _(I) {
    return n.isWebGL2 ? s.deleteVertexArray(I) : r.deleteVertexArrayOES(I);
  }
  function m(I, U, H) {
    const Y = H.wireframe === !0;
    let B = o[I.id];
    B === void 0 && ((B = {}), (o[I.id] = B));
    let Q = B[U.id];
    Q === void 0 && ((Q = {}), (B[U.id] = Q));
    let Z = Q[Y];
    return Z === void 0 && ((Z = g(f())), (Q[Y] = Z)), Z;
  }
  function g(I) {
    const U = [],
      H = [],
      Y = [];
    for (let B = 0; B < i; B++) (U[B] = 0), (H[B] = 0), (Y[B] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: U,
      enabledAttributes: H,
      attributeDivisors: Y,
      object: I,
      attributes: {},
      index: null,
    };
  }
  function p(I, U, H, Y) {
    const B = c.attributes,
      Q = U.attributes;
    let Z = 0;
    const me = H.getAttributes();
    for (const te in me)
      if (me[te].location >= 0) {
        const K = B[te];
        let ie = Q[te];
        if (
          (ie === void 0 &&
            (te === "instanceMatrix" &&
              I.instanceMatrix &&
              (ie = I.instanceMatrix),
            te === "instanceColor" &&
              I.instanceColor &&
              (ie = I.instanceColor)),
          K === void 0 || K.attribute !== ie || (ie && K.data !== ie.data))
        )
          return !0;
        Z++;
      }
    return c.attributesNum !== Z || c.index !== Y;
  }
  function y(I, U, H, Y) {
    const B = {},
      Q = U.attributes;
    let Z = 0;
    const me = H.getAttributes();
    for (const te in me)
      if (me[te].location >= 0) {
        let K = Q[te];
        K === void 0 &&
          (te === "instanceMatrix" &&
            I.instanceMatrix &&
            (K = I.instanceMatrix),
          te === "instanceColor" && I.instanceColor && (K = I.instanceColor));
        const ie = {};
        (ie.attribute = K),
          K && K.data && (ie.data = K.data),
          (B[te] = ie),
          Z++;
      }
    (c.attributes = B), (c.attributesNum = Z), (c.index = Y);
  }
  function v() {
    const I = c.newAttributes;
    for (let U = 0, H = I.length; U < H; U++) I[U] = 0;
  }
  function x(I) {
    S(I, 0);
  }
  function S(I, U) {
    const H = c.newAttributes,
      Y = c.enabledAttributes,
      B = c.attributeDivisors;
    (H[I] = 1),
      Y[I] === 0 && (s.enableVertexAttribArray(I), (Y[I] = 1)),
      B[I] !== U &&
        ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](I, U),
        (B[I] = U));
  }
  function w() {
    const I = c.newAttributes,
      U = c.enabledAttributes;
    for (let H = 0, Y = U.length; H < Y; H++)
      U[H] !== I[H] && (s.disableVertexAttribArray(H), (U[H] = 0));
  }
  function A(I, U, H, Y, B, Q) {
    n.isWebGL2 === !0 && (H === 5124 || H === 5125)
      ? s.vertexAttribIPointer(I, U, H, B, Q)
      : s.vertexAttribPointer(I, U, H, Y, B, Q);
  }
  function C(I, U, H, Y) {
    if (
      n.isWebGL2 === !1 &&
      (I.isInstancedMesh || Y.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    v();
    const B = Y.attributes,
      Q = H.getAttributes(),
      Z = U.defaultAttributeValues;
    for (const me in Q) {
      const te = Q[me];
      if (te.location >= 0) {
        let V = B[me];
        if (
          (V === void 0 &&
            (me === "instanceMatrix" &&
              I.instanceMatrix &&
              (V = I.instanceMatrix),
            me === "instanceColor" && I.instanceColor && (V = I.instanceColor)),
          V !== void 0)
        ) {
          const K = V.normalized,
            ie = V.itemSize,
            oe = t.get(V);
          if (oe === void 0) continue;
          const z = oe.buffer,
            we = oe.type,
            Me = oe.bytesPerElement;
          if (V.isInterleavedBufferAttribute) {
            const se = V.data,
              xe = se.stride,
              Be = V.offset;
            if (se.isInstancedInterleavedBuffer) {
              for (let pe = 0; pe < te.locationSize; pe++)
                S(te.location + pe, se.meshPerAttribute);
              I.isInstancedMesh !== !0 &&
                Y._maxInstanceCount === void 0 &&
                (Y._maxInstanceCount = se.meshPerAttribute * se.count);
            } else
              for (let pe = 0; pe < te.locationSize; pe++) x(te.location + pe);
            s.bindBuffer(34962, z);
            for (let pe = 0; pe < te.locationSize; pe++)
              A(
                te.location + pe,
                ie / te.locationSize,
                we,
                K,
                xe * Me,
                (Be + (ie / te.locationSize) * pe) * Me
              );
          } else {
            if (V.isInstancedBufferAttribute) {
              for (let se = 0; se < te.locationSize; se++)
                S(te.location + se, V.meshPerAttribute);
              I.isInstancedMesh !== !0 &&
                Y._maxInstanceCount === void 0 &&
                (Y._maxInstanceCount = V.meshPerAttribute * V.count);
            } else
              for (let se = 0; se < te.locationSize; se++) x(te.location + se);
            s.bindBuffer(34962, z);
            for (let se = 0; se < te.locationSize; se++)
              A(
                te.location + se,
                ie / te.locationSize,
                we,
                K,
                ie * Me,
                (ie / te.locationSize) * se * Me
              );
          }
        } else if (Z !== void 0) {
          const K = Z[me];
          if (K !== void 0)
            switch (K.length) {
              case 2:
                s.vertexAttrib2fv(te.location, K);
                break;
              case 3:
                s.vertexAttrib3fv(te.location, K);
                break;
              case 4:
                s.vertexAttrib4fv(te.location, K);
                break;
              default:
                s.vertexAttrib1fv(te.location, K);
            }
        }
      }
    }
    w();
  }
  function M() {
    D();
    for (const I in o) {
      const U = o[I];
      for (const H in U) {
        const Y = U[H];
        for (const B in Y) _(Y[B].object), delete Y[B];
        delete U[H];
      }
      delete o[I];
    }
  }
  function b(I) {
    if (o[I.id] === void 0) return;
    const U = o[I.id];
    for (const H in U) {
      const Y = U[H];
      for (const B in Y) _(Y[B].object), delete Y[B];
      delete U[H];
    }
    delete o[I.id];
  }
  function R(I) {
    for (const U in o) {
      const H = o[U];
      if (H[I.id] === void 0) continue;
      const Y = H[I.id];
      for (const B in Y) _(Y[B].object), delete Y[B];
      delete H[I.id];
    }
  }
  function D() {
    P(), (u = !0), c !== l && ((c = l), h(c.object));
  }
  function P() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: d,
    reset: D,
    resetDefaultState: P,
    dispose: M,
    releaseStatesOfGeometry: b,
    releaseStatesOfProgram: R,
    initAttributes: v,
    enableAttribute: x,
    disableUnusedAttributes: w,
  };
}
function cy(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function a(c) {
    r = c;
  }
  function o(c, u) {
    s.drawArrays(r, c, u), t.update(u, r, 1);
  }
  function l(c, u, d) {
    if (d === 0) return;
    let f, h;
    if (i) (f = s), (h = "drawArraysInstanced");
    else if (
      ((f = e.get("ANGLE_instanced_arrays")),
      (h = "drawArraysInstancedANGLE"),
      f === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    f[h](r, c, u, d), t.update(u, r, d);
  }
  (this.setMode = a), (this.render = o), (this.renderInstances = l);
}
function uy(s, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const A = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function r(A) {
    if (A === "highp") {
      if (
        s.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        s.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      A = "mediump";
    }
    return A === "mediump" &&
      s.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      s.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const a =
    typeof WebGL2RenderingContext != "undefined" &&
    s.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const l = r(o);
  l !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      l,
      "instead."
    ),
    (o = l));
  const c = a || e.has("WEBGL_draw_buffers"),
    u = t.logarithmicDepthBuffer === !0,
    d = s.getParameter(34930),
    f = s.getParameter(35660),
    h = s.getParameter(3379),
    _ = s.getParameter(34076),
    m = s.getParameter(34921),
    g = s.getParameter(36347),
    p = s.getParameter(36348),
    y = s.getParameter(36349),
    v = f > 0,
    x = a || e.has("OES_texture_float"),
    S = v && x,
    w = a ? s.getParameter(36183) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: o,
    logarithmicDepthBuffer: u,
    maxTextures: d,
    maxVertexTextures: f,
    maxTextureSize: h,
    maxCubemapSize: _,
    maxAttributes: m,
    maxVertexUniforms: g,
    maxVaryings: p,
    maxFragmentUniforms: y,
    vertexTextures: v,
    floatFragmentTextures: x,
    floatVertexTextures: S,
    maxSamples: w,
  };
}
function dy(s) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    r = !1;
  const a = new Ni(),
    o = new Ie(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, f) {
      const h = d.length !== 0 || f || n !== 0 || i;
      return (i = f), (n = d.length), h;
    }),
    (this.beginShadows = function () {
      (r = !0), u(null);
    }),
    (this.endShadows = function () {
      r = !1;
    }),
    (this.setGlobalState = function (d, f) {
      t = u(d, f, 0);
    }),
    (this.setState = function (d, f, h) {
      const _ = d.clippingPlanes,
        m = d.clipIntersection,
        g = d.clipShadows,
        p = s.get(d);
      if (!i || _ === null || _.length === 0 || (r && !g)) r ? u(null) : c();
      else {
        const y = r ? 0 : n,
          v = y * 4;
        let x = p.clippingState || null;
        (l.value = x), (x = u(_, f, v, h));
        for (let S = 0; S !== v; ++S) x[S] = t[S];
        (p.clippingState = x),
          (this.numIntersection = m ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function u(d, f, h, _) {
    const m = d !== null ? d.length : 0;
    let g = null;
    if (m !== 0) {
      if (((g = l.value), _ !== !0 || g === null)) {
        const p = h + m * 4,
          y = f.matrixWorldInverse;
        o.getNormalMatrix(y),
          (g === null || g.length < p) && (g = new Float32Array(p));
        for (let v = 0, x = h; v !== m; ++v, x += 4)
          a.copy(d[v]).applyMatrix4(y, o),
            a.normal.toArray(g, x),
            (g[x + 3] = a.constant);
      }
      (l.value = g), (l.needsUpdate = !0);
    }
    return (e.numPlanes = m), (e.numIntersection = 0), g;
  }
}
function fy(s) {
  let e = new WeakMap();
  function t(a, o) {
    return o === ul ? (a.mapping = Gr) : o === dl && (a.mapping = Hr), a;
  }
  function n(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === ul || o === dl)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new C0(l.height / 2);
            return (
              c.fromEquirectangularTexture(s, a),
              e.set(a, c),
              a.addEventListener("dispose", i),
              t(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function i(a) {
    const o = a.target;
    o.removeEventListener("dispose", i);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function r() {
    e = new WeakMap();
  }
  return { get: n, dispose: r };
}
class Zl extends ph {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = r),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, r, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let r = n - e,
      a = n + e,
      o = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += c * this.view.offsetX),
        (a = r + c * this.view.width),
        (o -= u * this.view.offsetY),
        (l = o - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(r, a, o, l, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const Pr = 4,
  Pu = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Fi = 20,
  Uo = new Zl(),
  Lu = new Te();
let Fo = null;
const Ui = (1 + Math.sqrt(5)) / 2,
  yr = 1 / Ui,
  Ru = [
    new N(1, 1, 1),
    new N(-1, 1, 1),
    new N(1, 1, -1),
    new N(-1, 1, -1),
    new N(0, Ui, yr),
    new N(0, Ui, -yr),
    new N(yr, 0, Ui),
    new N(-yr, 0, Ui),
    new N(Ui, yr, 0),
    new N(-Ui, yr, 0),
  ];
class Du {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (Fo = this._renderer.getRenderTarget()), this._setSize(256);
    const r = this._allocateTargets();
    return (
      (r.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, r),
      t > 0 && this._blur(r, 0, 0, t),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Nu()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Ou()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Fo),
      (e.scissorTest = !1),
      ua(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Gr || e.mapping === Hr
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Fo = this._renderer.getRenderTarget());
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: Ft,
        minFilter: Ft,
        generateMipmaps: !1,
        type: Ls,
        format: cn,
        encoding: Ji,
        depthBuffer: !1,
      },
      i = Iu(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Iu(e, t, n));
      const { _lodMax: r } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = hy(r)),
        (this._blurMaterial = py(r, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Jt(this._lodPlanes[0], e);
    this._renderer.compile(t, Uo);
  }
  _sceneToCubeUV(e, t, n, i) {
    const o = new It(90, 1, t, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      d = u.autoClear,
      f = u.toneMapping;
    u.getClearColor(Lu), (u.toneMapping = jn), (u.autoClear = !1);
    const h = new gi({
        name: "PMREM.Background",
        side: Gt,
        depthWrite: !1,
        depthTest: !1,
      }),
      _ = new Jt(new Fs(), h);
    let m = !1;
    const g = e.background;
    g
      ? g.isColor && (h.color.copy(g), (e.background = null), (m = !0))
      : (h.color.copy(Lu), (m = !0));
    for (let p = 0; p < 6; p++) {
      const y = p % 3;
      y === 0
        ? (o.up.set(0, l[p], 0), o.lookAt(c[p], 0, 0))
        : y === 1
        ? (o.up.set(0, 0, l[p]), o.lookAt(0, c[p], 0))
        : (o.up.set(0, l[p], 0), o.lookAt(0, 0, c[p]));
      const v = this._cubeSize;
      ua(i, y * v, p > 2 ? v : 0, v, v),
        u.setRenderTarget(i),
        m && u.render(_, o),
        u.render(e, o);
    }
    _.geometry.dispose(),
      _.material.dispose(),
      (u.toneMapping = f),
      (u.autoClear = d),
      (e.background = g);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === Gr || e.mapping === Hr;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Nu()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Ou());
    const r = i ? this._cubemapMaterial : this._equirectMaterial,
      a = new Jt(this._lodPlanes[0], r),
      o = r.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    ua(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, Uo);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const r = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        a = Ru[(i - 1) % Ru.length];
      this._blur(e, i - 1, i, r, a);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, r) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, i, "latitudinal", r),
      this._halfBlur(a, e, n, n, i, "longitudinal", r);
  }
  _halfBlur(e, t, n, i, r, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      d = new Jt(this._lodPlanes[i], c),
      f = c.uniforms,
      h = this._sizeLods[n] - 1,
      _ = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / (2 * Fi - 1),
      m = r / _,
      g = isFinite(r) ? 1 + Math.floor(u * m) : Fi;
    g > Fi &&
      console.warn(
        `sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Fi}`
      );
    const p = [];
    let y = 0;
    for (let A = 0; A < Fi; ++A) {
      const C = A / m,
        M = Math.exp((-C * C) / 2);
      p.push(M), A === 0 ? (y += M) : A < g && (y += 2 * M);
    }
    for (let A = 0; A < p.length; A++) p[A] = p[A] / y;
    (f.envMap.value = e.texture),
      (f.samples.value = g),
      (f.weights.value = p),
      (f.latitudinal.value = a === "latitudinal"),
      o && (f.poleAxis.value = o);
    const { _lodMax: v } = this;
    (f.dTheta.value = _), (f.mipInt.value = v - n);
    const x = this._sizeLods[i],
      S = 3 * x * (i > v - Pr ? i - v + Pr : 0),
      w = 4 * (this._cubeSize - x);
    ua(t, S, w, 3 * x, 2 * x), l.setRenderTarget(t), l.render(d, Uo);
  }
}
function hy(s) {
  const e = [],
    t = [],
    n = [];
  let i = s;
  const r = s - Pr + 1 + Pu.length;
  for (let a = 0; a < r; a++) {
    const o = Math.pow(2, i);
    t.push(o);
    let l = 1 / o;
    a > s - Pr ? (l = Pu[a - s + Pr - 1]) : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2),
      u = -c,
      d = 1 + c,
      f = [u, u, d, u, d, d, u, u, d, d, u, d],
      h = 6,
      _ = 6,
      m = 3,
      g = 2,
      p = 1,
      y = new Float32Array(m * _ * h),
      v = new Float32Array(g * _ * h),
      x = new Float32Array(p * _ * h);
    for (let w = 0; w < h; w++) {
      const A = ((w % 3) * 2) / 3 - 1,
        C = w > 2 ? 0 : -1,
        M = [
          A,
          C,
          0,
          A + 2 / 3,
          C,
          0,
          A + 2 / 3,
          C + 1,
          0,
          A,
          C,
          0,
          A + 2 / 3,
          C + 1,
          0,
          A,
          C + 1,
          0,
        ];
      y.set(M, m * _ * w), v.set(f, g * _ * w);
      const b = [w, w, w, w, w, w];
      x.set(b, p * _ * w);
    }
    const S = new Rn();
    S.setAttribute("position", new Nt(y, m)),
      S.setAttribute("uv", new Nt(v, g)),
      S.setAttribute("faceIndex", new Nt(x, p)),
      e.push(S),
      i > Pr && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Iu(s, e, t) {
  const n = new Qi(s, e, t);
  return (
    (n.texture.mapping = ka),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function ua(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function py(s, e, t) {
  const n = new Float32Array(Fi),
    i = new N(0, 1, 0);
  return new er({
    name: "SphericalGaussianBlur",
    defines: {
      n: Fi,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Jl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: xi,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Ou() {
  return new er({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Jl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: xi,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Nu() {
  return new er({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Jl(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: xi,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Jl() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function my(s) {
  let e = new WeakMap(),
    t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === ul || l === dl,
        u = l === Gr || l === Hr;
      if (c || u)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let d = e.get(o);
          return (
            t === null && (t = new Du(s)),
            (d = c ? t.fromEquirectangular(o, d) : t.fromCubemap(o, d)),
            e.set(o, d),
            d.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const d = o.image;
            if ((c && d && d.height > 0) || (u && d && i(d))) {
              t === null && (t = new Du(s));
              const f = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, f), o.addEventListener("dispose", r), f.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function i(o) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
    return l === c;
  }
  function r(o) {
    const l = o.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: a };
}
function gy(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          s.getExtension("WEBGL_depth_texture") ||
          s.getExtension("MOZ_WEBGL_depth_texture") ||
          s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          s.getExtension("EXT_texture_filter_anisotropic") ||
          s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          s.getExtension("WEBGL_compressed_texture_s3tc") ||
          s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          s.getExtension("WEBGL_compressed_texture_pvrtc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        i
      );
    },
  };
}
function _y(s, e, t, n) {
  const i = {},
    r = new WeakMap();
  function a(d) {
    const f = d.target;
    f.index !== null && e.remove(f.index);
    for (const _ in f.attributes) e.remove(f.attributes[_]);
    f.removeEventListener("dispose", a), delete i[f.id];
    const h = r.get(f);
    h && (e.remove(h), r.delete(f)),
      n.releaseStatesOfGeometry(f),
      f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
      t.memory.geometries--;
  }
  function o(d, f) {
    return (
      i[f.id] === !0 ||
        (f.addEventListener("dispose", a),
        (i[f.id] = !0),
        t.memory.geometries++),
      f
    );
  }
  function l(d) {
    const f = d.attributes;
    for (const _ in f) e.update(f[_], 34962);
    const h = d.morphAttributes;
    for (const _ in h) {
      const m = h[_];
      for (let g = 0, p = m.length; g < p; g++) e.update(m[g], 34962);
    }
  }
  function c(d) {
    const f = [],
      h = d.index,
      _ = d.attributes.position;
    let m = 0;
    if (h !== null) {
      const y = h.array;
      m = h.version;
      for (let v = 0, x = y.length; v < x; v += 3) {
        const S = y[v + 0],
          w = y[v + 1],
          A = y[v + 2];
        f.push(S, w, w, A, A, S);
      }
    } else {
      const y = _.array;
      m = _.version;
      for (let v = 0, x = y.length / 3 - 1; v < x; v += 3) {
        const S = v + 0,
          w = v + 1,
          A = v + 2;
        f.push(S, w, w, A, A, S);
      }
    }
    const g = new (ah(f) ? fh : dh)(f, 1);
    g.version = m;
    const p = r.get(d);
    p && e.remove(p), r.set(d, g);
  }
  function u(d) {
    const f = r.get(d);
    if (f) {
      const h = d.index;
      h !== null && f.version < h.version && c(d);
    } else c(d);
    return r.get(d);
  }
  return { get: o, update: l, getWireframeAttribute: u };
}
function vy(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function a(f) {
    r = f;
  }
  let o, l;
  function c(f) {
    (o = f.type), (l = f.bytesPerElement);
  }
  function u(f, h) {
    s.drawElements(r, h, o, f * l), t.update(h, r, 1);
  }
  function d(f, h, _) {
    if (_ === 0) return;
    let m, g;
    if (i) (m = s), (g = "drawElementsInstanced");
    else if (
      ((m = e.get("ANGLE_instanced_arrays")),
      (g = "drawElementsInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    m[g](r, h, o, f * l, _), t.update(h, r, _);
  }
  (this.setMode = a),
    (this.setIndex = c),
    (this.render = u),
    (this.renderInstances = d);
}
function xy(s) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(r, a, o) {
    switch ((t.calls++, a)) {
      case 4:
        t.triangles += o * (r / 3);
        break;
      case 1:
        t.lines += o * (r / 2);
        break;
      case 3:
        t.lines += o * (r - 1);
        break;
      case 2:
        t.lines += o * r;
        break;
      case 0:
        t.points += o * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function yy(s, e) {
  return s[0] - e[0];
}
function Sy(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1]);
}
function My(s, e, t) {
  const n = {},
    i = new Float32Array(8),
    r = new WeakMap(),
    a = new Ye(),
    o = [];
  for (let c = 0; c < 8; c++) o[c] = [c, 0];
  function l(c, u, d) {
    const f = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const _ =
          u.morphAttributes.position ||
          u.morphAttributes.normal ||
          u.morphAttributes.color,
        m = _ !== void 0 ? _.length : 0;
      let g = r.get(u);
      if (g === void 0 || g.count !== m) {
        let U = function () {
          P.dispose(), r.delete(u), u.removeEventListener("dispose", U);
        };
        var h = U;
        g !== void 0 && g.texture.dispose();
        const v = u.morphAttributes.position !== void 0,
          x = u.morphAttributes.normal !== void 0,
          S = u.morphAttributes.color !== void 0,
          w = u.morphAttributes.position || [],
          A = u.morphAttributes.normal || [],
          C = u.morphAttributes.color || [];
        let M = 0;
        v === !0 && (M = 1), x === !0 && (M = 2), S === !0 && (M = 3);
        let b = u.attributes.position.count * M,
          R = 1;
        b > e.maxTextureSize &&
          ((R = Math.ceil(b / e.maxTextureSize)), (b = e.maxTextureSize));
        const D = new Float32Array(b * R * 4 * m),
          P = new ch(D, b, R, m);
        (P.type = mi), (P.needsUpdate = !0);
        const I = M * 4;
        for (let H = 0; H < m; H++) {
          const Y = w[H],
            B = A[H],
            Q = C[H],
            Z = b * R * 4 * H;
          for (let me = 0; me < Y.count; me++) {
            const te = me * I;
            v === !0 &&
              (a.fromBufferAttribute(Y, me),
              (D[Z + te + 0] = a.x),
              (D[Z + te + 1] = a.y),
              (D[Z + te + 2] = a.z),
              (D[Z + te + 3] = 0)),
              x === !0 &&
                (a.fromBufferAttribute(B, me),
                (D[Z + te + 4] = a.x),
                (D[Z + te + 5] = a.y),
                (D[Z + te + 6] = a.z),
                (D[Z + te + 7] = 0)),
              S === !0 &&
                (a.fromBufferAttribute(Q, me),
                (D[Z + te + 8] = a.x),
                (D[Z + te + 9] = a.y),
                (D[Z + te + 10] = a.z),
                (D[Z + te + 11] = Q.itemSize === 4 ? a.w : 1));
          }
        }
        (g = { count: m, texture: P, size: new Ne(b, R) }),
          r.set(u, g),
          u.addEventListener("dispose", U);
      }
      let p = 0;
      for (let v = 0; v < f.length; v++) p += f[v];
      const y = u.morphTargetsRelative ? 1 : 1 - p;
      d.getUniforms().setValue(s, "morphTargetBaseInfluence", y),
        d.getUniforms().setValue(s, "morphTargetInfluences", f),
        d.getUniforms().setValue(s, "morphTargetsTexture", g.texture, t),
        d.getUniforms().setValue(s, "morphTargetsTextureSize", g.size);
    } else {
      const _ = f === void 0 ? 0 : f.length;
      let m = n[u.id];
      if (m === void 0 || m.length !== _) {
        m = [];
        for (let x = 0; x < _; x++) m[x] = [x, 0];
        n[u.id] = m;
      }
      for (let x = 0; x < _; x++) {
        const S = m[x];
        (S[0] = x), (S[1] = f[x]);
      }
      m.sort(Sy);
      for (let x = 0; x < 8; x++)
        x < _ && m[x][1]
          ? ((o[x][0] = m[x][0]), (o[x][1] = m[x][1]))
          : ((o[x][0] = Number.MAX_SAFE_INTEGER), (o[x][1] = 0));
      o.sort(yy);
      const g = u.morphAttributes.position,
        p = u.morphAttributes.normal;
      let y = 0;
      for (let x = 0; x < 8; x++) {
        const S = o[x],
          w = S[0],
          A = S[1];
        w !== Number.MAX_SAFE_INTEGER && A
          ? (g &&
              u.getAttribute("morphTarget" + x) !== g[w] &&
              u.setAttribute("morphTarget" + x, g[w]),
            p &&
              u.getAttribute("morphNormal" + x) !== p[w] &&
              u.setAttribute("morphNormal" + x, p[w]),
            (i[x] = A),
            (y += A))
          : (g &&
              u.hasAttribute("morphTarget" + x) === !0 &&
              u.deleteAttribute("morphTarget" + x),
            p &&
              u.hasAttribute("morphNormal" + x) === !0 &&
              u.deleteAttribute("morphNormal" + x),
            (i[x] = 0));
      }
      const v = u.morphTargetsRelative ? 1 : 1 - y;
      d.getUniforms().setValue(s, "morphTargetBaseInfluence", v),
        d.getUniforms().setValue(s, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function by(s, e, t, n) {
  let i = new WeakMap();
  function r(l) {
    const c = n.render.frame,
      u = l.geometry,
      d = e.get(l, u);
    return (
      i.get(d) !== c && (e.update(d), i.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
      d
    );
  }
  function a() {
    i = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: r, dispose: a };
}
const _h = new yt(),
  vh = new ch(),
  xh = new f0(),
  yh = new mh(),
  Uu = [],
  Fu = [],
  ku = new Float32Array(16),
  zu = new Float32Array(9),
  Bu = new Float32Array(4);
function Zr(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0) return s;
  const i = e * t;
  let r = Uu[i];
  if ((r === void 0 && ((r = new Float32Array(i)), (Uu[i] = r)), e !== 0)) {
    n.toArray(r, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += t), s[a].toArray(r, o);
  }
  return r;
}
function ut(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return !1;
  return !0;
}
function dt(s, e) {
  for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
}
function Ha(s, e) {
  let t = Fu[e];
  t === void 0 && ((t = new Int32Array(e)), (Fu[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
  return t;
}
function wy(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), (t[0] = e));
}
function Ty(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ut(t, e)) return;
    s.uniform2fv(this.addr, e), dt(t, e);
  }
}
function Ey(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (s.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (ut(t, e)) return;
    s.uniform3fv(this.addr, e), dt(t, e);
  }
}
function Ay(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ut(t, e)) return;
    s.uniform4fv(this.addr, e), dt(t, e);
  }
}
function Cy(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (ut(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), dt(t, e);
  } else {
    if (ut(t, n)) return;
    Bu.set(n), s.uniformMatrix2fv(this.addr, !1, Bu), dt(t, n);
  }
}
function Py(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (ut(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), dt(t, e);
  } else {
    if (ut(t, n)) return;
    zu.set(n), s.uniformMatrix3fv(this.addr, !1, zu), dt(t, n);
  }
}
function Ly(s, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (ut(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), dt(t, e);
  } else {
    if (ut(t, n)) return;
    ku.set(n), s.uniformMatrix4fv(this.addr, !1, ku), dt(t, n);
  }
}
function Ry(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), (t[0] = e));
}
function Dy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ut(t, e)) return;
    s.uniform2iv(this.addr, e), dt(t, e);
  }
}
function Iy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (ut(t, e)) return;
    s.uniform3iv(this.addr, e), dt(t, e);
  }
}
function Oy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ut(t, e)) return;
    s.uniform4iv(this.addr, e), dt(t, e);
  }
}
function Ny(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), (t[0] = e));
}
function Uy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (s.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ut(t, e)) return;
    s.uniform2uiv(this.addr, e), dt(t, e);
  }
}
function Fy(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (s.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (ut(t, e)) return;
    s.uniform3uiv(this.addr, e), dt(t, e);
  }
}
function ky(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ut(t, e)) return;
    s.uniform4uiv(this.addr, e), dt(t, e);
  }
}
function zy(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2D(e || _h, i);
}
function By(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || xh, i);
}
function Vy(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || yh, i);
}
function Gy(s, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || vh, i);
}
function Hy(s) {
  switch (s) {
    case 5126:
      return wy;
    case 35664:
      return Ty;
    case 35665:
      return Ey;
    case 35666:
      return Ay;
    case 35674:
      return Cy;
    case 35675:
      return Py;
    case 35676:
      return Ly;
    case 5124:
    case 35670:
      return Ry;
    case 35667:
    case 35671:
      return Dy;
    case 35668:
    case 35672:
      return Iy;
    case 35669:
    case 35673:
      return Oy;
    case 5125:
      return Ny;
    case 36294:
      return Uy;
    case 36295:
      return Fy;
    case 36296:
      return ky;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return zy;
    case 35679:
    case 36299:
    case 36307:
      return By;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Vy;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Gy;
  }
}
function Wy(s, e) {
  s.uniform1fv(this.addr, e);
}
function qy(s, e) {
  const t = Zr(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function Xy(s, e) {
  const t = Zr(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function jy(s, e) {
  const t = Zr(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function Yy(s, e) {
  const t = Zr(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function $y(s, e) {
  const t = Zr(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function Ky(s, e) {
  const t = Zr(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function Zy(s, e) {
  s.uniform1iv(this.addr, e);
}
function Jy(s, e) {
  s.uniform2iv(this.addr, e);
}
function Qy(s, e) {
  s.uniform3iv(this.addr, e);
}
function eS(s, e) {
  s.uniform4iv(this.addr, e);
}
function tS(s, e) {
  s.uniform1uiv(this.addr, e);
}
function nS(s, e) {
  s.uniform2uiv(this.addr, e);
}
function iS(s, e) {
  s.uniform3uiv(this.addr, e);
}
function rS(s, e) {
  s.uniform4uiv(this.addr, e);
}
function sS(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = Ha(t, i);
  ut(n, r) || (s.uniform1iv(this.addr, r), dt(n, r));
  for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || _h, r[a]);
}
function aS(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = Ha(t, i);
  ut(n, r) || (s.uniform1iv(this.addr, r), dt(n, r));
  for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || xh, r[a]);
}
function oS(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = Ha(t, i);
  ut(n, r) || (s.uniform1iv(this.addr, r), dt(n, r));
  for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || yh, r[a]);
}
function lS(s, e, t) {
  const n = this.cache,
    i = e.length,
    r = Ha(t, i);
  ut(n, r) || (s.uniform1iv(this.addr, r), dt(n, r));
  for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || vh, r[a]);
}
function cS(s) {
  switch (s) {
    case 5126:
      return Wy;
    case 35664:
      return qy;
    case 35665:
      return Xy;
    case 35666:
      return jy;
    case 35674:
      return Yy;
    case 35675:
      return $y;
    case 35676:
      return Ky;
    case 5124:
    case 35670:
      return Zy;
    case 35667:
    case 35671:
      return Jy;
    case 35668:
    case 35672:
      return Qy;
    case 35669:
    case 35673:
      return eS;
    case 5125:
      return tS;
    case 36294:
      return nS;
    case 36295:
      return iS;
    case 36296:
      return rS;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return sS;
    case 35679:
    case 36299:
    case 36307:
      return aS;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return oS;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return lS;
  }
}
class uS {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = Hy(t.type));
  }
}
class dS {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = cS(t.type));
  }
}
class fS {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let r = 0, a = i.length; r !== a; ++r) {
      const o = i[r];
      o.setValue(e, t[o.id], n);
    }
  }
}
const ko = /(\w+)(\])?(\[|\.)?/g;
function Vu(s, e) {
  s.seq.push(e), (s.map[e.id] = e);
}
function hS(s, e, t) {
  const n = s.name,
    i = n.length;
  for (ko.lastIndex = 0; ; ) {
    const r = ko.exec(n),
      a = ko.lastIndex;
    let o = r[1];
    const l = r[2] === "]",
      c = r[3];
    if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === i))) {
      Vu(t, c === void 0 ? new uS(o, s, e) : new dS(o, s, e));
      break;
    } else {
      let d = t.map[o];
      d === void 0 && ((d = new fS(o)), Vu(t, d)), (t = d);
    }
  }
}
class Sa {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, 35718);
    for (let i = 0; i < n; ++i) {
      const r = e.getActiveUniform(t, i),
        a = e.getUniformLocation(t, r.name);
      hS(r, a, this);
    }
  }
  setValue(e, t, n, i) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let r = 0, a = t.length; r !== a; ++r) {
      const o = t[r],
        l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function Gu(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
let pS = 0;
function mS(s, e) {
  const t = s.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    r = Math.min(e + 6, t.length);
  for (let a = i; a < r; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
function gS(s) {
  switch (s) {
    case Ji:
      return ["Linear", "( value )"];
    case ze:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", s),
        ["Linear", "( value )"]
      );
  }
}
function Hu(s, e, t) {
  const n = s.getShaderParameter(e, 35713),
    i = s.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(i);
  if (r) {
    const a = parseInt(r[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      mS(s.getShaderSource(e), a)
    );
  } else return i;
}
function _S(s, e) {
  const t = gS(e);
  return "vec4 " + s + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function vS(s, e) {
  let t;
  switch (e) {
    case y_:
      t = "Linear";
      break;
    case Zf:
      t = "Reinhard";
      break;
    case S_:
      t = "OptimizedCineon";
      break;
    case M_:
      t = "ACESFilmic";
      break;
    case b_:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function xS(s) {
  return [
    s.extensionDerivatives ||
    !!s.envMapCubeUVHeight ||
    s.bumpMap ||
    s.normalMapTangentSpace ||
    s.clearcoatNormalMap ||
    s.flatShading ||
    s.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
    s.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) &&
    s.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(ps).join(`
`);
}
function yS(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function SS(s, e) {
  const t = {},
    n = s.getProgramParameter(e, 35721);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i),
      a = r.name;
    let o = 1;
    r.type === 35674 && (o = 2),
      r.type === 35675 && (o = 3),
      r.type === 35676 && (o = 4),
      (t[a] = {
        type: r.type,
        location: s.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return t;
}
function ps(s) {
  return s !== "";
}
function Wu(s, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function qu(s, e) {
  return s
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const MS = /^[ \t]*#include +<([\w\d./]+)>/gm;
function _l(s) {
  return s.replace(MS, bS);
}
function bS(s, e) {
  const t = Ae[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return _l(t);
}
const wS =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Xu(s) {
  return s.replace(wS, TS);
}
function TS(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function ju(s) {
  let e =
    "precision " +
    s.precision +
    ` float;
precision ` +
    s.precision +
    " int;";
  return (
    s.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : s.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : s.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function ES(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    s.shadowMapType === Xf
      ? (e = "SHADOWMAP_TYPE_PCF")
      : s.shadowMapType === jf
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : s.shadowMapType === hs && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function AS(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Gr:
      case Hr:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ka:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function CS(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Hr:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function PS(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case Kf:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case v_:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case x_:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function LS(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function RS(s, e, t, n) {
  const i = s.getContext(),
    r = t.defines;
  let a = t.vertexShader,
    o = t.fragmentShader;
  const l = ES(t),
    c = AS(t),
    u = CS(t),
    d = PS(t),
    f = LS(t),
    h = t.isWebGL2 ? "" : xS(t),
    _ = yS(r),
    m = i.createProgram();
  let g,
    p,
    y = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((g = [_].filter(ps).join(`
`)),
      g.length > 0 &&
        (g += `
`),
      (p = [h, _].filter(ps).join(`
`)),
      p.length > 0 &&
        (p += `
`))
    : ((g = [
        ju(t),
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.vertexUvs2 ? "#define USE_UV2" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(ps).join(`
`)),
      (p = [
        h,
        ju(t),
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + d : "",
        f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
        f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
        f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs2 ? "#define USE_UV2" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== jn ? "#define TONE_MAPPING" : "",
        t.toneMapping !== jn ? Ae.tonemapping_pars_fragment : "",
        t.toneMapping !== jn ? vS("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Ae.encodings_pars_fragment,
        _S("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(ps).join(`
`))),
    (a = _l(a)),
    (a = Wu(a, t)),
    (a = qu(a, t)),
    (o = _l(o)),
    (o = Wu(o, t)),
    (o = qu(o, t)),
    (a = Xu(a)),
    (o = Xu(o)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (g =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        g),
      (p =
        [
          "#define varying in",
          t.glslVersion === hu
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === hu ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        p));
  const v = y + g + a,
    x = y + p + o,
    S = Gu(i, 35633, v),
    w = Gu(i, 35632, x);
  if (
    (i.attachShader(m, S),
    i.attachShader(m, w),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(m, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"),
    i.linkProgram(m),
    s.debug.checkShaderErrors)
  ) {
    const M = i.getProgramInfoLog(m).trim(),
      b = i.getShaderInfoLog(S).trim(),
      R = i.getShaderInfoLog(w).trim();
    let D = !0,
      P = !0;
    if (i.getProgramParameter(m, 35714) === !1)
      if (((D = !1), typeof s.debug.onShaderError == "function"))
        s.debug.onShaderError(i, m, S, w);
      else {
        const I = Hu(i, S, "vertex"),
          U = Hu(i, w, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            i.getError() +
            " - VALIDATE_STATUS " +
            i.getProgramParameter(m, 35715) +
            `

Program Info Log: ` +
            M +
            `
` +
            I +
            `
` +
            U
        );
      }
    else
      M !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", M)
        : (b === "" || R === "") && (P = !1);
    P &&
      (this.diagnostics = {
        runnable: D,
        programLog: M,
        vertexShader: { log: b, prefix: g },
        fragmentShader: { log: R, prefix: p },
      });
  }
  i.deleteShader(S), i.deleteShader(w);
  let A;
  this.getUniforms = function () {
    return A === void 0 && (A = new Sa(i, m)), A;
  };
  let C;
  return (
    (this.getAttributes = function () {
      return C === void 0 && (C = SS(i, m)), C;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(m),
        (this.program = void 0);
    }),
    (this.name = t.shaderName),
    (this.id = pS++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = S),
    (this.fragmentShader = w),
    this
  );
}
let DS = 0;
class IS {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      r = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(i) === !1 && (a.add(i), i.usedTimes++),
      a.has(r) === !1 && (a.add(r), r.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new OS(e)), t.set(e, n)), n;
  }
}
class OS {
  constructor(e) {
    (this.id = DS++), (this.code = e), (this.usedTimes = 0);
  }
}
function NS(s, e, t, n, i, r, a) {
  const o = new $l(),
    l = new IS(),
    c = [],
    u = i.isWebGL2,
    d = i.logarithmicDepthBuffer,
    f = i.vertexTextures;
  let h = i.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function m(M) {
    return M === 1 ? "uv2" : "uv";
  }
  function g(M, b, R, D, P) {
    const I = D.fog,
      U = P.geometry,
      H = M.isMeshStandardMaterial ? D.environment : null,
      Y = (M.isMeshStandardMaterial ? t : e).get(M.envMap || H),
      B = !!Y && Y.mapping === ka ? Y.image.height : null,
      Q = _[M.type];
    M.precision !== null &&
      ((h = i.getMaxPrecision(M.precision)),
      h !== M.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          M.precision,
          "not supported, using",
          h,
          "instead."
        ));
    const Z =
        U.morphAttributes.position ||
        U.morphAttributes.normal ||
        U.morphAttributes.color,
      me = Z !== void 0 ? Z.length : 0;
    let te = 0;
    U.morphAttributes.position !== void 0 && (te = 1),
      U.morphAttributes.normal !== void 0 && (te = 2),
      U.morphAttributes.color !== void 0 && (te = 3);
    let V, K, ie, oe;
    if (Q) {
      const de = Mn[Q];
      (V = de.vertexShader), (K = de.fragmentShader);
    } else
      (V = M.vertexShader),
        (K = M.fragmentShader),
        l.update(M),
        (ie = l.getVertexShaderID(M)),
        (oe = l.getFragmentShaderID(M));
    const z = s.getRenderTarget(),
      we = P.isInstancedMesh === !0,
      Me = !!M.map,
      se = !!M.matcap,
      xe = !!Y,
      Be = !!M.aoMap,
      pe = !!M.lightMap,
      Re = !!M.bumpMap,
      ft = !!M.normalMap,
      xt = !!M.displacementMap,
      ht = !!M.emissiveMap,
      ct = !!M.metalnessMap,
      Ve = !!M.roughnessMap,
      et = M.clearcoat > 0,
      Ut = M.iridescence > 0,
      L = M.sheen > 0,
      T = M.transmission > 0,
      G = et && !!M.clearcoatMap,
      ee = et && !!M.clearcoatNormalMap,
      ne = et && !!M.clearcoatRoughnessMap,
      ae = Ut && !!M.iridescenceMap,
      ye = Ut && !!M.iridescenceThicknessMap,
      ue = L && !!M.sheenColorMap,
      X = L && !!M.sheenRoughnessMap,
      fe = !!M.specularMap,
      ge = !!M.specularColorMap,
      ve = !!M.specularIntensityMap,
      ce = T && !!M.transmissionMap,
      he = T && !!M.thicknessMap,
      Ue = !!M.gradientMap,
      He = !!M.alphaMap,
      it = M.alphaTest > 0,
      O = !!M.extensions,
      q = !!U.attributes.uv,
      J = !!U.attributes.uv2;
    return {
      isWebGL2: u,
      shaderID: Q,
      shaderName: M.type,
      vertexShader: V,
      fragmentShader: K,
      defines: M.defines,
      customVertexShaderID: ie,
      customFragmentShaderID: oe,
      isRawShaderMaterial: M.isRawShaderMaterial === !0,
      glslVersion: M.glslVersion,
      precision: h,
      instancing: we,
      instancingColor: we && P.instanceColor !== null,
      supportsVertexTextures: f,
      outputEncoding:
        z === null
          ? s.outputEncoding
          : z.isXRRenderTarget === !0
          ? z.texture.encoding
          : Ji,
      map: Me,
      matcap: se,
      envMap: xe,
      envMapMode: xe && Y.mapping,
      envMapCubeUVHeight: B,
      aoMap: Be,
      lightMap: pe,
      bumpMap: Re,
      normalMap: ft,
      displacementMap: f && xt,
      emissiveMap: ht,
      normalMapObjectSpace: ft && M.normalMapType === H_,
      normalMapTangentSpace: ft && M.normalMapType === nh,
      decodeVideoTexture:
        Me && M.map.isVideoTexture === !0 && M.map.encoding === ze,
      metalnessMap: ct,
      roughnessMap: Ve,
      clearcoat: et,
      clearcoatMap: G,
      clearcoatNormalMap: ee,
      clearcoatRoughnessMap: ne,
      iridescence: Ut,
      iridescenceMap: ae,
      iridescenceThicknessMap: ye,
      sheen: L,
      sheenColorMap: ue,
      sheenRoughnessMap: X,
      specularMap: fe,
      specularColorMap: ge,
      specularIntensityMap: ve,
      transmission: T,
      transmissionMap: ce,
      thicknessMap: he,
      gradientMap: Ue,
      opaque: M.transparent === !1 && M.blending === Ir,
      alphaMap: He,
      alphaTest: it,
      combine: M.combine,
      mapUv: Me && m(M.map.channel),
      aoMapUv: Be && m(M.aoMap.channel),
      lightMapUv: pe && m(M.lightMap.channel),
      bumpMapUv: Re && m(M.bumpMap.channel),
      normalMapUv: ft && m(M.normalMap.channel),
      displacementMapUv: xt && m(M.displacementMap.channel),
      emissiveMapUv: ht && m(M.emissiveMap.channel),
      metalnessMapUv: ct && m(M.metalnessMap.channel),
      roughnessMapUv: Ve && m(M.roughnessMap.channel),
      clearcoatMapUv: G && m(M.clearcoatMap.channel),
      clearcoatNormalMapUv: ee && m(M.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ne && m(M.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ae && m(M.iridescenceMap.channel),
      iridescenceThicknessMapUv: ye && m(M.iridescenceThicknessMap.channel),
      sheenColorMapUv: ue && m(M.sheenColorMap.channel),
      sheenRoughnessMapUv: X && m(M.sheenRoughnessMap.channel),
      specularMapUv: fe && m(M.specularMap.channel),
      specularColorMapUv: ge && m(M.specularColorMap.channel),
      specularIntensityMapUv: ve && m(M.specularIntensityMap.channel),
      transmissionMapUv: ce && m(M.transmissionMap.channel),
      thicknessMapUv: he && m(M.thicknessMap.channel),
      alphaMapUv: He && m(M.alphaMap.channel),
      vertexTangents: ft && !!U.attributes.tangent,
      vertexColors: M.vertexColors,
      vertexAlphas:
        M.vertexColors === !0 &&
        !!U.attributes.color &&
        U.attributes.color.itemSize === 4,
      vertexUvs: q,
      vertexUvs2: J,
      pointsUvs: P.isPoints === !0 && !!U.attributes.uv && (Me || He),
      fog: !!I,
      useFog: M.fog === !0,
      fogExp2: I && I.isFogExp2,
      flatShading: M.flatShading === !0,
      sizeAttenuation: M.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: P.isSkinnedMesh === !0,
      morphTargets: U.morphAttributes.position !== void 0,
      morphNormals: U.morphAttributes.normal !== void 0,
      morphColors: U.morphAttributes.color !== void 0,
      morphTargetsCount: me,
      morphTextureStride: te,
      numDirLights: b.directional.length,
      numPointLights: b.point.length,
      numSpotLights: b.spot.length,
      numSpotLightMaps: b.spotLightMap.length,
      numRectAreaLights: b.rectArea.length,
      numHemiLights: b.hemi.length,
      numDirLightShadows: b.directionalShadowMap.length,
      numPointLightShadows: b.pointShadowMap.length,
      numSpotLightShadows: b.spotShadowMap.length,
      numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: M.dithering,
      shadowMapEnabled: s.shadowMap.enabled && R.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: M.toneMapped ? s.toneMapping : jn,
      useLegacyLights: s.useLegacyLights,
      premultipliedAlpha: M.premultipliedAlpha,
      doubleSided: M.side === wn,
      flipSided: M.side === Gt,
      useDepthPacking: M.depthPacking >= 0,
      depthPacking: M.depthPacking || 0,
      index0AttributeName: M.index0AttributeName,
      extensionDerivatives: O && M.extensions.derivatives === !0,
      extensionFragDepth: O && M.extensions.fragDepth === !0,
      extensionDrawBuffers: O && M.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: O && M.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: M.customProgramCacheKey(),
    };
  }
  function p(M) {
    const b = [];
    if (
      (M.shaderID
        ? b.push(M.shaderID)
        : (b.push(M.customVertexShaderID), b.push(M.customFragmentShaderID)),
      M.defines !== void 0)
    )
      for (const R in M.defines) b.push(R), b.push(M.defines[R]);
    return (
      M.isRawShaderMaterial === !1 &&
        (y(b, M), v(b, M), b.push(s.outputEncoding)),
      b.push(M.customProgramCacheKey),
      b.join()
    );
  }
  function y(M, b) {
    M.push(b.precision),
      M.push(b.outputEncoding),
      M.push(b.envMapMode),
      M.push(b.envMapCubeUVHeight),
      M.push(b.mapUv),
      M.push(b.alphaMapUv),
      M.push(b.lightMapUv),
      M.push(b.aoMapUv),
      M.push(b.bumpMapUv),
      M.push(b.normalMapUv),
      M.push(b.displacementMapUv),
      M.push(b.emissiveMapUv),
      M.push(b.metalnessMapUv),
      M.push(b.roughnessMapUv),
      M.push(b.clearcoatMapUv),
      M.push(b.clearcoatNormalMapUv),
      M.push(b.clearcoatRoughnessMapUv),
      M.push(b.iridescenceMapUv),
      M.push(b.iridescenceThicknessMapUv),
      M.push(b.sheenColorMapUv),
      M.push(b.sheenRoughnessMapUv),
      M.push(b.specularMapUv),
      M.push(b.specularColorMapUv),
      M.push(b.specularIntensityMapUv),
      M.push(b.transmissionMapUv),
      M.push(b.thicknessMapUv),
      M.push(b.combine),
      M.push(b.fogExp2),
      M.push(b.sizeAttenuation),
      M.push(b.morphTargetsCount),
      M.push(b.morphAttributeCount),
      M.push(b.numDirLights),
      M.push(b.numPointLights),
      M.push(b.numSpotLights),
      M.push(b.numSpotLightMaps),
      M.push(b.numHemiLights),
      M.push(b.numRectAreaLights),
      M.push(b.numDirLightShadows),
      M.push(b.numPointLightShadows),
      M.push(b.numSpotLightShadows),
      M.push(b.numSpotLightShadowsWithMaps),
      M.push(b.shadowMapType),
      M.push(b.toneMapping),
      M.push(b.numClippingPlanes),
      M.push(b.numClipIntersection),
      M.push(b.depthPacking);
  }
  function v(M, b) {
    o.disableAll(),
      b.isWebGL2 && o.enable(0),
      b.supportsVertexTextures && o.enable(1),
      b.instancing && o.enable(2),
      b.instancingColor && o.enable(3),
      b.matcap && o.enable(4),
      b.envMap && o.enable(5),
      b.normalMapObjectSpace && o.enable(6),
      b.normalMapTangentSpace && o.enable(7),
      b.clearcoat && o.enable(8),
      b.iridescence && o.enable(9),
      b.alphaTest && o.enable(10),
      b.vertexColors && o.enable(11),
      b.vertexAlphas && o.enable(12),
      b.vertexUvs && o.enable(13),
      b.vertexUvs2 && o.enable(14),
      b.vertexTangents && o.enable(15),
      M.push(o.mask),
      o.disableAll(),
      b.fog && o.enable(0),
      b.useFog && o.enable(1),
      b.flatShading && o.enable(2),
      b.logarithmicDepthBuffer && o.enable(3),
      b.skinning && o.enable(4),
      b.morphTargets && o.enable(5),
      b.morphNormals && o.enable(6),
      b.morphColors && o.enable(7),
      b.premultipliedAlpha && o.enable(8),
      b.shadowMapEnabled && o.enable(9),
      b.useLegacyLights && o.enable(10),
      b.doubleSided && o.enable(11),
      b.flipSided && o.enable(12),
      b.useDepthPacking && o.enable(13),
      b.dithering && o.enable(14),
      b.transmission && o.enable(15),
      b.sheen && o.enable(16),
      b.decodeVideoTexture && o.enable(17),
      b.opaque && o.enable(18),
      b.pointsUvs && o.enable(19),
      M.push(o.mask);
  }
  function x(M) {
    const b = _[M.type];
    let R;
    if (b) {
      const D = Mn[b];
      R = w0.clone(D.uniforms);
    } else R = M.uniforms;
    return R;
  }
  function S(M, b) {
    let R;
    for (let D = 0, P = c.length; D < P; D++) {
      const I = c[D];
      if (I.cacheKey === b) {
        (R = I), ++R.usedTimes;
        break;
      }
    }
    return R === void 0 && ((R = new RS(s, b, M, r)), c.push(R)), R;
  }
  function w(M) {
    if (--M.usedTimes === 0) {
      const b = c.indexOf(M);
      (c[b] = c[c.length - 1]), c.pop(), M.destroy();
    }
  }
  function A(M) {
    l.remove(M);
  }
  function C() {
    l.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: p,
    getUniforms: x,
    acquireProgram: S,
    releaseProgram: w,
    releaseShaderCache: A,
    programs: c,
    dispose: C,
  };
}
function US() {
  let s = new WeakMap();
  function e(r) {
    let a = s.get(r);
    return a === void 0 && ((a = {}), s.set(r, a)), a;
  }
  function t(r) {
    s.delete(r);
  }
  function n(r, a, o) {
    s.get(r)[a] = o;
  }
  function i() {
    s = new WeakMap();
  }
  return { get: e, remove: t, update: n, dispose: i };
}
function FS(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.material.id !== e.material.id
    ? s.material.id - e.material.id
    : s.z !== e.z
    ? s.z - e.z
    : s.id - e.id;
}
function Yu(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.z !== e.z
    ? e.z - s.z
    : s.id - e.id;
}
function $u() {
  const s = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function r() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function a(d, f, h, _, m, g) {
    let p = s[e];
    return (
      p === void 0
        ? ((p = {
            id: d.id,
            object: d,
            geometry: f,
            material: h,
            groupOrder: _,
            renderOrder: d.renderOrder,
            z: m,
            group: g,
          }),
          (s[e] = p))
        : ((p.id = d.id),
          (p.object = d),
          (p.geometry = f),
          (p.material = h),
          (p.groupOrder = _),
          (p.renderOrder = d.renderOrder),
          (p.z = m),
          (p.group = g)),
      e++,
      p
    );
  }
  function o(d, f, h, _, m, g) {
    const p = a(d, f, h, _, m, g);
    h.transmission > 0
      ? n.push(p)
      : h.transparent === !0
      ? i.push(p)
      : t.push(p);
  }
  function l(d, f, h, _, m, g) {
    const p = a(d, f, h, _, m, g);
    h.transmission > 0
      ? n.unshift(p)
      : h.transparent === !0
      ? i.unshift(p)
      : t.unshift(p);
  }
  function c(d, f) {
    t.length > 1 && t.sort(d || FS),
      n.length > 1 && n.sort(f || Yu),
      i.length > 1 && i.sort(f || Yu);
  }
  function u() {
    for (let d = e, f = s.length; d < f; d++) {
      const h = s[d];
      if (h.id === null) break;
      (h.id = null),
        (h.object = null),
        (h.geometry = null),
        (h.material = null),
        (h.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: o,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function kS() {
  let s = new WeakMap();
  function e(n, i) {
    const r = s.get(n);
    let a;
    return (
      r === void 0
        ? ((a = new $u()), s.set(n, [a]))
        : i >= r.length
        ? ((a = new $u()), r.push(a))
        : (a = r[i]),
      a
    );
  }
  function t() {
    s = new WeakMap();
  }
  return { get: e, dispose: t };
}
function zS() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new N(), color: new Te() };
          break;
        case "SpotLight":
          t = {
            position: new N(),
            direction: new N(),
            color: new Te(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new N(), color: new Te(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new N(), skyColor: new Te(), groundColor: new Te() };
          break;
        case "RectAreaLight":
          t = {
            color: new Te(),
            position: new N(),
            halfWidth: new N(),
            halfHeight: new N(),
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
function BS() {
  const s = {};
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ne(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ne(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ne(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (s[e.id] = t), t;
    },
  };
}
let VS = 0;
function GS(s, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (s.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (s.map ? 1 : 0)
  );
}
function HS(s, e) {
  const t = new zS(),
    n = BS(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let u = 0; u < 9; u++) i.probe.push(new N());
  const r = new N(),
    a = new Le(),
    o = new Le();
  function l(u, d) {
    let f = 0,
      h = 0,
      _ = 0;
    for (let R = 0; R < 9; R++) i.probe[R].set(0, 0, 0);
    let m = 0,
      g = 0,
      p = 0,
      y = 0,
      v = 0,
      x = 0,
      S = 0,
      w = 0,
      A = 0,
      C = 0;
    u.sort(GS);
    const M = d === !0 ? Math.PI : 1;
    for (let R = 0, D = u.length; R < D; R++) {
      const P = u[R],
        I = P.color,
        U = P.intensity,
        H = P.distance,
        Y = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
      if (P.isAmbientLight)
        (f += I.r * U * M), (h += I.g * U * M), (_ += I.b * U * M);
      else if (P.isLightProbe)
        for (let B = 0; B < 9; B++)
          i.probe[B].addScaledVector(P.sh.coefficients[B], U);
      else if (P.isDirectionalLight) {
        const B = t.get(P);
        if (
          (B.color.copy(P.color).multiplyScalar(P.intensity * M), P.castShadow)
        ) {
          const Q = P.shadow,
            Z = n.get(P);
          (Z.shadowBias = Q.bias),
            (Z.shadowNormalBias = Q.normalBias),
            (Z.shadowRadius = Q.radius),
            (Z.shadowMapSize = Q.mapSize),
            (i.directionalShadow[m] = Z),
            (i.directionalShadowMap[m] = Y),
            (i.directionalShadowMatrix[m] = P.shadow.matrix),
            x++;
        }
        (i.directional[m] = B), m++;
      } else if (P.isSpotLight) {
        const B = t.get(P);
        B.position.setFromMatrixPosition(P.matrixWorld),
          B.color.copy(I).multiplyScalar(U * M),
          (B.distance = H),
          (B.coneCos = Math.cos(P.angle)),
          (B.penumbraCos = Math.cos(P.angle * (1 - P.penumbra))),
          (B.decay = P.decay),
          (i.spot[p] = B);
        const Q = P.shadow;
        if (
          (P.map &&
            ((i.spotLightMap[A] = P.map),
            A++,
            Q.updateMatrices(P),
            P.castShadow && C++),
          (i.spotLightMatrix[p] = Q.matrix),
          P.castShadow)
        ) {
          const Z = n.get(P);
          (Z.shadowBias = Q.bias),
            (Z.shadowNormalBias = Q.normalBias),
            (Z.shadowRadius = Q.radius),
            (Z.shadowMapSize = Q.mapSize),
            (i.spotShadow[p] = Z),
            (i.spotShadowMap[p] = Y),
            w++;
        }
        p++;
      } else if (P.isRectAreaLight) {
        const B = t.get(P);
        B.color.copy(I).multiplyScalar(U),
          B.halfWidth.set(P.width * 0.5, 0, 0),
          B.halfHeight.set(0, P.height * 0.5, 0),
          (i.rectArea[y] = B),
          y++;
      } else if (P.isPointLight) {
        const B = t.get(P);
        if (
          (B.color.copy(P.color).multiplyScalar(P.intensity * M),
          (B.distance = P.distance),
          (B.decay = P.decay),
          P.castShadow)
        ) {
          const Q = P.shadow,
            Z = n.get(P);
          (Z.shadowBias = Q.bias),
            (Z.shadowNormalBias = Q.normalBias),
            (Z.shadowRadius = Q.radius),
            (Z.shadowMapSize = Q.mapSize),
            (Z.shadowCameraNear = Q.camera.near),
            (Z.shadowCameraFar = Q.camera.far),
            (i.pointShadow[g] = Z),
            (i.pointShadowMap[g] = Y),
            (i.pointShadowMatrix[g] = P.shadow.matrix),
            S++;
        }
        (i.point[g] = B), g++;
      } else if (P.isHemisphereLight) {
        const B = t.get(P);
        B.skyColor.copy(P.color).multiplyScalar(U * M),
          B.groundColor.copy(P.groundColor).multiplyScalar(U * M),
          (i.hemi[v] = B),
          v++;
      }
    }
    y > 0 &&
      (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = re.LTC_FLOAT_1), (i.rectAreaLTC2 = re.LTC_FLOAT_2))
        : s.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = re.LTC_HALF_1), (i.rectAreaLTC2 = re.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = f),
      (i.ambient[1] = h),
      (i.ambient[2] = _);
    const b = i.hash;
    (b.directionalLength !== m ||
      b.pointLength !== g ||
      b.spotLength !== p ||
      b.rectAreaLength !== y ||
      b.hemiLength !== v ||
      b.numDirectionalShadows !== x ||
      b.numPointShadows !== S ||
      b.numSpotShadows !== w ||
      b.numSpotMaps !== A) &&
      ((i.directional.length = m),
      (i.spot.length = p),
      (i.rectArea.length = y),
      (i.point.length = g),
      (i.hemi.length = v),
      (i.directionalShadow.length = x),
      (i.directionalShadowMap.length = x),
      (i.pointShadow.length = S),
      (i.pointShadowMap.length = S),
      (i.spotShadow.length = w),
      (i.spotShadowMap.length = w),
      (i.directionalShadowMatrix.length = x),
      (i.pointShadowMatrix.length = S),
      (i.spotLightMatrix.length = w + A - C),
      (i.spotLightMap.length = A),
      (i.numSpotLightShadowsWithMaps = C),
      (b.directionalLength = m),
      (b.pointLength = g),
      (b.spotLength = p),
      (b.rectAreaLength = y),
      (b.hemiLength = v),
      (b.numDirectionalShadows = x),
      (b.numPointShadows = S),
      (b.numSpotShadows = w),
      (b.numSpotMaps = A),
      (i.version = VS++));
  }
  function c(u, d) {
    let f = 0,
      h = 0,
      _ = 0,
      m = 0,
      g = 0;
    const p = d.matrixWorldInverse;
    for (let y = 0, v = u.length; y < v; y++) {
      const x = u[y];
      if (x.isDirectionalLight) {
        const S = i.directional[f];
        S.direction.setFromMatrixPosition(x.matrixWorld),
          r.setFromMatrixPosition(x.target.matrixWorld),
          S.direction.sub(r),
          S.direction.transformDirection(p),
          f++;
      } else if (x.isSpotLight) {
        const S = i.spot[_];
        S.position.setFromMatrixPosition(x.matrixWorld),
          S.position.applyMatrix4(p),
          S.direction.setFromMatrixPosition(x.matrixWorld),
          r.setFromMatrixPosition(x.target.matrixWorld),
          S.direction.sub(r),
          S.direction.transformDirection(p),
          _++;
      } else if (x.isRectAreaLight) {
        const S = i.rectArea[m];
        S.position.setFromMatrixPosition(x.matrixWorld),
          S.position.applyMatrix4(p),
          o.identity(),
          a.copy(x.matrixWorld),
          a.premultiply(p),
          o.extractRotation(a),
          S.halfWidth.set(x.width * 0.5, 0, 0),
          S.halfHeight.set(0, x.height * 0.5, 0),
          S.halfWidth.applyMatrix4(o),
          S.halfHeight.applyMatrix4(o),
          m++;
      } else if (x.isPointLight) {
        const S = i.point[h];
        S.position.setFromMatrixPosition(x.matrixWorld),
          S.position.applyMatrix4(p),
          h++;
      } else if (x.isHemisphereLight) {
        const S = i.hemi[g];
        S.direction.setFromMatrixPosition(x.matrixWorld),
          S.direction.transformDirection(p),
          g++;
      }
    }
  }
  return { setup: l, setupView: c, state: i };
}
function Ku(s, e) {
  const t = new HS(s, e),
    n = [],
    i = [];
  function r() {
    (n.length = 0), (i.length = 0);
  }
  function a(d) {
    n.push(d);
  }
  function o(d) {
    i.push(d);
  }
  function l(d) {
    t.setup(n, d);
  }
  function c(d) {
    t.setupView(n, d);
  }
  return {
    init: r,
    state: { lightsArray: n, shadowsArray: i, lights: t },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o,
  };
}
function WS(s, e) {
  let t = new WeakMap();
  function n(r, a = 0) {
    const o = t.get(r);
    let l;
    return (
      o === void 0
        ? ((l = new Ku(s, e)), t.set(r, [l]))
        : a >= o.length
        ? ((l = new Ku(s, e)), o.push(l))
        : (l = o[a]),
      l
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
class qS extends Pn {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = V_),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class XS extends Pn {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const jS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  YS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function $S(s, e, t) {
  let n = new Kl();
  const i = new Ne(),
    r = new Ne(),
    a = new Ye(),
    o = new qS({ depthPacking: G_ }),
    l = new XS(),
    c = {},
    u = t.maxTextureSize,
    d = { [Zn]: Gt, [Gt]: Zn, [wn]: wn },
    f = new er({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ne() },
        radius: { value: 4 },
      },
      vertexShader: jS,
      fragmentShader: YS,
    }),
    h = f.clone();
  h.defines.HORIZONTAL_PASS = 1;
  const _ = new Rn();
  _.setAttribute(
    "position",
    new Nt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const m = new Jt(_, f),
    g = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Xf),
    (this.render = function (x, S, w) {
      if (
        g.enabled === !1 ||
        (g.autoUpdate === !1 && g.needsUpdate === !1) ||
        x.length === 0
      )
        return;
      const A = s.getRenderTarget(),
        C = s.getActiveCubeFace(),
        M = s.getActiveMipmapLevel(),
        b = s.state;
      b.setBlending(xi),
        b.buffers.color.setClear(1, 1, 1, 1),
        b.buffers.depth.setTest(!0),
        b.setScissorTest(!1);
      for (let R = 0, D = x.length; R < D; R++) {
        const P = x[R],
          I = P.shadow;
        if (I === void 0) {
          console.warn("THREE.WebGLShadowMap:", P, "has no shadow.");
          continue;
        }
        if (I.autoUpdate === !1 && I.needsUpdate === !1) continue;
        i.copy(I.mapSize);
        const U = I.getFrameExtents();
        if (
          (i.multiply(U),
          r.copy(I.mapSize),
          (i.x > u || i.y > u) &&
            (i.x > u &&
              ((r.x = Math.floor(u / U.x)),
              (i.x = r.x * U.x),
              (I.mapSize.x = r.x)),
            i.y > u &&
              ((r.y = Math.floor(u / U.y)),
              (i.y = r.y * U.y),
              (I.mapSize.y = r.y))),
          I.map === null)
        ) {
          const Y = this.type !== hs ? { minFilter: gt, magFilter: gt } : {};
          (I.map = new Qi(i.x, i.y, Y)),
            (I.map.texture.name = P.name + ".shadowMap"),
            I.camera.updateProjectionMatrix();
        }
        s.setRenderTarget(I.map), s.clear();
        const H = I.getViewportCount();
        for (let Y = 0; Y < H; Y++) {
          const B = I.getViewport(Y);
          a.set(r.x * B.x, r.y * B.y, r.x * B.z, r.y * B.w),
            b.viewport(a),
            I.updateMatrices(P, Y),
            (n = I.getFrustum()),
            v(S, w, I.camera, P, this.type);
        }
        I.isPointLightShadow !== !0 && this.type === hs && p(I, w),
          (I.needsUpdate = !1);
      }
      (g.needsUpdate = !1), s.setRenderTarget(A, C, M);
    });
  function p(x, S) {
    const w = e.update(m);
    f.defines.VSM_SAMPLES !== x.blurSamples &&
      ((f.defines.VSM_SAMPLES = x.blurSamples),
      (h.defines.VSM_SAMPLES = x.blurSamples),
      (f.needsUpdate = !0),
      (h.needsUpdate = !0)),
      x.mapPass === null && (x.mapPass = new Qi(i.x, i.y)),
      (f.uniforms.shadow_pass.value = x.map.texture),
      (f.uniforms.resolution.value = x.mapSize),
      (f.uniforms.radius.value = x.radius),
      s.setRenderTarget(x.mapPass),
      s.clear(),
      s.renderBufferDirect(S, null, w, f, m, null),
      (h.uniforms.shadow_pass.value = x.mapPass.texture),
      (h.uniforms.resolution.value = x.mapSize),
      (h.uniforms.radius.value = x.radius),
      s.setRenderTarget(x.map),
      s.clear(),
      s.renderBufferDirect(S, null, w, h, m, null);
  }
  function y(x, S, w, A) {
    let C = null;
    const M =
      w.isPointLight === !0 ? x.customDistanceMaterial : x.customDepthMaterial;
    if (M !== void 0) C = M;
    else if (
      ((C = w.isPointLight === !0 ? l : o),
      (s.localClippingEnabled &&
        S.clipShadows === !0 &&
        Array.isArray(S.clippingPlanes) &&
        S.clippingPlanes.length !== 0) ||
        (S.displacementMap && S.displacementScale !== 0) ||
        (S.alphaMap && S.alphaTest > 0) ||
        (S.map && S.alphaTest > 0))
    ) {
      const b = C.uuid,
        R = S.uuid;
      let D = c[b];
      D === void 0 && ((D = {}), (c[b] = D));
      let P = D[R];
      P === void 0 && ((P = C.clone()), (D[R] = P)), (C = P);
    }
    if (
      ((C.visible = S.visible),
      (C.wireframe = S.wireframe),
      A === hs
        ? (C.side = S.shadowSide !== null ? S.shadowSide : S.side)
        : (C.side = S.shadowSide !== null ? S.shadowSide : d[S.side]),
      (C.alphaMap = S.alphaMap),
      (C.alphaTest = S.alphaTest),
      (C.map = S.map),
      (C.clipShadows = S.clipShadows),
      (C.clippingPlanes = S.clippingPlanes),
      (C.clipIntersection = S.clipIntersection),
      (C.displacementMap = S.displacementMap),
      (C.displacementScale = S.displacementScale),
      (C.displacementBias = S.displacementBias),
      (C.wireframeLinewidth = S.wireframeLinewidth),
      (C.linewidth = S.linewidth),
      w.isPointLight === !0 && C.isMeshDistanceMaterial === !0)
    ) {
      const b = s.properties.get(C);
      b.light = w;
    }
    return C;
  }
  function v(x, S, w, A, C) {
    if (x.visible === !1) return;
    if (
      x.layers.test(S.layers) &&
      (x.isMesh || x.isLine || x.isPoints) &&
      (x.castShadow || (x.receiveShadow && C === hs)) &&
      (!x.frustumCulled || n.intersectsObject(x))
    ) {
      x.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, x.matrixWorld);
      const R = e.update(x),
        D = x.material;
      if (Array.isArray(D)) {
        const P = R.groups;
        for (let I = 0, U = P.length; I < U; I++) {
          const H = P[I],
            Y = D[H.materialIndex];
          if (Y && Y.visible) {
            const B = y(x, Y, A, C);
            s.renderBufferDirect(w, null, R, B, x, H);
          }
        }
      } else if (D.visible) {
        const P = y(x, D, A, C);
        s.renderBufferDirect(w, null, R, P, x, null);
      }
    }
    const b = x.children;
    for (let R = 0, D = b.length; R < D; R++) v(b[R], S, w, A, C);
  }
}
function KS(s, e, t) {
  const n = t.isWebGL2;
  function i() {
    let O = !1;
    const q = new Ye();
    let J = null;
    const le = new Ye(0, 0, 0, 0);
    return {
      setMask: function (de) {
        J !== de && !O && (s.colorMask(de, de, de, de), (J = de));
      },
      setLocked: function (de) {
        O = de;
      },
      setClear: function (de, $e, Ke, St, ei) {
        ei === !0 && ((de *= St), ($e *= St), (Ke *= St)),
          q.set(de, $e, Ke, St),
          le.equals(q) === !1 && (s.clearColor(de, $e, Ke, St), le.copy(q));
      },
      reset: function () {
        (O = !1), (J = null), le.set(-1, 0, 0, 0);
      },
    };
  }
  function r() {
    let O = !1,
      q = null,
      J = null,
      le = null;
    return {
      setTest: function (de) {
        de ? z(2929) : we(2929);
      },
      setMask: function (de) {
        q !== de && !O && (s.depthMask(de), (q = de));
      },
      setFunc: function (de) {
        if (J !== de) {
          switch (de) {
            case d_:
              s.depthFunc(512);
              break;
            case f_:
              s.depthFunc(519);
              break;
            case h_:
              s.depthFunc(513);
              break;
            case cl:
              s.depthFunc(515);
              break;
            case p_:
              s.depthFunc(514);
              break;
            case m_:
              s.depthFunc(518);
              break;
            case g_:
              s.depthFunc(516);
              break;
            case __:
              s.depthFunc(517);
              break;
            default:
              s.depthFunc(515);
          }
          J = de;
        }
      },
      setLocked: function (de) {
        O = de;
      },
      setClear: function (de) {
        le !== de && (s.clearDepth(de), (le = de));
      },
      reset: function () {
        (O = !1), (q = null), (J = null), (le = null);
      },
    };
  }
  function a() {
    let O = !1,
      q = null,
      J = null,
      le = null,
      de = null,
      $e = null,
      Ke = null,
      St = null,
      ei = null;
    return {
      setTest: function (rt) {
        O || (rt ? z(2960) : we(2960));
      },
      setMask: function (rt) {
        q !== rt && !O && (s.stencilMask(rt), (q = rt));
      },
      setFunc: function (rt, tn, xn) {
        (J !== rt || le !== tn || de !== xn) &&
          (s.stencilFunc(rt, tn, xn), (J = rt), (le = tn), (de = xn));
      },
      setOp: function (rt, tn, xn) {
        ($e !== rt || Ke !== tn || St !== xn) &&
          (s.stencilOp(rt, tn, xn), ($e = rt), (Ke = tn), (St = xn));
      },
      setLocked: function (rt) {
        O = rt;
      },
      setClear: function (rt) {
        ei !== rt && (s.clearStencil(rt), (ei = rt));
      },
      reset: function () {
        (O = !1),
          (q = null),
          (J = null),
          (le = null),
          (de = null),
          ($e = null),
          (Ke = null),
          (St = null),
          (ei = null);
      },
    };
  }
  const o = new i(),
    l = new r(),
    c = new a(),
    u = new WeakMap(),
    d = new WeakMap();
  let f = {},
    h = {},
    _ = new WeakMap(),
    m = [],
    g = null,
    p = !1,
    y = null,
    v = null,
    x = null,
    S = null,
    w = null,
    A = null,
    C = null,
    M = !1,
    b = null,
    R = null,
    D = null,
    P = null,
    I = null;
  const U = s.getParameter(35661);
  let H = !1,
    Y = 0;
  const B = s.getParameter(7938);
  B.indexOf("WebGL") !== -1
    ? ((Y = parseFloat(/^WebGL (\d)/.exec(B)[1])), (H = Y >= 1))
    : B.indexOf("OpenGL ES") !== -1 &&
      ((Y = parseFloat(/^OpenGL ES (\d)/.exec(B)[1])), (H = Y >= 2));
  let Q = null,
    Z = {};
  const me = s.getParameter(3088),
    te = s.getParameter(2978),
    V = new Ye().fromArray(me),
    K = new Ye().fromArray(te);
  function ie(O, q, J) {
    const le = new Uint8Array(4),
      de = s.createTexture();
    s.bindTexture(O, de),
      s.texParameteri(O, 10241, 9728),
      s.texParameteri(O, 10240, 9728);
    for (let $e = 0; $e < J; $e++)
      s.texImage2D(q + $e, 0, 6408, 1, 1, 0, 6408, 5121, le);
    return de;
  }
  const oe = {};
  (oe[3553] = ie(3553, 3553, 1)),
    (oe[34067] = ie(34067, 34069, 6)),
    o.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    z(2929),
    l.setFunc(cl),
    xt(!1),
    ht(Nc),
    z(2884),
    Re(xi);
  function z(O) {
    f[O] !== !0 && (s.enable(O), (f[O] = !0));
  }
  function we(O) {
    f[O] !== !1 && (s.disable(O), (f[O] = !1));
  }
  function Me(O, q) {
    return h[O] !== q
      ? (s.bindFramebuffer(O, q),
        (h[O] = q),
        n && (O === 36009 && (h[36160] = q), O === 36160 && (h[36009] = q)),
        !0)
      : !1;
  }
  function se(O, q) {
    let J = m,
      le = !1;
    if (O)
      if (
        ((J = _.get(q)),
        J === void 0 && ((J = []), _.set(q, J)),
        O.isWebGLMultipleRenderTargets)
      ) {
        const de = O.texture;
        if (J.length !== de.length || J[0] !== 36064) {
          for (let $e = 0, Ke = de.length; $e < Ke; $e++) J[$e] = 36064 + $e;
          (J.length = de.length), (le = !0);
        }
      } else J[0] !== 36064 && ((J[0] = 36064), (le = !0));
    else J[0] !== 1029 && ((J[0] = 1029), (le = !0));
    le &&
      (t.isWebGL2
        ? s.drawBuffers(J)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(J));
  }
  function xe(O) {
    return g !== O ? (s.useProgram(O), (g = O), !0) : !1;
  }
  const Be = { [Tr]: 32774, [e_]: 32778, [t_]: 32779 };
  if (n) (Be[zc] = 32775), (Be[Bc] = 32776);
  else {
    const O = e.get("EXT_blend_minmax");
    O !== null && ((Be[zc] = O.MIN_EXT), (Be[Bc] = O.MAX_EXT));
  }
  const pe = {
    [n_]: 0,
    [i_]: 1,
    [r_]: 768,
    [Yf]: 770,
    [u_]: 776,
    [l_]: 774,
    [a_]: 772,
    [s_]: 769,
    [$f]: 771,
    [c_]: 775,
    [o_]: 773,
  };
  function Re(O, q, J, le, de, $e, Ke, St) {
    if (O === xi) {
      p === !0 && (we(3042), (p = !1));
      return;
    }
    if ((p === !1 && (z(3042), (p = !0)), O !== Qg)) {
      if (O !== y || St !== M) {
        if (
          ((v !== Tr || w !== Tr) &&
            (s.blendEquation(32774), (v = Tr), (w = Tr)),
          St)
        )
          switch (O) {
            case Ir:
              s.blendFuncSeparate(1, 771, 1, 771);
              break;
            case Uc:
              s.blendFunc(1, 1);
              break;
            case Fc:
              s.blendFuncSeparate(0, 769, 0, 1);
              break;
            case kc:
              s.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", O);
              break;
          }
        else
          switch (O) {
            case Ir:
              s.blendFuncSeparate(770, 771, 1, 771);
              break;
            case Uc:
              s.blendFunc(770, 1);
              break;
            case Fc:
              s.blendFuncSeparate(0, 769, 0, 1);
              break;
            case kc:
              s.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", O);
              break;
          }
        (x = null), (S = null), (A = null), (C = null), (y = O), (M = St);
      }
      return;
    }
    (de = de || q),
      ($e = $e || J),
      (Ke = Ke || le),
      (q !== v || de !== w) &&
        (s.blendEquationSeparate(Be[q], Be[de]), (v = q), (w = de)),
      (J !== x || le !== S || $e !== A || Ke !== C) &&
        (s.blendFuncSeparate(pe[J], pe[le], pe[$e], pe[Ke]),
        (x = J),
        (S = le),
        (A = $e),
        (C = Ke)),
      (y = O),
      (M = !1);
  }
  function ft(O, q) {
    O.side === wn ? we(2884) : z(2884);
    let J = O.side === Gt;
    q && (J = !J),
      xt(J),
      O.blending === Ir && O.transparent === !1
        ? Re(xi)
        : Re(
            O.blending,
            O.blendEquation,
            O.blendSrc,
            O.blendDst,
            O.blendEquationAlpha,
            O.blendSrcAlpha,
            O.blendDstAlpha,
            O.premultipliedAlpha
          ),
      l.setFunc(O.depthFunc),
      l.setTest(O.depthTest),
      l.setMask(O.depthWrite),
      o.setMask(O.colorWrite);
    const le = O.stencilWrite;
    c.setTest(le),
      le &&
        (c.setMask(O.stencilWriteMask),
        c.setFunc(O.stencilFunc, O.stencilRef, O.stencilFuncMask),
        c.setOp(O.stencilFail, O.stencilZFail, O.stencilZPass)),
      Ve(O.polygonOffset, O.polygonOffsetFactor, O.polygonOffsetUnits),
      O.alphaToCoverage === !0 ? z(32926) : we(32926);
  }
  function xt(O) {
    b !== O && (O ? s.frontFace(2304) : s.frontFace(2305), (b = O));
  }
  function ht(O) {
    O !== Zg
      ? (z(2884),
        O !== R &&
          (O === Nc
            ? s.cullFace(1029)
            : O === Jg
            ? s.cullFace(1028)
            : s.cullFace(1032)))
      : we(2884),
      (R = O);
  }
  function ct(O) {
    O !== D && (H && s.lineWidth(O), (D = O));
  }
  function Ve(O, q, J) {
    O
      ? (z(32823),
        (P !== q || I !== J) && (s.polygonOffset(q, J), (P = q), (I = J)))
      : we(32823);
  }
  function et(O) {
    O ? z(3089) : we(3089);
  }
  function Ut(O) {
    O === void 0 && (O = 33984 + U - 1),
      Q !== O && (s.activeTexture(O), (Q = O));
  }
  function L(O, q, J) {
    J === void 0 && (Q === null ? (J = 33984 + U - 1) : (J = Q));
    let le = Z[J];
    le === void 0 && ((le = { type: void 0, texture: void 0 }), (Z[J] = le)),
      (le.type !== O || le.texture !== q) &&
        (Q !== J && (s.activeTexture(J), (Q = J)),
        s.bindTexture(O, q || oe[O]),
        (le.type = O),
        (le.texture = q));
  }
  function T() {
    const O = Z[Q];
    O !== void 0 &&
      O.type !== void 0 &&
      (s.bindTexture(O.type, null), (O.type = void 0), (O.texture = void 0));
  }
  function G() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ee() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ne() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ae() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ye() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ue() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function X() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function fe() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ge() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ve() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (O) {
      console.error("THREE.WebGLState:", O);
    }
  }
  function ce(O) {
    V.equals(O) === !1 && (s.scissor(O.x, O.y, O.z, O.w), V.copy(O));
  }
  function he(O) {
    K.equals(O) === !1 && (s.viewport(O.x, O.y, O.z, O.w), K.copy(O));
  }
  function Ue(O, q) {
    let J = d.get(q);
    J === void 0 && ((J = new WeakMap()), d.set(q, J));
    let le = J.get(O);
    le === void 0 && ((le = s.getUniformBlockIndex(q, O.name)), J.set(O, le));
  }
  function He(O, q) {
    const le = d.get(q).get(O);
    u.get(q) !== le &&
      (s.uniformBlockBinding(q, le, O.__bindingPointIndex), u.set(q, le));
  }
  function it() {
    s.disable(3042),
      s.disable(2884),
      s.disable(2929),
      s.disable(32823),
      s.disable(3089),
      s.disable(2960),
      s.disable(32926),
      s.blendEquation(32774),
      s.blendFunc(1, 0),
      s.blendFuncSeparate(1, 0, 1, 0),
      s.colorMask(!0, !0, !0, !0),
      s.clearColor(0, 0, 0, 0),
      s.depthMask(!0),
      s.depthFunc(513),
      s.clearDepth(1),
      s.stencilMask(4294967295),
      s.stencilFunc(519, 0, 4294967295),
      s.stencilOp(7680, 7680, 7680),
      s.clearStencil(0),
      s.cullFace(1029),
      s.frontFace(2305),
      s.polygonOffset(0, 0),
      s.activeTexture(33984),
      s.bindFramebuffer(36160, null),
      n === !0 &&
        (s.bindFramebuffer(36009, null), s.bindFramebuffer(36008, null)),
      s.useProgram(null),
      s.lineWidth(1),
      s.scissor(0, 0, s.canvas.width, s.canvas.height),
      s.viewport(0, 0, s.canvas.width, s.canvas.height),
      (f = {}),
      (Q = null),
      (Z = {}),
      (h = {}),
      (_ = new WeakMap()),
      (m = []),
      (g = null),
      (p = !1),
      (y = null),
      (v = null),
      (x = null),
      (S = null),
      (w = null),
      (A = null),
      (C = null),
      (M = !1),
      (b = null),
      (R = null),
      (D = null),
      (P = null),
      (I = null),
      V.set(0, 0, s.canvas.width, s.canvas.height),
      K.set(0, 0, s.canvas.width, s.canvas.height),
      o.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: o, depth: l, stencil: c },
    enable: z,
    disable: we,
    bindFramebuffer: Me,
    drawBuffers: se,
    useProgram: xe,
    setBlending: Re,
    setMaterial: ft,
    setFlipSided: xt,
    setCullFace: ht,
    setLineWidth: ct,
    setPolygonOffset: Ve,
    setScissorTest: et,
    activeTexture: Ut,
    bindTexture: L,
    unbindTexture: T,
    compressedTexImage2D: G,
    compressedTexImage3D: ee,
    texImage2D: ge,
    texImage3D: ve,
    updateUBOMapping: Ue,
    uniformBlockBinding: He,
    texStorage2D: X,
    texStorage3D: fe,
    texSubImage2D: ne,
    texSubImage3D: ae,
    compressedTexSubImage2D: ye,
    compressedTexSubImage3D: ue,
    scissor: ce,
    viewport: he,
    reset: it,
  };
}
function ZS(s, e, t, n, i, r, a) {
  const o = i.isWebGL2,
    l = i.maxTextures,
    c = i.maxCubemapSize,
    u = i.maxTextureSize,
    d = i.maxSamples,
    f = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    h =
      typeof navigator == "undefined"
        ? !1
        : /OculusBrowser/g.test(navigator.userAgent),
    _ = new WeakMap();
  let m;
  const g = new WeakMap();
  let p = !1;
  try {
    p =
      typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function y(L, T) {
    return p ? new OffscreenCanvas(L, T) : Is("canvas");
  }
  function v(L, T, G, ee) {
    let ne = 1;
    if (
      ((L.width > ee || L.height > ee) &&
        (ne = ee / Math.max(L.width, L.height)),
      ne < 1 || T === !0)
    )
      if (
        (typeof HTMLImageElement != "undefined" &&
          L instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != "undefined" &&
          L instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != "undefined" && L instanceof ImageBitmap)
      ) {
        const ae = T ? sh : Math.floor,
          ye = ae(ne * L.width),
          ue = ae(ne * L.height);
        m === void 0 && (m = y(ye, ue));
        const X = G ? y(ye, ue) : m;
        return (
          (X.width = ye),
          (X.height = ue),
          X.getContext("2d").drawImage(L, 0, 0, ye, ue),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              L.width +
              "x" +
              L.height +
              ") to (" +
              ye +
              "x" +
              ue +
              ")."
          ),
          X
        );
      } else
        return (
          "data" in L &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                L.width +
                "x" +
                L.height +
                ")."
            ),
          L
        );
    return L;
  }
  function x(L) {
    return gl(L.width) && gl(L.height);
  }
  function S(L) {
    return o
      ? !1
      : L.wrapS !== ln ||
          L.wrapT !== ln ||
          (L.minFilter !== gt && L.minFilter !== Ft);
  }
  function w(L, T) {
    return L.generateMipmaps && T && L.minFilter !== gt && L.minFilter !== Ft;
  }
  function A(L) {
    s.generateMipmap(L);
  }
  function C(L, T, G, ee, ne = !1) {
    if (o === !1) return T;
    if (L !== null) {
      if (s[L] !== void 0) return s[L];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          L +
          "'"
      );
    }
    let ae = T;
    return (
      T === 6403 &&
        (G === 5126 && (ae = 33326),
        G === 5131 && (ae = 33325),
        G === 5121 && (ae = 33321)),
      T === 33319 &&
        (G === 5126 && (ae = 33328),
        G === 5131 && (ae = 33327),
        G === 5121 && (ae = 33323)),
      T === 6408 &&
        (G === 5126 && (ae = 34836),
        G === 5131 && (ae = 34842),
        G === 5121 && (ae = ee === ze && ne === !1 ? 35907 : 32856),
        G === 32819 && (ae = 32854),
        G === 32820 && (ae = 32855)),
      (ae === 33325 ||
        ae === 33326 ||
        ae === 33327 ||
        ae === 33328 ||
        ae === 34842 ||
        ae === 34836) &&
        e.get("EXT_color_buffer_float"),
      ae
    );
  }
  function M(L, T, G) {
    return w(L, G) === !0 ||
      (L.isFramebufferTexture && L.minFilter !== gt && L.minFilter !== Ft)
      ? Math.log2(Math.max(T.width, T.height)) + 1
      : L.mipmaps !== void 0 && L.mipmaps.length > 0
      ? L.mipmaps.length
      : L.isCompressedTexture && Array.isArray(L.image)
      ? T.mipmaps.length
      : 1;
  }
  function b(L) {
    return L === gt || L === fl || L === ya ? 9728 : 9729;
  }
  function R(L) {
    const T = L.target;
    T.removeEventListener("dispose", R), P(T), T.isVideoTexture && _.delete(T);
  }
  function D(L) {
    const T = L.target;
    T.removeEventListener("dispose", D), U(T);
  }
  function P(L) {
    const T = n.get(L);
    if (T.__webglInit === void 0) return;
    const G = L.source,
      ee = g.get(G);
    if (ee) {
      const ne = ee[T.__cacheKey];
      ne.usedTimes--,
        ne.usedTimes === 0 && I(L),
        Object.keys(ee).length === 0 && g.delete(G);
    }
    n.remove(L);
  }
  function I(L) {
    const T = n.get(L);
    s.deleteTexture(T.__webglTexture);
    const G = L.source,
      ee = g.get(G);
    delete ee[T.__cacheKey], a.memory.textures--;
  }
  function U(L) {
    const T = L.texture,
      G = n.get(L),
      ee = n.get(T);
    if (
      (ee.__webglTexture !== void 0 &&
        (s.deleteTexture(ee.__webglTexture), a.memory.textures--),
      L.depthTexture && L.depthTexture.dispose(),
      L.isWebGLCubeRenderTarget)
    )
      for (let ne = 0; ne < 6; ne++)
        s.deleteFramebuffer(G.__webglFramebuffer[ne]),
          G.__webglDepthbuffer &&
            s.deleteRenderbuffer(G.__webglDepthbuffer[ne]);
    else {
      if (
        (s.deleteFramebuffer(G.__webglFramebuffer),
        G.__webglDepthbuffer && s.deleteRenderbuffer(G.__webglDepthbuffer),
        G.__webglMultisampledFramebuffer &&
          s.deleteFramebuffer(G.__webglMultisampledFramebuffer),
        G.__webglColorRenderbuffer)
      )
        for (let ne = 0; ne < G.__webglColorRenderbuffer.length; ne++)
          G.__webglColorRenderbuffer[ne] &&
            s.deleteRenderbuffer(G.__webglColorRenderbuffer[ne]);
      G.__webglDepthRenderbuffer &&
        s.deleteRenderbuffer(G.__webglDepthRenderbuffer);
    }
    if (L.isWebGLMultipleRenderTargets)
      for (let ne = 0, ae = T.length; ne < ae; ne++) {
        const ye = n.get(T[ne]);
        ye.__webglTexture &&
          (s.deleteTexture(ye.__webglTexture), a.memory.textures--),
          n.remove(T[ne]);
      }
    n.remove(T), n.remove(L);
  }
  let H = 0;
  function Y() {
    H = 0;
  }
  function B() {
    const L = H;
    return (
      L >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            L +
            " texture units while this GPU supports only " +
            l
        ),
      (H += 1),
      L
    );
  }
  function Q(L) {
    const T = [];
    return (
      T.push(L.wrapS),
      T.push(L.wrapT),
      T.push(L.wrapR || 0),
      T.push(L.magFilter),
      T.push(L.minFilter),
      T.push(L.anisotropy),
      T.push(L.internalFormat),
      T.push(L.format),
      T.push(L.type),
      T.push(L.generateMipmaps),
      T.push(L.premultiplyAlpha),
      T.push(L.flipY),
      T.push(L.unpackAlignment),
      T.push(L.encoding),
      T.join()
    );
  }
  function Z(L, T) {
    const G = n.get(L);
    if (
      (L.isVideoTexture && et(L),
      L.isRenderTargetTexture === !1 &&
        L.version > 0 &&
        G.__version !== L.version)
    ) {
      const ee = L.image;
      if (ee === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ee.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        we(G, L, T);
        return;
      }
    }
    t.bindTexture(3553, G.__webglTexture, 33984 + T);
  }
  function me(L, T) {
    const G = n.get(L);
    if (L.version > 0 && G.__version !== L.version) {
      we(G, L, T);
      return;
    }
    t.bindTexture(35866, G.__webglTexture, 33984 + T);
  }
  function te(L, T) {
    const G = n.get(L);
    if (L.version > 0 && G.__version !== L.version) {
      we(G, L, T);
      return;
    }
    t.bindTexture(32879, G.__webglTexture, 33984 + T);
  }
  function V(L, T) {
    const G = n.get(L);
    if (L.version > 0 && G.__version !== L.version) {
      Me(G, L, T);
      return;
    }
    t.bindTexture(34067, G.__webglTexture, 33984 + T);
  }
  const K = { [Wr]: 10497, [ln]: 33071, [Ia]: 33648 },
    ie = {
      [gt]: 9728,
      [fl]: 9984,
      [ya]: 9986,
      [Ft]: 9729,
      [Qf]: 9985,
      [Ki]: 9987,
    };
  function oe(L, T, G) {
    if (
      (G
        ? (s.texParameteri(L, 10242, K[T.wrapS]),
          s.texParameteri(L, 10243, K[T.wrapT]),
          (L === 32879 || L === 35866) && s.texParameteri(L, 32882, K[T.wrapR]),
          s.texParameteri(L, 10240, ie[T.magFilter]),
          s.texParameteri(L, 10241, ie[T.minFilter]))
        : (s.texParameteri(L, 10242, 33071),
          s.texParameteri(L, 10243, 33071),
          (L === 32879 || L === 35866) && s.texParameteri(L, 32882, 33071),
          (T.wrapS !== ln || T.wrapT !== ln) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          s.texParameteri(L, 10240, b(T.magFilter)),
          s.texParameteri(L, 10241, b(T.minFilter)),
          T.minFilter !== gt &&
            T.minFilter !== Ft &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const ee = e.get("EXT_texture_filter_anisotropic");
      if (
        T.magFilter === gt ||
        (T.minFilter !== ya && T.minFilter !== Ki) ||
        (T.type === mi && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          T.type === Ls &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (T.anisotropy > 1 || n.get(T).__currentAnisotropy) &&
        (s.texParameterf(
          L,
          ee.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(T.anisotropy, i.getMaxAnisotropy())
        ),
        (n.get(T).__currentAnisotropy = T.anisotropy));
    }
  }
  function z(L, T) {
    let G = !1;
    L.__webglInit === void 0 &&
      ((L.__webglInit = !0), T.addEventListener("dispose", R));
    const ee = T.source;
    let ne = g.get(ee);
    ne === void 0 && ((ne = {}), g.set(ee, ne));
    const ae = Q(T);
    if (ae !== L.__cacheKey) {
      ne[ae] === void 0 &&
        ((ne[ae] = { texture: s.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (G = !0)),
        ne[ae].usedTimes++;
      const ye = ne[L.__cacheKey];
      ye !== void 0 &&
        (ne[L.__cacheKey].usedTimes--, ye.usedTimes === 0 && I(T)),
        (L.__cacheKey = ae),
        (L.__webglTexture = ne[ae].texture);
    }
    return G;
  }
  function we(L, T, G) {
    let ee = 3553;
    (T.isDataArrayTexture || T.isCompressedArrayTexture) && (ee = 35866),
      T.isData3DTexture && (ee = 32879);
    const ne = z(L, T),
      ae = T.source;
    t.bindTexture(ee, L.__webglTexture, 33984 + G);
    const ye = n.get(ae);
    if (ae.version !== ye.__version || ne === !0) {
      t.activeTexture(33984 + G),
        s.pixelStorei(37440, T.flipY),
        s.pixelStorei(37441, T.premultiplyAlpha),
        s.pixelStorei(3317, T.unpackAlignment),
        s.pixelStorei(37443, 0);
      const ue = S(T) && x(T.image) === !1;
      let X = v(T.image, ue, !1, u);
      X = Ut(T, X);
      const fe = x(X) || o,
        ge = r.convert(T.format, T.encoding);
      let ve = r.convert(T.type),
        ce = C(T.internalFormat, ge, ve, T.encoding, T.isVideoTexture);
      oe(ee, T, fe);
      let he;
      const Ue = T.mipmaps,
        He = o && T.isVideoTexture !== !0,
        it = ye.__version === void 0 || ne === !0,
        O = M(T, X, fe);
      if (T.isDepthTexture)
        (ce = 6402),
          o
            ? T.type === mi
              ? (ce = 36012)
              : T.type === Gi
              ? (ce = 33190)
              : T.type === Or
              ? (ce = 35056)
              : (ce = 33189)
            : T.type === mi &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          T.format === ji &&
            ce === 6402 &&
            T.type !== eh &&
            T.type !== Gi &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (T.type = Gi),
            (ve = r.convert(T.type))),
          T.format === qr &&
            ce === 6402 &&
            ((ce = 34041),
            T.type !== Or &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (T.type = Or),
              (ve = r.convert(T.type)))),
          it &&
            (He
              ? t.texStorage2D(3553, 1, ce, X.width, X.height)
              : t.texImage2D(3553, 0, ce, X.width, X.height, 0, ge, ve, null));
      else if (T.isDataTexture)
        if (Ue.length > 0 && fe) {
          He && it && t.texStorage2D(3553, O, ce, Ue[0].width, Ue[0].height);
          for (let q = 0, J = Ue.length; q < J; q++)
            (he = Ue[q]),
              He
                ? t.texSubImage2D(
                    3553,
                    q,
                    0,
                    0,
                    he.width,
                    he.height,
                    ge,
                    ve,
                    he.data
                  )
                : t.texImage2D(
                    3553,
                    q,
                    ce,
                    he.width,
                    he.height,
                    0,
                    ge,
                    ve,
                    he.data
                  );
          T.generateMipmaps = !1;
        } else
          He
            ? (it && t.texStorage2D(3553, O, ce, X.width, X.height),
              t.texSubImage2D(3553, 0, 0, 0, X.width, X.height, ge, ve, X.data))
            : t.texImage2D(3553, 0, ce, X.width, X.height, 0, ge, ve, X.data);
      else if (T.isCompressedTexture)
        if (T.isCompressedArrayTexture) {
          He &&
            it &&
            t.texStorage3D(35866, O, ce, Ue[0].width, Ue[0].height, X.depth);
          for (let q = 0, J = Ue.length; q < J; q++)
            (he = Ue[q]),
              T.format !== cn
                ? ge !== null
                  ? He
                    ? t.compressedTexSubImage3D(
                        35866,
                        q,
                        0,
                        0,
                        0,
                        he.width,
                        he.height,
                        X.depth,
                        ge,
                        he.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        35866,
                        q,
                        ce,
                        he.width,
                        he.height,
                        X.depth,
                        0,
                        he.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : He
                ? t.texSubImage3D(
                    35866,
                    q,
                    0,
                    0,
                    0,
                    he.width,
                    he.height,
                    X.depth,
                    ge,
                    ve,
                    he.data
                  )
                : t.texImage3D(
                    35866,
                    q,
                    ce,
                    he.width,
                    he.height,
                    X.depth,
                    0,
                    ge,
                    ve,
                    he.data
                  );
        } else {
          He && it && t.texStorage2D(3553, O, ce, Ue[0].width, Ue[0].height);
          for (let q = 0, J = Ue.length; q < J; q++)
            (he = Ue[q]),
              T.format !== cn
                ? ge !== null
                  ? He
                    ? t.compressedTexSubImage2D(
                        3553,
                        q,
                        0,
                        0,
                        he.width,
                        he.height,
                        ge,
                        he.data
                      )
                    : t.compressedTexImage2D(
                        3553,
                        q,
                        ce,
                        he.width,
                        he.height,
                        0,
                        he.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : He
                ? t.texSubImage2D(
                    3553,
                    q,
                    0,
                    0,
                    he.width,
                    he.height,
                    ge,
                    ve,
                    he.data
                  )
                : t.texImage2D(
                    3553,
                    q,
                    ce,
                    he.width,
                    he.height,
                    0,
                    ge,
                    ve,
                    he.data
                  );
        }
      else if (T.isDataArrayTexture)
        He
          ? (it && t.texStorage3D(35866, O, ce, X.width, X.height, X.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              X.width,
              X.height,
              X.depth,
              ge,
              ve,
              X.data
            ))
          : t.texImage3D(
              35866,
              0,
              ce,
              X.width,
              X.height,
              X.depth,
              0,
              ge,
              ve,
              X.data
            );
      else if (T.isData3DTexture)
        He
          ? (it && t.texStorage3D(32879, O, ce, X.width, X.height, X.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              X.width,
              X.height,
              X.depth,
              ge,
              ve,
              X.data
            ))
          : t.texImage3D(
              32879,
              0,
              ce,
              X.width,
              X.height,
              X.depth,
              0,
              ge,
              ve,
              X.data
            );
      else if (T.isFramebufferTexture) {
        if (it)
          if (He) t.texStorage2D(3553, O, ce, X.width, X.height);
          else {
            let q = X.width,
              J = X.height;
            for (let le = 0; le < O; le++)
              t.texImage2D(3553, le, ce, q, J, 0, ge, ve, null),
                (q >>= 1),
                (J >>= 1);
          }
      } else if (Ue.length > 0 && fe) {
        He && it && t.texStorage2D(3553, O, ce, Ue[0].width, Ue[0].height);
        for (let q = 0, J = Ue.length; q < J; q++)
          (he = Ue[q]),
            He
              ? t.texSubImage2D(3553, q, 0, 0, ge, ve, he)
              : t.texImage2D(3553, q, ce, ge, ve, he);
        T.generateMipmaps = !1;
      } else
        He
          ? (it && t.texStorage2D(3553, O, ce, X.width, X.height),
            t.texSubImage2D(3553, 0, 0, 0, ge, ve, X))
          : t.texImage2D(3553, 0, ce, ge, ve, X);
      w(T, fe) && A(ee),
        (ye.__version = ae.version),
        T.onUpdate && T.onUpdate(T);
    }
    L.__version = T.version;
  }
  function Me(L, T, G) {
    if (T.image.length !== 6) return;
    const ee = z(L, T),
      ne = T.source;
    t.bindTexture(34067, L.__webglTexture, 33984 + G);
    const ae = n.get(ne);
    if (ne.version !== ae.__version || ee === !0) {
      t.activeTexture(33984 + G),
        s.pixelStorei(37440, T.flipY),
        s.pixelStorei(37441, T.premultiplyAlpha),
        s.pixelStorei(3317, T.unpackAlignment),
        s.pixelStorei(37443, 0);
      const ye = T.isCompressedTexture || T.image[0].isCompressedTexture,
        ue = T.image[0] && T.image[0].isDataTexture,
        X = [];
      for (let q = 0; q < 6; q++)
        !ye && !ue
          ? (X[q] = v(T.image[q], !1, !0, c))
          : (X[q] = ue ? T.image[q].image : T.image[q]),
          (X[q] = Ut(T, X[q]));
      const fe = X[0],
        ge = x(fe) || o,
        ve = r.convert(T.format, T.encoding),
        ce = r.convert(T.type),
        he = C(T.internalFormat, ve, ce, T.encoding),
        Ue = o && T.isVideoTexture !== !0,
        He = ae.__version === void 0 || ee === !0;
      let it = M(T, fe, ge);
      oe(34067, T, ge);
      let O;
      if (ye) {
        Ue && He && t.texStorage2D(34067, it, he, fe.width, fe.height);
        for (let q = 0; q < 6; q++) {
          O = X[q].mipmaps;
          for (let J = 0; J < O.length; J++) {
            const le = O[J];
            T.format !== cn
              ? ve !== null
                ? Ue
                  ? t.compressedTexSubImage2D(
                      34069 + q,
                      J,
                      0,
                      0,
                      le.width,
                      le.height,
                      ve,
                      le.data
                    )
                  : t.compressedTexImage2D(
                      34069 + q,
                      J,
                      he,
                      le.width,
                      le.height,
                      0,
                      le.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Ue
              ? t.texSubImage2D(
                  34069 + q,
                  J,
                  0,
                  0,
                  le.width,
                  le.height,
                  ve,
                  ce,
                  le.data
                )
              : t.texImage2D(
                  34069 + q,
                  J,
                  he,
                  le.width,
                  le.height,
                  0,
                  ve,
                  ce,
                  le.data
                );
          }
        }
      } else {
        (O = T.mipmaps),
          Ue &&
            He &&
            (O.length > 0 && it++,
            t.texStorage2D(34067, it, he, X[0].width, X[0].height));
        for (let q = 0; q < 6; q++)
          if (ue) {
            Ue
              ? t.texSubImage2D(
                  34069 + q,
                  0,
                  0,
                  0,
                  X[q].width,
                  X[q].height,
                  ve,
                  ce,
                  X[q].data
                )
              : t.texImage2D(
                  34069 + q,
                  0,
                  he,
                  X[q].width,
                  X[q].height,
                  0,
                  ve,
                  ce,
                  X[q].data
                );
            for (let J = 0; J < O.length; J++) {
              const de = O[J].image[q].image;
              Ue
                ? t.texSubImage2D(
                    34069 + q,
                    J + 1,
                    0,
                    0,
                    de.width,
                    de.height,
                    ve,
                    ce,
                    de.data
                  )
                : t.texImage2D(
                    34069 + q,
                    J + 1,
                    he,
                    de.width,
                    de.height,
                    0,
                    ve,
                    ce,
                    de.data
                  );
            }
          } else {
            Ue
              ? t.texSubImage2D(34069 + q, 0, 0, 0, ve, ce, X[q])
              : t.texImage2D(34069 + q, 0, he, ve, ce, X[q]);
            for (let J = 0; J < O.length; J++) {
              const le = O[J];
              Ue
                ? t.texSubImage2D(34069 + q, J + 1, 0, 0, ve, ce, le.image[q])
                : t.texImage2D(34069 + q, J + 1, he, ve, ce, le.image[q]);
            }
          }
      }
      w(T, ge) && A(34067),
        (ae.__version = ne.version),
        T.onUpdate && T.onUpdate(T);
    }
    L.__version = T.version;
  }
  function se(L, T, G, ee, ne) {
    const ae = r.convert(G.format, G.encoding),
      ye = r.convert(G.type),
      ue = C(G.internalFormat, ae, ye, G.encoding);
    n.get(T).__hasExternalTextures ||
      (ne === 32879 || ne === 35866
        ? t.texImage3D(ne, 0, ue, T.width, T.height, T.depth, 0, ae, ye, null)
        : t.texImage2D(ne, 0, ue, T.width, T.height, 0, ae, ye, null)),
      t.bindFramebuffer(36160, L),
      Ve(T)
        ? f.framebufferTexture2DMultisampleEXT(
            36160,
            ee,
            ne,
            n.get(G).__webglTexture,
            0,
            ct(T)
          )
        : (ne === 3553 || (ne >= 34069 && ne <= 34074)) &&
          s.framebufferTexture2D(36160, ee, ne, n.get(G).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function xe(L, T, G) {
    if ((s.bindRenderbuffer(36161, L), T.depthBuffer && !T.stencilBuffer)) {
      let ee = 33189;
      if (G || Ve(T)) {
        const ne = T.depthTexture;
        ne &&
          ne.isDepthTexture &&
          (ne.type === mi ? (ee = 36012) : ne.type === Gi && (ee = 33190));
        const ae = ct(T);
        Ve(T)
          ? f.renderbufferStorageMultisampleEXT(
              36161,
              ae,
              ee,
              T.width,
              T.height
            )
          : s.renderbufferStorageMultisample(36161, ae, ee, T.width, T.height);
      } else s.renderbufferStorage(36161, ee, T.width, T.height);
      s.framebufferRenderbuffer(36160, 36096, 36161, L);
    } else if (T.depthBuffer && T.stencilBuffer) {
      const ee = ct(T);
      G && Ve(T) === !1
        ? s.renderbufferStorageMultisample(36161, ee, 35056, T.width, T.height)
        : Ve(T)
        ? f.renderbufferStorageMultisampleEXT(
            36161,
            ee,
            35056,
            T.width,
            T.height
          )
        : s.renderbufferStorage(36161, 34041, T.width, T.height),
        s.framebufferRenderbuffer(36160, 33306, 36161, L);
    } else {
      const ee =
        T.isWebGLMultipleRenderTargets === !0 ? T.texture : [T.texture];
      for (let ne = 0; ne < ee.length; ne++) {
        const ae = ee[ne],
          ye = r.convert(ae.format, ae.encoding),
          ue = r.convert(ae.type),
          X = C(ae.internalFormat, ye, ue, ae.encoding),
          fe = ct(T);
        G && Ve(T) === !1
          ? s.renderbufferStorageMultisample(36161, fe, X, T.width, T.height)
          : Ve(T)
          ? f.renderbufferStorageMultisampleEXT(36161, fe, X, T.width, T.height)
          : s.renderbufferStorage(36161, X, T.width, T.height);
      }
    }
    s.bindRenderbuffer(36161, null);
  }
  function Be(L, T) {
    if (T && T.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, L),
      !(T.depthTexture && T.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!n.get(T.depthTexture).__webglTexture ||
      T.depthTexture.image.width !== T.width ||
      T.depthTexture.image.height !== T.height) &&
      ((T.depthTexture.image.width = T.width),
      (T.depthTexture.image.height = T.height),
      (T.depthTexture.needsUpdate = !0)),
      Z(T.depthTexture, 0);
    const ee = n.get(T.depthTexture).__webglTexture,
      ne = ct(T);
    if (T.depthTexture.format === ji)
      Ve(T)
        ? f.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ee, 0, ne)
        : s.framebufferTexture2D(36160, 36096, 3553, ee, 0);
    else if (T.depthTexture.format === qr)
      Ve(T)
        ? f.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ee, 0, ne)
        : s.framebufferTexture2D(36160, 33306, 3553, ee, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function pe(L) {
    const T = n.get(L),
      G = L.isWebGLCubeRenderTarget === !0;
    if (L.depthTexture && !T.__autoAllocateDepthBuffer) {
      if (G)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Be(T.__webglFramebuffer, L);
    } else if (G) {
      T.__webglDepthbuffer = [];
      for (let ee = 0; ee < 6; ee++)
        t.bindFramebuffer(36160, T.__webglFramebuffer[ee]),
          (T.__webglDepthbuffer[ee] = s.createRenderbuffer()),
          xe(T.__webglDepthbuffer[ee], L, !1);
    } else
      t.bindFramebuffer(36160, T.__webglFramebuffer),
        (T.__webglDepthbuffer = s.createRenderbuffer()),
        xe(T.__webglDepthbuffer, L, !1);
    t.bindFramebuffer(36160, null);
  }
  function Re(L, T, G) {
    const ee = n.get(L);
    T !== void 0 && se(ee.__webglFramebuffer, L, L.texture, 36064, 3553),
      G !== void 0 && pe(L);
  }
  function ft(L) {
    const T = L.texture,
      G = n.get(L),
      ee = n.get(T);
    L.addEventListener("dispose", D),
      L.isWebGLMultipleRenderTargets !== !0 &&
        (ee.__webglTexture === void 0 &&
          (ee.__webglTexture = s.createTexture()),
        (ee.__version = T.version),
        a.memory.textures++);
    const ne = L.isWebGLCubeRenderTarget === !0,
      ae = L.isWebGLMultipleRenderTargets === !0,
      ye = x(L) || o;
    if (ne) {
      G.__webglFramebuffer = [];
      for (let ue = 0; ue < 6; ue++)
        G.__webglFramebuffer[ue] = s.createFramebuffer();
    } else {
      if (((G.__webglFramebuffer = s.createFramebuffer()), ae))
        if (i.drawBuffers) {
          const ue = L.texture;
          for (let X = 0, fe = ue.length; X < fe; X++) {
            const ge = n.get(ue[X]);
            ge.__webglTexture === void 0 &&
              ((ge.__webglTexture = s.createTexture()), a.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && L.samples > 0 && Ve(L) === !1) {
        const ue = ae ? T : [T];
        (G.__webglMultisampledFramebuffer = s.createFramebuffer()),
          (G.__webglColorRenderbuffer = []),
          t.bindFramebuffer(36160, G.__webglMultisampledFramebuffer);
        for (let X = 0; X < ue.length; X++) {
          const fe = ue[X];
          (G.__webglColorRenderbuffer[X] = s.createRenderbuffer()),
            s.bindRenderbuffer(36161, G.__webglColorRenderbuffer[X]);
          const ge = r.convert(fe.format, fe.encoding),
            ve = r.convert(fe.type),
            ce = C(
              fe.internalFormat,
              ge,
              ve,
              fe.encoding,
              L.isXRRenderTarget === !0
            ),
            he = ct(L);
          s.renderbufferStorageMultisample(36161, he, ce, L.width, L.height),
            s.framebufferRenderbuffer(
              36160,
              36064 + X,
              36161,
              G.__webglColorRenderbuffer[X]
            );
        }
        s.bindRenderbuffer(36161, null),
          L.depthBuffer &&
            ((G.__webglDepthRenderbuffer = s.createRenderbuffer()),
            xe(G.__webglDepthRenderbuffer, L, !0)),
          t.bindFramebuffer(36160, null);
      }
    }
    if (ne) {
      t.bindTexture(34067, ee.__webglTexture), oe(34067, T, ye);
      for (let ue = 0; ue < 6; ue++)
        se(G.__webglFramebuffer[ue], L, T, 36064, 34069 + ue);
      w(T, ye) && A(34067), t.unbindTexture();
    } else if (ae) {
      const ue = L.texture;
      for (let X = 0, fe = ue.length; X < fe; X++) {
        const ge = ue[X],
          ve = n.get(ge);
        t.bindTexture(3553, ve.__webglTexture),
          oe(3553, ge, ye),
          se(G.__webglFramebuffer, L, ge, 36064 + X, 3553),
          w(ge, ye) && A(3553);
      }
      t.unbindTexture();
    } else {
      let ue = 3553;
      (L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) &&
        (o
          ? (ue = L.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(ue, ee.__webglTexture),
        oe(ue, T, ye),
        se(G.__webglFramebuffer, L, T, 36064, ue),
        w(T, ye) && A(ue),
        t.unbindTexture();
    }
    L.depthBuffer && pe(L);
  }
  function xt(L) {
    const T = x(L) || o,
      G = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
    for (let ee = 0, ne = G.length; ee < ne; ee++) {
      const ae = G[ee];
      if (w(ae, T)) {
        const ye = L.isWebGLCubeRenderTarget ? 34067 : 3553,
          ue = n.get(ae).__webglTexture;
        t.bindTexture(ye, ue), A(ye), t.unbindTexture();
      }
    }
  }
  function ht(L) {
    if (o && L.samples > 0 && Ve(L) === !1) {
      const T = L.isWebGLMultipleRenderTargets ? L.texture : [L.texture],
        G = L.width,
        ee = L.height;
      let ne = 16384;
      const ae = [],
        ye = L.stencilBuffer ? 33306 : 36096,
        ue = n.get(L),
        X = L.isWebGLMultipleRenderTargets === !0;
      if (X)
        for (let fe = 0; fe < T.length; fe++)
          t.bindFramebuffer(36160, ue.__webglMultisampledFramebuffer),
            s.framebufferRenderbuffer(36160, 36064 + fe, 36161, null),
            t.bindFramebuffer(36160, ue.__webglFramebuffer),
            s.framebufferTexture2D(36009, 36064 + fe, 3553, null, 0);
      t.bindFramebuffer(36008, ue.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, ue.__webglFramebuffer);
      for (let fe = 0; fe < T.length; fe++) {
        ae.push(36064 + fe), L.depthBuffer && ae.push(ye);
        const ge =
          ue.__ignoreDepthValues !== void 0 ? ue.__ignoreDepthValues : !1;
        if (
          (ge === !1 &&
            (L.depthBuffer && (ne |= 256), L.stencilBuffer && (ne |= 1024)),
          X &&
            s.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              ue.__webglColorRenderbuffer[fe]
            ),
          ge === !0 &&
            (s.invalidateFramebuffer(36008, [ye]),
            s.invalidateFramebuffer(36009, [ye])),
          X)
        ) {
          const ve = n.get(T[fe]).__webglTexture;
          s.framebufferTexture2D(36009, 36064, 3553, ve, 0);
        }
        s.blitFramebuffer(0, 0, G, ee, 0, 0, G, ee, ne, 9728),
          h && s.invalidateFramebuffer(36008, ae);
      }
      if ((t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), X))
        for (let fe = 0; fe < T.length; fe++) {
          t.bindFramebuffer(36160, ue.__webglMultisampledFramebuffer),
            s.framebufferRenderbuffer(
              36160,
              36064 + fe,
              36161,
              ue.__webglColorRenderbuffer[fe]
            );
          const ge = n.get(T[fe]).__webglTexture;
          t.bindFramebuffer(36160, ue.__webglFramebuffer),
            s.framebufferTexture2D(36009, 36064 + fe, 3553, ge, 0);
        }
      t.bindFramebuffer(36009, ue.__webglMultisampledFramebuffer);
    }
  }
  function ct(L) {
    return Math.min(d, L.samples);
  }
  function Ve(L) {
    const T = n.get(L);
    return (
      o &&
      L.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      T.__useRenderToTexture !== !1
    );
  }
  function et(L) {
    const T = a.render.frame;
    _.get(L) !== T && (_.set(L, T), L.update());
  }
  function Ut(L, T) {
    const G = L.encoding,
      ee = L.format,
      ne = L.type;
    return (
      L.isCompressedTexture === !0 ||
        L.isVideoTexture === !0 ||
        L.format === ml ||
        (G !== Ji &&
          (G === ze
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && ee === cn
                ? ((L.format = ml),
                  (L.minFilter = Ft),
                  (L.generateMipmaps = !1))
                : (T = oh.sRGBToLinear(T))
              : (ee !== cn || ne !== Zi) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                G
              ))),
      T
    );
  }
  (this.allocateTextureUnit = B),
    (this.resetTextureUnits = Y),
    (this.setTexture2D = Z),
    (this.setTexture2DArray = me),
    (this.setTexture3D = te),
    (this.setTextureCube = V),
    (this.rebindTextures = Re),
    (this.setupRenderTarget = ft),
    (this.updateRenderTargetMipmap = xt),
    (this.updateMultisampleRenderTarget = ht),
    (this.setupDepthRenderbuffer = pe),
    (this.setupFrameBufferTexture = se),
    (this.useMultisampledRTT = Ve);
}
function JS(s, e, t) {
  const n = t.isWebGL2;
  function i(r, a = null) {
    let o;
    if (r === Zi) return 5121;
    if (r === A_) return 32819;
    if (r === C_) return 32820;
    if (r === w_) return 5120;
    if (r === T_) return 5122;
    if (r === eh) return 5123;
    if (r === E_) return 5124;
    if (r === Gi) return 5125;
    if (r === mi) return 5126;
    if (r === Ls)
      return n
        ? 5131
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (r === P_) return 6406;
    if (r === cn) return 6408;
    if (r === L_) return 6409;
    if (r === R_) return 6410;
    if (r === ji) return 6402;
    if (r === qr) return 34041;
    if (r === ml)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (r === D_) return 6403;
    if (r === I_) return 36244;
    if (r === O_) return 33319;
    if (r === N_) return 33320;
    if (r === U_) return 36249;
    if (r === fo || r === ho || r === po || r === mo)
      if (a === ze)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (r === fo) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === ho) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === po) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === mo) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === fo) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === ho) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === po) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === mo) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === Vc || r === Gc || r === Hc || r === Wc)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === Vc) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === Gc) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === Hc) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === Wc) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === F_)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (r === qc || r === Xc)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (r === qc)
          return a === ze ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === Xc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === jc ||
      r === Yc ||
      r === $c ||
      r === Kc ||
      r === Zc ||
      r === Jc ||
      r === Qc ||
      r === eu ||
      r === tu ||
      r === nu ||
      r === iu ||
      r === ru ||
      r === su ||
      r === au
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (r === jc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === Yc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === $c)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === Kc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === Zc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === Jc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === Qc)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === eu)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === tu)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === nu)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === iu)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === ru)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === su)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === au)
          return a === ze
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === go)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (r === go)
          return a === ze
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (r === k_ || r === ou || r === lu || r === cu)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (r === go) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === ou) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === lu) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === cu) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === Or
      ? n
        ? 34042
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : s[r] !== void 0
      ? s[r]
      : null;
  }
  return { convert: i };
}
class QS extends It {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Xn extends Qe {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const eM = { type: "move" };
class zo {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Xn()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Xn()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new N()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new N())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Xn()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new N()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new N())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      r = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const m of e.hand.values()) {
          const g = t.getJointPose(m, n),
            p = this._getHandJoint(c, m);
          g !== null &&
            (p.matrix.fromArray(g.transform.matrix),
            p.matrix.decompose(p.position, p.rotation, p.scale),
            (p.jointRadius = g.radius)),
            (p.visible = g !== null);
        }
        const u = c.joints["index-finger-tip"],
          d = c.joints["thumb-tip"],
          f = u.position.distanceTo(d.position),
          h = 0.02,
          _ = 0.005;
        c.inputState.pinching && f > h + _
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            f <= h - _ &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((r = t.getPose(e.gripSpace, n)),
          r !== null &&
            (l.matrix.fromArray(r.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            r.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(r.linearVelocity))
              : (l.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(r.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && r !== null && (i = r),
        i !== null &&
          (o.matrix.fromArray(i.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          i.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(i.linearVelocity))
            : (o.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(i.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(eM)));
    }
    return (
      o !== null && (o.visible = i !== null),
      l !== null && (l.visible = r !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Xn();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class tM extends yt {
  constructor(e, t, n, i, r, a, o, l, c, u) {
    if (((u = u !== void 0 ? u : ji), u !== ji && u !== qr))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && u === ji && (n = Gi),
      n === void 0 && u === qr && (n = Or),
      super(null, i, r, a, o, l, u, n, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = o !== void 0 ? o : gt),
      (this.minFilter = l !== void 0 ? l : gt),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class nM extends Kr {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      r = 1,
      a = null,
      o = "local-floor",
      l = 1,
      c = null,
      u = null,
      d = null,
      f = null,
      h = null,
      _ = null;
    const m = t.getContextAttributes();
    let g = null,
      p = null;
    const y = [],
      v = [],
      x = new Set(),
      S = new Map(),
      w = new It();
    w.layers.enable(1), (w.viewport = new Ye());
    const A = new It();
    A.layers.enable(2), (A.viewport = new Ye());
    const C = [w, A],
      M = new QS();
    M.layers.enable(1), M.layers.enable(2);
    let b = null,
      R = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (V) {
        let K = y[V];
        return (
          K === void 0 && ((K = new zo()), (y[V] = K)), K.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (V) {
        let K = y[V];
        return K === void 0 && ((K = new zo()), (y[V] = K)), K.getGripSpace();
      }),
      (this.getHand = function (V) {
        let K = y[V];
        return K === void 0 && ((K = new zo()), (y[V] = K)), K.getHandSpace();
      });
    function D(V) {
      const K = v.indexOf(V.inputSource);
      if (K === -1) return;
      const ie = y[K];
      ie !== void 0 && ie.dispatchEvent({ type: V.type, data: V.inputSource });
    }
    function P() {
      i.removeEventListener("select", D),
        i.removeEventListener("selectstart", D),
        i.removeEventListener("selectend", D),
        i.removeEventListener("squeeze", D),
        i.removeEventListener("squeezestart", D),
        i.removeEventListener("squeezeend", D),
        i.removeEventListener("end", P),
        i.removeEventListener("inputsourceschange", I);
      for (let V = 0; V < y.length; V++) {
        const K = v[V];
        K !== null && ((v[V] = null), y[V].disconnect(K));
      }
      (b = null),
        (R = null),
        e.setRenderTarget(g),
        (h = null),
        (f = null),
        (d = null),
        (i = null),
        (p = null),
        te.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (V) {
      (r = V),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (V) {
        (o = V),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (V) {
        c = V;
      }),
      (this.getBaseLayer = function () {
        return f !== null ? f : h;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return _;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (V) {
        if (((i = V), i !== null)) {
          if (
            ((g = e.getRenderTarget()),
            i.addEventListener("select", D),
            i.addEventListener("selectstart", D),
            i.addEventListener("selectend", D),
            i.addEventListener("squeeze", D),
            i.addEventListener("squeezestart", D),
            i.addEventListener("squeezeend", D),
            i.addEventListener("end", P),
            i.addEventListener("inputsourceschange", I),
            m.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const K = {
              antialias: i.renderState.layers === void 0 ? m.antialias : !0,
              alpha: m.alpha,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: r,
            };
            (h = new XRWebGLLayer(i, t, K)),
              i.updateRenderState({ baseLayer: h }),
              (p = new Qi(h.framebufferWidth, h.framebufferHeight, {
                format: cn,
                type: Zi,
                encoding: e.outputEncoding,
                stencilBuffer: m.stencil,
              }));
          } else {
            let K = null,
              ie = null,
              oe = null;
            m.depth &&
              ((oe = m.stencil ? 35056 : 33190),
              (K = m.stencil ? qr : ji),
              (ie = m.stencil ? Or : Gi));
            const z = { colorFormat: 32856, depthFormat: oe, scaleFactor: r };
            (d = new XRWebGLBinding(i, t)),
              (f = d.createProjectionLayer(z)),
              i.updateRenderState({ layers: [f] }),
              (p = new Qi(f.textureWidth, f.textureHeight, {
                format: cn,
                type: Zi,
                depthTexture: new tM(
                  f.textureWidth,
                  f.textureHeight,
                  ie,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  K
                ),
                stencilBuffer: m.stencil,
                encoding: e.outputEncoding,
                samples: m.antialias ? 4 : 0,
              }));
            const we = e.properties.get(p);
            we.__ignoreDepthValues = f.ignoreDepthValues;
          }
          (p.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await i.requestReferenceSpace(o)),
            te.setContext(i),
            te.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      });
    function I(V) {
      for (let K = 0; K < V.removed.length; K++) {
        const ie = V.removed[K],
          oe = v.indexOf(ie);
        oe >= 0 && ((v[oe] = null), y[oe].disconnect(ie));
      }
      for (let K = 0; K < V.added.length; K++) {
        const ie = V.added[K];
        let oe = v.indexOf(ie);
        if (oe === -1) {
          for (let we = 0; we < y.length; we++)
            if (we >= v.length) {
              v.push(ie), (oe = we);
              break;
            } else if (v[we] === null) {
              (v[we] = ie), (oe = we);
              break;
            }
          if (oe === -1) break;
        }
        const z = y[oe];
        z && z.connect(ie);
      }
    }
    const U = new N(),
      H = new N();
    function Y(V, K, ie) {
      U.setFromMatrixPosition(K.matrixWorld),
        H.setFromMatrixPosition(ie.matrixWorld);
      const oe = U.distanceTo(H),
        z = K.projectionMatrix.elements,
        we = ie.projectionMatrix.elements,
        Me = z[14] / (z[10] - 1),
        se = z[14] / (z[10] + 1),
        xe = (z[9] + 1) / z[5],
        Be = (z[9] - 1) / z[5],
        pe = (z[8] - 1) / z[0],
        Re = (we[8] + 1) / we[0],
        ft = Me * pe,
        xt = Me * Re,
        ht = oe / (-pe + Re),
        ct = ht * -pe;
      K.matrixWorld.decompose(V.position, V.quaternion, V.scale),
        V.translateX(ct),
        V.translateZ(ht),
        V.matrixWorld.compose(V.position, V.quaternion, V.scale),
        V.matrixWorldInverse.copy(V.matrixWorld).invert();
      const Ve = Me + ht,
        et = se + ht,
        Ut = ft - ct,
        L = xt + (oe - ct),
        T = ((xe * se) / et) * Ve,
        G = ((Be * se) / et) * Ve;
      V.projectionMatrix.makePerspective(Ut, L, T, G, Ve, et),
        V.projectionMatrixInverse.copy(V.projectionMatrix).invert();
    }
    function B(V, K) {
      K === null
        ? V.matrixWorld.copy(V.matrix)
        : V.matrixWorld.multiplyMatrices(K.matrixWorld, V.matrix),
        V.matrixWorldInverse.copy(V.matrixWorld).invert();
    }
    this.updateCamera = function (V) {
      if (i === null) return;
      (M.near = A.near = w.near = V.near),
        (M.far = A.far = w.far = V.far),
        (b !== M.near || R !== M.far) &&
          (i.updateRenderState({ depthNear: M.near, depthFar: M.far }),
          (b = M.near),
          (R = M.far));
      const K = V.parent,
        ie = M.cameras;
      B(M, K);
      for (let oe = 0; oe < ie.length; oe++) B(ie[oe], K);
      ie.length === 2
        ? Y(M, w, A)
        : M.projectionMatrix.copy(w.projectionMatrix),
        Q(V, M, K);
    };
    function Q(V, K, ie) {
      ie === null
        ? V.matrix.copy(K.matrixWorld)
        : (V.matrix.copy(ie.matrixWorld),
          V.matrix.invert(),
          V.matrix.multiply(K.matrixWorld)),
        V.matrix.decompose(V.position, V.quaternion, V.scale),
        V.updateMatrixWorld(!0);
      const oe = V.children;
      for (let z = 0, we = oe.length; z < we; z++) oe[z].updateMatrixWorld(!0);
      V.projectionMatrix.copy(K.projectionMatrix),
        V.projectionMatrixInverse.copy(K.projectionMatrixInverse),
        V.isPerspectiveCamera &&
          ((V.fov = jr * 2 * Math.atan(1 / V.projectionMatrix.elements[5])),
          (V.zoom = 1));
    }
    (this.getCamera = function () {
      return M;
    }),
      (this.getFoveation = function () {
        if (!(f === null && h === null)) return l;
      }),
      (this.setFoveation = function (V) {
        (l = V),
          f !== null && (f.fixedFoveation = V),
          h !== null && h.fixedFoveation !== void 0 && (h.fixedFoveation = V);
      }),
      (this.getPlanes = function () {
        return x;
      });
    let Z = null;
    function me(V, K) {
      if (((u = K.getViewerPose(c || a)), (_ = K), u !== null)) {
        const ie = u.views;
        h !== null &&
          (e.setRenderTargetFramebuffer(p, h.framebuffer),
          e.setRenderTarget(p));
        let oe = !1;
        ie.length !== M.cameras.length && ((M.cameras.length = 0), (oe = !0));
        for (let z = 0; z < ie.length; z++) {
          const we = ie[z];
          let Me = null;
          if (h !== null) Me = h.getViewport(we);
          else {
            const xe = d.getViewSubImage(f, we);
            (Me = xe.viewport),
              z === 0 &&
                (e.setRenderTargetTextures(
                  p,
                  xe.colorTexture,
                  f.ignoreDepthValues ? void 0 : xe.depthStencilTexture
                ),
                e.setRenderTarget(p));
          }
          let se = C[z];
          se === void 0 &&
            ((se = new It()),
            se.layers.enable(z),
            (se.viewport = new Ye()),
            (C[z] = se)),
            se.matrix.fromArray(we.transform.matrix),
            se.matrix.decompose(se.position, se.quaternion, se.scale),
            se.projectionMatrix.fromArray(we.projectionMatrix),
            se.projectionMatrixInverse.copy(se.projectionMatrix).invert(),
            se.viewport.set(Me.x, Me.y, Me.width, Me.height),
            z === 0 &&
              (M.matrix.copy(se.matrix),
              M.matrix.decompose(M.position, M.quaternion, M.scale)),
            oe === !0 && M.cameras.push(se);
        }
      }
      for (let ie = 0; ie < y.length; ie++) {
        const oe = v[ie],
          z = y[ie];
        oe !== null && z !== void 0 && z.update(oe, K, c || a);
      }
      if ((Z && Z(V, K), K.detectedPlanes)) {
        n.dispatchEvent({ type: "planesdetected", data: K.detectedPlanes });
        let ie = null;
        for (const oe of x)
          K.detectedPlanes.has(oe) || (ie === null && (ie = []), ie.push(oe));
        if (ie !== null)
          for (const oe of ie)
            x.delete(oe),
              S.delete(oe),
              n.dispatchEvent({ type: "planeremoved", data: oe });
        for (const oe of K.detectedPlanes)
          if (!x.has(oe))
            x.add(oe),
              S.set(oe, K.lastChangedTime),
              n.dispatchEvent({ type: "planeadded", data: oe });
          else {
            const z = S.get(oe);
            oe.lastChangedTime > z &&
              (S.set(oe, oe.lastChangedTime),
              n.dispatchEvent({ type: "planechanged", data: oe }));
          }
      }
      _ = null;
    }
    const te = new gh();
    te.setAnimationLoop(me),
      (this.setAnimationLoop = function (V) {
        Z = V;
      }),
      (this.dispose = function () {});
  }
}
function iM(s, e) {
  function t(g, p) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), p.value.copy(g.matrix);
  }
  function n(g, p) {
    p.color.getRGB(g.fogColor.value, hh(s)),
      p.isFog
        ? ((g.fogNear.value = p.near), (g.fogFar.value = p.far))
        : p.isFogExp2 && (g.fogDensity.value = p.density);
  }
  function i(g, p, y, v, x) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial
      ? r(g, p)
      : p.isMeshToonMaterial
      ? (r(g, p), d(g, p))
      : p.isMeshPhongMaterial
      ? (r(g, p), u(g, p))
      : p.isMeshStandardMaterial
      ? (r(g, p), f(g, p), p.isMeshPhysicalMaterial && h(g, p, x))
      : p.isMeshMatcapMaterial
      ? (r(g, p), _(g, p))
      : p.isMeshDepthMaterial
      ? r(g, p)
      : p.isMeshDistanceMaterial
      ? (r(g, p), m(g, p))
      : p.isMeshNormalMaterial
      ? r(g, p)
      : p.isLineBasicMaterial
      ? (a(g, p), p.isLineDashedMaterial && o(g, p))
      : p.isPointsMaterial
      ? l(g, p, y, v)
      : p.isSpriteMaterial
      ? c(g, p)
      : p.isShadowMaterial
      ? (g.color.value.copy(p.color), (g.opacity.value = p.opacity))
      : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function r(g, p) {
    (g.opacity.value = p.opacity),
      p.color && g.diffuse.value.copy(p.color),
      p.emissive &&
        g.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
      p.map && ((g.map.value = p.map), t(p.map, g.mapTransform)),
      p.alphaMap &&
        ((g.alphaMap.value = p.alphaMap), t(p.alphaMap, g.alphaMapTransform)),
      p.bumpMap &&
        ((g.bumpMap.value = p.bumpMap),
        t(p.bumpMap, g.bumpMapTransform),
        (g.bumpScale.value = p.bumpScale),
        p.side === Gt && (g.bumpScale.value *= -1)),
      p.normalMap &&
        ((g.normalMap.value = p.normalMap),
        t(p.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(p.normalScale),
        p.side === Gt && g.normalScale.value.negate()),
      p.displacementMap &&
        ((g.displacementMap.value = p.displacementMap),
        t(p.displacementMap, g.displacementMapTransform),
        (g.displacementScale.value = p.displacementScale),
        (g.displacementBias.value = p.displacementBias)),
      p.emissiveMap &&
        ((g.emissiveMap.value = p.emissiveMap),
        t(p.emissiveMap, g.emissiveMapTransform)),
      p.specularMap &&
        ((g.specularMap.value = p.specularMap),
        t(p.specularMap, g.specularMapTransform)),
      p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
    const y = e.get(p).envMap;
    if (
      (y &&
        ((g.envMap.value = y),
        (g.flipEnvMap.value =
          y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
        (g.reflectivity.value = p.reflectivity),
        (g.ior.value = p.ior),
        (g.refractionRatio.value = p.refractionRatio)),
      p.lightMap)
    ) {
      g.lightMap.value = p.lightMap;
      const v = s.useLegacyLights === !0 ? Math.PI : 1;
      (g.lightMapIntensity.value = p.lightMapIntensity * v),
        t(p.lightMap, g.lightMapTransform);
    }
    p.aoMap &&
      ((g.aoMap.value = p.aoMap),
      (g.aoMapIntensity.value = p.aoMapIntensity),
      t(p.aoMap, g.aoMapTransform));
  }
  function a(g, p) {
    g.diffuse.value.copy(p.color),
      (g.opacity.value = p.opacity),
      p.map && ((g.map.value = p.map), t(p.map, g.mapTransform));
  }
  function o(g, p) {
    (g.dashSize.value = p.dashSize),
      (g.totalSize.value = p.dashSize + p.gapSize),
      (g.scale.value = p.scale);
  }
  function l(g, p, y, v) {
    g.diffuse.value.copy(p.color),
      (g.opacity.value = p.opacity),
      (g.size.value = p.size * y),
      (g.scale.value = v * 0.5),
      p.map && ((g.map.value = p.map), t(p.map, g.uvTransform)),
      p.alphaMap && (g.alphaMap.value = p.alphaMap),
      p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
  }
  function c(g, p) {
    g.diffuse.value.copy(p.color),
      (g.opacity.value = p.opacity),
      (g.rotation.value = p.rotation),
      p.map && ((g.map.value = p.map), t(p.map, g.mapTransform)),
      p.alphaMap && (g.alphaMap.value = p.alphaMap),
      p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
  }
  function u(g, p) {
    g.specular.value.copy(p.specular),
      (g.shininess.value = Math.max(p.shininess, 1e-4));
  }
  function d(g, p) {
    p.gradientMap && (g.gradientMap.value = p.gradientMap);
  }
  function f(g, p) {
    (g.metalness.value = p.metalness),
      p.metalnessMap &&
        ((g.metalnessMap.value = p.metalnessMap),
        t(p.metalnessMap, g.metalnessMapTransform)),
      (g.roughness.value = p.roughness),
      p.roughnessMap &&
        ((g.roughnessMap.value = p.roughnessMap),
        t(p.roughnessMap, g.roughnessMapTransform)),
      e.get(p).envMap && (g.envMapIntensity.value = p.envMapIntensity);
  }
  function h(g, p, y) {
    (g.ior.value = p.ior),
      p.sheen > 0 &&
        (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        (g.sheenRoughness.value = p.sheenRoughness),
        p.sheenColorMap &&
          ((g.sheenColorMap.value = p.sheenColorMap),
          t(p.sheenColorMap, g.sheenColorMapTransform)),
        p.sheenRoughnessMap &&
          ((g.sheenRoughnessMap.value = p.sheenRoughnessMap),
          t(p.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
      p.clearcoat > 0 &&
        ((g.clearcoat.value = p.clearcoat),
        (g.clearcoatRoughness.value = p.clearcoatRoughness),
        p.clearcoatMap &&
          ((g.clearcoatMap.value = p.clearcoatMap),
          t(p.clearcoatMap, g.clearcoatMapTransform)),
        p.clearcoatRoughnessMap &&
          ((g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
          t(p.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap &&
          ((g.clearcoatNormalMap.value = p.clearcoatNormalMap),
          t(p.clearcoatNormalMap, g.clearcoatNormalMapTransform),
          g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
          p.side === Gt && g.clearcoatNormalScale.value.negate())),
      p.iridescence > 0 &&
        ((g.iridescence.value = p.iridescence),
        (g.iridescenceIOR.value = p.iridescenceIOR),
        (g.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0]),
        (g.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1]),
        p.iridescenceMap &&
          ((g.iridescenceMap.value = p.iridescenceMap),
          t(p.iridescenceMap, g.iridescenceMapTransform)),
        p.iridescenceThicknessMap &&
          ((g.iridescenceThicknessMap.value = p.iridescenceThicknessMap),
          t(p.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
      p.transmission > 0 &&
        ((g.transmission.value = p.transmission),
        (g.transmissionSamplerMap.value = y.texture),
        g.transmissionSamplerSize.value.set(y.width, y.height),
        p.transmissionMap &&
          ((g.transmissionMap.value = p.transmissionMap),
          t(p.transmissionMap, g.transmissionMapTransform)),
        (g.thickness.value = p.thickness),
        p.thicknessMap &&
          ((g.thicknessMap.value = p.thicknessMap),
          t(p.thicknessMap, g.thicknessMapTransform)),
        (g.attenuationDistance.value = p.attenuationDistance),
        g.attenuationColor.value.copy(p.attenuationColor)),
      (g.specularIntensity.value = p.specularIntensity),
      g.specularColor.value.copy(p.specularColor),
      p.specularColorMap &&
        ((g.specularColorMap.value = p.specularColorMap),
        t(p.specularColorMap, g.specularColorMapTransform)),
      p.specularIntensityMap &&
        ((g.specularIntensityMap.value = p.specularIntensityMap),
        t(p.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function _(g, p) {
    p.matcap && (g.matcap.value = p.matcap);
  }
  function m(g, p) {
    const y = e.get(p).light;
    g.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (g.nearDistance.value = y.shadow.camera.near),
      (g.farDistance.value = y.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function rM(s, e, t, n) {
  let i = {},
    r = {},
    a = [];
  const o = t.isWebGL2 ? s.getParameter(35375) : 0;
  function l(y, v) {
    const x = v.program;
    n.uniformBlockBinding(y, x);
  }
  function c(y, v) {
    let x = i[y.id];
    x === void 0 &&
      (_(y), (x = u(y)), (i[y.id] = x), y.addEventListener("dispose", g));
    const S = v.program;
    n.updateUBOMapping(y, S);
    const w = e.render.frame;
    r[y.id] !== w && (f(y), (r[y.id] = w));
  }
  function u(y) {
    const v = d();
    y.__bindingPointIndex = v;
    const x = s.createBuffer(),
      S = y.__size,
      w = y.usage;
    return (
      s.bindBuffer(35345, x),
      s.bufferData(35345, S, w),
      s.bindBuffer(35345, null),
      s.bindBufferBase(35345, v, x),
      x
    );
  }
  function d() {
    for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return a.push(y), y;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function f(y) {
    const v = i[y.id],
      x = y.uniforms,
      S = y.__cache;
    s.bindBuffer(35345, v);
    for (let w = 0, A = x.length; w < A; w++) {
      const C = x[w];
      if (h(C, w, S) === !0) {
        const M = C.__offset,
          b = Array.isArray(C.value) ? C.value : [C.value];
        let R = 0;
        for (let D = 0; D < b.length; D++) {
          const P = b[D],
            I = m(P);
          typeof P == "number"
            ? ((C.__data[0] = P), s.bufferSubData(35345, M + R, C.__data))
            : P.isMatrix3
            ? ((C.__data[0] = P.elements[0]),
              (C.__data[1] = P.elements[1]),
              (C.__data[2] = P.elements[2]),
              (C.__data[3] = P.elements[0]),
              (C.__data[4] = P.elements[3]),
              (C.__data[5] = P.elements[4]),
              (C.__data[6] = P.elements[5]),
              (C.__data[7] = P.elements[0]),
              (C.__data[8] = P.elements[6]),
              (C.__data[9] = P.elements[7]),
              (C.__data[10] = P.elements[8]),
              (C.__data[11] = P.elements[0]))
            : (P.toArray(C.__data, R),
              (R += I.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        s.bufferSubData(35345, M, C.__data);
      }
    }
    s.bindBuffer(35345, null);
  }
  function h(y, v, x) {
    const S = y.value;
    if (x[v] === void 0) {
      if (typeof S == "number") x[v] = S;
      else {
        const w = Array.isArray(S) ? S : [S],
          A = [];
        for (let C = 0; C < w.length; C++) A.push(w[C].clone());
        x[v] = A;
      }
      return !0;
    } else if (typeof S == "number") {
      if (x[v] !== S) return (x[v] = S), !0;
    } else {
      const w = Array.isArray(x[v]) ? x[v] : [x[v]],
        A = Array.isArray(S) ? S : [S];
      for (let C = 0; C < w.length; C++) {
        const M = w[C];
        if (M.equals(A[C]) === !1) return M.copy(A[C]), !0;
      }
    }
    return !1;
  }
  function _(y) {
    const v = y.uniforms;
    let x = 0;
    const S = 16;
    let w = 0;
    for (let A = 0, C = v.length; A < C; A++) {
      const M = v[A],
        b = { boundary: 0, storage: 0 },
        R = Array.isArray(M.value) ? M.value : [M.value];
      for (let D = 0, P = R.length; D < P; D++) {
        const I = R[D],
          U = m(I);
        (b.boundary += U.boundary), (b.storage += U.storage);
      }
      if (
        ((M.__data = new Float32Array(
          b.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (M.__offset = x),
        A > 0)
      ) {
        w = x % S;
        const D = S - w;
        w !== 0 && D - b.boundary < 0 && ((x += S - w), (M.__offset = x));
      }
      x += b.storage;
    }
    return (
      (w = x % S), w > 0 && (x += S - w), (y.__size = x), (y.__cache = {}), this
    );
  }
  function m(y) {
    const v = { boundary: 0, storage: 0 };
    return (
      typeof y == "number"
        ? ((v.boundary = 4), (v.storage = 4))
        : y.isVector2
        ? ((v.boundary = 8), (v.storage = 8))
        : y.isVector3 || y.isColor
        ? ((v.boundary = 16), (v.storage = 12))
        : y.isVector4
        ? ((v.boundary = 16), (v.storage = 16))
        : y.isMatrix3
        ? ((v.boundary = 48), (v.storage = 48))
        : y.isMatrix4
        ? ((v.boundary = 64), (v.storage = 64))
        : y.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            y
          ),
      v
    );
  }
  function g(y) {
    const v = y.target;
    v.removeEventListener("dispose", g);
    const x = a.indexOf(v.__bindingPointIndex);
    a.splice(x, 1), s.deleteBuffer(i[v.id]), delete i[v.id], delete r[v.id];
  }
  function p() {
    for (const y in i) s.deleteBuffer(i[y]);
    (a = []), (i = {}), (r = {});
  }
  return { bind: l, update: c, dispose: p };
}
function sM() {
  const s = Is("canvas");
  return (s.style.display = "block"), s;
}
class Sh {
  constructor(e = {}) {
    const {
      canvas: t = sM(),
      context: n = null,
      depth: i = !0,
      stencil: r = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    n !== null ? (f = n.getContextAttributes().alpha) : (f = a);
    let h = null,
      _ = null;
    const m = [],
      g = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputEncoding = Ji),
      (this.useLegacyLights = !0),
      (this.toneMapping = jn),
      (this.toneMappingExposure = 1);
    const p = this;
    let y = !1,
      v = 0,
      x = 0,
      S = null,
      w = -1,
      A = null;
    const C = new Ye(),
      M = new Ye();
    let b = null,
      R = t.width,
      D = t.height,
      P = 1,
      I = null,
      U = null;
    const H = new Ye(0, 0, R, D),
      Y = new Ye(0, 0, R, D);
    let B = !1;
    const Q = new Kl();
    let Z = !1,
      me = !1,
      te = null;
    const V = new Le(),
      K = new N(),
      ie = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function oe() {
      return S === null ? P : 1;
    }
    let z = n;
    function we(E, k) {
      for (let W = 0; W < E.length; W++) {
        const F = E[W],
          j = t.getContext(F, k);
        if (j !== null) return j;
      }
      return null;
    }
    try {
      const E = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${jl}`),
        t.addEventListener("webglcontextlost", he, !1),
        t.addEventListener("webglcontextrestored", Ue, !1),
        t.addEventListener("webglcontextcreationerror", He, !1),
        z === null)
      ) {
        const k = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (p.isWebGL1Renderer === !0 && k.shift(), (z = we(k, E)), z === null)
        )
          throw we(k)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      z.getShaderPrecisionFormat === void 0 &&
        (z.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (E) {
      throw (console.error("THREE.WebGLRenderer: " + E.message), E);
    }
    let Me,
      se,
      xe,
      Be,
      pe,
      Re,
      ft,
      xt,
      ht,
      ct,
      Ve,
      et,
      Ut,
      L,
      T,
      G,
      ee,
      ne,
      ae,
      ye,
      ue,
      X,
      fe,
      ge;
    function ve() {
      (Me = new gy(z)),
        (se = new uy(z, Me, e)),
        Me.init(se),
        (X = new JS(z, Me, se)),
        (xe = new KS(z, Me, se)),
        (Be = new xy()),
        (pe = new US()),
        (Re = new ZS(z, Me, xe, pe, se, X, Be)),
        (ft = new fy(p)),
        (xt = new my(p)),
        (ht = new R0(z, se)),
        (fe = new ly(z, Me, ht, se)),
        (ct = new _y(z, ht, Be, fe)),
        (Ve = new by(z, ct, ht, Be)),
        (ae = new My(z, se, Re)),
        (G = new dy(pe)),
        (et = new NS(p, ft, xt, Me, se, fe, G)),
        (Ut = new iM(p, pe)),
        (L = new kS()),
        (T = new WS(Me, se)),
        (ne = new oy(p, ft, xt, xe, Ve, f, l)),
        (ee = new $S(p, Ve, se)),
        (ge = new rM(z, Be, se, xe)),
        (ye = new cy(z, Me, Be, se)),
        (ue = new vy(z, Me, Be, se)),
        (Be.programs = et.programs),
        (p.capabilities = se),
        (p.extensions = Me),
        (p.properties = pe),
        (p.renderLists = L),
        (p.shadowMap = ee),
        (p.state = xe),
        (p.info = Be);
    }
    ve();
    const ce = new nM(p, z);
    (this.xr = ce),
      (this.getContext = function () {
        return z;
      }),
      (this.getContextAttributes = function () {
        return z.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const E = Me.get("WEBGL_lose_context");
        E && E.loseContext();
      }),
      (this.forceContextRestore = function () {
        const E = Me.get("WEBGL_lose_context");
        E && E.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return P;
      }),
      (this.setPixelRatio = function (E) {
        E !== void 0 && ((P = E), this.setSize(R, D, !1));
      }),
      (this.getSize = function (E) {
        return E.set(R, D);
      }),
      (this.setSize = function (E, k, W = !0) {
        if (ce.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (R = E),
          (D = k),
          (t.width = Math.floor(E * P)),
          (t.height = Math.floor(k * P)),
          W === !0 && ((t.style.width = E + "px"), (t.style.height = k + "px")),
          this.setViewport(0, 0, E, k);
      }),
      (this.getDrawingBufferSize = function (E) {
        return E.set(R * P, D * P).floor();
      }),
      (this.setDrawingBufferSize = function (E, k, W) {
        (R = E),
          (D = k),
          (P = W),
          (t.width = Math.floor(E * W)),
          (t.height = Math.floor(k * W)),
          this.setViewport(0, 0, E, k);
      }),
      (this.getCurrentViewport = function (E) {
        return E.copy(C);
      }),
      (this.getViewport = function (E) {
        return E.copy(H);
      }),
      (this.setViewport = function (E, k, W, F) {
        E.isVector4 ? H.set(E.x, E.y, E.z, E.w) : H.set(E, k, W, F),
          xe.viewport(C.copy(H).multiplyScalar(P).floor());
      }),
      (this.getScissor = function (E) {
        return E.copy(Y);
      }),
      (this.setScissor = function (E, k, W, F) {
        E.isVector4 ? Y.set(E.x, E.y, E.z, E.w) : Y.set(E, k, W, F),
          xe.scissor(M.copy(Y).multiplyScalar(P).floor());
      }),
      (this.getScissorTest = function () {
        return B;
      }),
      (this.setScissorTest = function (E) {
        xe.setScissorTest((B = E));
      }),
      (this.setOpaqueSort = function (E) {
        I = E;
      }),
      (this.setTransparentSort = function (E) {
        U = E;
      }),
      (this.getClearColor = function (E) {
        return E.copy(ne.getClearColor());
      }),
      (this.setClearColor = function () {
        ne.setClearColor.apply(ne, arguments);
      }),
      (this.getClearAlpha = function () {
        return ne.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        ne.setClearAlpha.apply(ne, arguments);
      }),
      (this.clear = function (E = !0, k = !0, W = !0) {
        let F = 0;
        E && (F |= 16384), k && (F |= 256), W && (F |= 1024), z.clear(F);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", he, !1),
          t.removeEventListener("webglcontextrestored", Ue, !1),
          t.removeEventListener("webglcontextcreationerror", He, !1),
          L.dispose(),
          T.dispose(),
          pe.dispose(),
          ft.dispose(),
          xt.dispose(),
          Ve.dispose(),
          fe.dispose(),
          ge.dispose(),
          et.dispose(),
          ce.dispose(),
          ce.removeEventListener("sessionstart", de),
          ce.removeEventListener("sessionend", $e),
          te && (te.dispose(), (te = null)),
          Ke.stop();
      });
    function he(E) {
      E.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (y = !0);
    }
    function Ue() {
      console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
      const E = Be.autoReset,
        k = ee.enabled,
        W = ee.autoUpdate,
        F = ee.needsUpdate,
        j = ee.type;
      ve(),
        (Be.autoReset = E),
        (ee.enabled = k),
        (ee.autoUpdate = W),
        (ee.needsUpdate = F),
        (ee.type = j);
    }
    function He(E) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        E.statusMessage
      );
    }
    function it(E) {
      const k = E.target;
      k.removeEventListener("dispose", it), O(k);
    }
    function O(E) {
      q(E), pe.remove(E);
    }
    function q(E) {
      const k = pe.get(E).programs;
      k !== void 0 &&
        (k.forEach(function (W) {
          et.releaseProgram(W);
        }),
        E.isShaderMaterial && et.releaseShaderCache(E));
    }
    (this.renderBufferDirect = function (E, k, W, F, j, _e) {
      k === null && (k = ie);
      const Se = j.isMesh && j.matrixWorld.determinant() < 0,
        be = Ih(E, k, W, F, j);
      xe.setMaterial(F, Se);
      let Ee = W.index,
        Ce = 1;
      F.wireframe === !0 && ((Ee = ct.getWireframeAttribute(W)), (Ce = 2));
      const Pe = W.drawRange,
        De = W.attributes.position;
      let We = Pe.start * Ce,
        Pt = (Pe.start + Pe.count) * Ce;
      _e !== null &&
        ((We = Math.max(We, _e.start * Ce)),
        (Pt = Math.min(Pt, (_e.start + _e.count) * Ce))),
        Ee !== null
          ? ((We = Math.max(We, 0)), (Pt = Math.min(Pt, Ee.count)))
          : De != null &&
            ((We = Math.max(We, 0)), (Pt = Math.min(Pt, De.count)));
      const hn = Pt - We;
      if (hn < 0 || hn === 1 / 0) return;
      fe.setup(j, F, be, W, Ee);
      let Ti,
        at = ye;
      if (
        (Ee !== null && ((Ti = ht.get(Ee)), (at = ue), at.setIndex(Ti)),
        j.isMesh)
      )
        F.wireframe === !0
          ? (xe.setLineWidth(F.wireframeLinewidth * oe()), at.setMode(1))
          : at.setMode(4);
      else if (j.isLine) {
        let Fe = F.linewidth;
        Fe === void 0 && (Fe = 1),
          xe.setLineWidth(Fe * oe()),
          j.isLineSegments
            ? at.setMode(1)
            : j.isLineLoop
            ? at.setMode(2)
            : at.setMode(3);
      } else j.isPoints ? at.setMode(0) : j.isSprite && at.setMode(4);
      if (j.isInstancedMesh) at.renderInstances(We, hn, j.count);
      else if (W.isInstancedBufferGeometry) {
        const Fe = W._maxInstanceCount !== void 0 ? W._maxInstanceCount : 1 / 0,
          qa = Math.min(W.instanceCount, Fe);
        at.renderInstances(We, hn, qa);
      } else at.render(We, hn);
    }),
      (this.compile = function (E, k) {
        function W(F, j, _e) {
          F.transparent === !0 && F.side === wn && F.forceSinglePass === !1
            ? ((F.side = Gt),
              (F.needsUpdate = !0),
              Bs(F, j, _e),
              (F.side = Zn),
              (F.needsUpdate = !0),
              Bs(F, j, _e),
              (F.side = wn))
            : Bs(F, j, _e);
        }
        (_ = T.get(E)),
          _.init(),
          g.push(_),
          E.traverseVisible(function (F) {
            F.isLight &&
              F.layers.test(k.layers) &&
              (_.pushLight(F), F.castShadow && _.pushShadow(F));
          }),
          _.setupLights(p.useLegacyLights),
          E.traverse(function (F) {
            const j = F.material;
            if (j)
              if (Array.isArray(j))
                for (let _e = 0; _e < j.length; _e++) {
                  const Se = j[_e];
                  W(Se, E, F);
                }
              else W(j, E, F);
          }),
          g.pop(),
          (_ = null);
      });
    let J = null;
    function le(E) {
      J && J(E);
    }
    function de() {
      Ke.stop();
    }
    function $e() {
      Ke.start();
    }
    const Ke = new gh();
    Ke.setAnimationLoop(le),
      typeof self != "undefined" && Ke.setContext(self),
      (this.setAnimationLoop = function (E) {
        (J = E), ce.setAnimationLoop(E), E === null ? Ke.stop() : Ke.start();
      }),
      ce.addEventListener("sessionstart", de),
      ce.addEventListener("sessionend", $e),
      (this.render = function (E, k) {
        if (k !== void 0 && k.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (y === !0) return;
        E.matrixWorldAutoUpdate === !0 && E.updateMatrixWorld(),
          k.parent === null &&
            k.matrixWorldAutoUpdate === !0 &&
            k.updateMatrixWorld(),
          ce.enabled === !0 &&
            ce.isPresenting === !0 &&
            (ce.cameraAutoUpdate === !0 && ce.updateCamera(k),
            (k = ce.getCamera())),
          E.isScene === !0 && E.onBeforeRender(p, E, k, S),
          (_ = T.get(E, g.length)),
          _.init(),
          g.push(_),
          V.multiplyMatrices(k.projectionMatrix, k.matrixWorldInverse),
          Q.setFromProjectionMatrix(V),
          (me = this.localClippingEnabled),
          (Z = G.init(this.clippingPlanes, me)),
          (h = L.get(E, m.length)),
          h.init(),
          m.push(h),
          St(E, k, 0, p.sortObjects),
          h.finish(),
          p.sortObjects === !0 && h.sort(I, U),
          Z === !0 && G.beginShadows();
        const W = _.state.shadowsArray;
        if (
          (ee.render(W, E, k),
          Z === !0 && G.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          ne.render(h, E),
          _.setupLights(p.useLegacyLights),
          k.isArrayCamera)
        ) {
          const F = k.cameras;
          for (let j = 0, _e = F.length; j < _e; j++) {
            const Se = F[j];
            ei(h, E, Se, Se.viewport);
          }
        } else ei(h, E, k);
        S !== null &&
          (Re.updateMultisampleRenderTarget(S), Re.updateRenderTargetMipmap(S)),
          E.isScene === !0 && E.onAfterRender(p, E, k),
          fe.resetDefaultState(),
          (w = -1),
          (A = null),
          g.pop(),
          g.length > 0 ? (_ = g[g.length - 1]) : (_ = null),
          m.pop(),
          m.length > 0 ? (h = m[m.length - 1]) : (h = null);
      });
    function St(E, k, W, F) {
      if (E.visible === !1) return;
      if (E.layers.test(k.layers)) {
        if (E.isGroup) W = E.renderOrder;
        else if (E.isLOD) E.autoUpdate === !0 && E.update(k);
        else if (E.isLight) _.pushLight(E), E.castShadow && _.pushShadow(E);
        else if (E.isSprite) {
          if (!E.frustumCulled || Q.intersectsSprite(E)) {
            F && K.setFromMatrixPosition(E.matrixWorld).applyMatrix4(V);
            const Se = Ve.update(E),
              be = E.material;
            be.visible && h.push(E, Se, be, W, K.z, null);
          }
        } else if (
          (E.isMesh || E.isLine || E.isPoints) &&
          (E.isSkinnedMesh &&
            E.skeleton.frame !== Be.render.frame &&
            (E.skeleton.update(), (E.skeleton.frame = Be.render.frame)),
          !E.frustumCulled || Q.intersectsObject(E))
        ) {
          F && K.setFromMatrixPosition(E.matrixWorld).applyMatrix4(V);
          const Se = Ve.update(E),
            be = E.material;
          if (Array.isArray(be)) {
            const Ee = Se.groups;
            for (let Ce = 0, Pe = Ee.length; Ce < Pe; Ce++) {
              const De = Ee[Ce],
                We = be[De.materialIndex];
              We && We.visible && h.push(E, Se, We, W, K.z, De);
            }
          } else be.visible && h.push(E, Se, be, W, K.z, null);
        }
      }
      const _e = E.children;
      for (let Se = 0, be = _e.length; Se < be; Se++) St(_e[Se], k, W, F);
    }
    function ei(E, k, W, F) {
      const j = E.opaque,
        _e = E.transmissive,
        Se = E.transparent;
      _.setupLightsView(W),
        Z === !0 && G.setGlobalState(p.clippingPlanes, W),
        _e.length > 0 && rt(j, _e, k, W),
        F && xe.viewport(C.copy(F)),
        j.length > 0 && tn(j, k, W),
        _e.length > 0 && tn(_e, k, W),
        Se.length > 0 && tn(Se, k, W),
        xe.buffers.depth.setTest(!0),
        xe.buffers.depth.setMask(!0),
        xe.buffers.color.setMask(!0),
        xe.setPolygonOffset(!1);
    }
    function rt(E, k, W, F) {
      if (te === null) {
        const be = se.isWebGL2;
        te = new Qi(1024, 1024, {
          generateMipmaps: !0,
          type: Me.has("EXT_color_buffer_half_float") ? Ls : Zi,
          minFilter: Ki,
          samples: be && o === !0 ? 4 : 0,
        });
      }
      const j = p.getRenderTarget();
      p.setRenderTarget(te), p.clear();
      const _e = p.toneMapping;
      (p.toneMapping = jn),
        tn(E, W, F),
        Re.updateMultisampleRenderTarget(te),
        Re.updateRenderTargetMipmap(te);
      let Se = !1;
      for (let be = 0, Ee = k.length; be < Ee; be++) {
        const Ce = k[be],
          Pe = Ce.object,
          De = Ce.geometry,
          We = Ce.material,
          Pt = Ce.group;
        if (We.side === wn && Pe.layers.test(F.layers)) {
          const hn = We.side;
          (We.side = Gt),
            (We.needsUpdate = !0),
            xn(Pe, W, F, De, We, Pt),
            (We.side = hn),
            (We.needsUpdate = !0),
            (Se = !0);
        }
      }
      Se === !0 &&
        (Re.updateMultisampleRenderTarget(te), Re.updateRenderTargetMipmap(te)),
        p.setRenderTarget(j),
        (p.toneMapping = _e);
    }
    function tn(E, k, W) {
      const F = k.isScene === !0 ? k.overrideMaterial : null;
      for (let j = 0, _e = E.length; j < _e; j++) {
        const Se = E[j],
          be = Se.object,
          Ee = Se.geometry,
          Ce = F === null ? Se.material : F,
          Pe = Se.group;
        be.layers.test(W.layers) && xn(be, k, W, Ee, Ce, Pe);
      }
    }
    function xn(E, k, W, F, j, _e) {
      E.onBeforeRender(p, k, W, F, j, _e),
        E.modelViewMatrix.multiplyMatrices(W.matrixWorldInverse, E.matrixWorld),
        E.normalMatrix.getNormalMatrix(E.modelViewMatrix),
        j.onBeforeRender(p, k, W, F, E, _e),
        j.transparent === !0 && j.side === wn && j.forceSinglePass === !1
          ? ((j.side = Gt),
            (j.needsUpdate = !0),
            p.renderBufferDirect(W, k, F, j, E, _e),
            (j.side = Zn),
            (j.needsUpdate = !0),
            p.renderBufferDirect(W, k, F, j, E, _e),
            (j.side = wn))
          : p.renderBufferDirect(W, k, F, j, E, _e),
        E.onAfterRender(p, k, W, F, j, _e);
    }
    function Bs(E, k, W) {
      k.isScene !== !0 && (k = ie);
      const F = pe.get(E),
        j = _.state.lights,
        _e = _.state.shadowsArray,
        Se = j.state.version,
        be = et.getParameters(E, j.state, _e, k, W),
        Ee = et.getProgramCacheKey(be);
      let Ce = F.programs;
      (F.environment = E.isMeshStandardMaterial ? k.environment : null),
        (F.fog = k.fog),
        (F.envMap = (E.isMeshStandardMaterial ? xt : ft).get(
          E.envMap || F.environment
        )),
        Ce === void 0 &&
          (E.addEventListener("dispose", it),
          (Ce = new Map()),
          (F.programs = Ce));
      let Pe = Ce.get(Ee);
      if (Pe !== void 0) {
        if (F.currentProgram === Pe && F.lightsStateVersion === Se)
          return oc(E, be), Pe;
      } else
        (be.uniforms = et.getUniforms(E)),
          E.onBuild(W, be, p),
          E.onBeforeCompile(be, p),
          (Pe = et.acquireProgram(be, Ee)),
          Ce.set(Ee, Pe),
          (F.uniforms = be.uniforms);
      const De = F.uniforms;
      ((!E.isShaderMaterial && !E.isRawShaderMaterial) || E.clipping === !0) &&
        (De.clippingPlanes = G.uniform),
        oc(E, be),
        (F.needsLights = Nh(E)),
        (F.lightsStateVersion = Se),
        F.needsLights &&
          ((De.ambientLightColor.value = j.state.ambient),
          (De.lightProbe.value = j.state.probe),
          (De.directionalLights.value = j.state.directional),
          (De.directionalLightShadows.value = j.state.directionalShadow),
          (De.spotLights.value = j.state.spot),
          (De.spotLightShadows.value = j.state.spotShadow),
          (De.rectAreaLights.value = j.state.rectArea),
          (De.ltc_1.value = j.state.rectAreaLTC1),
          (De.ltc_2.value = j.state.rectAreaLTC2),
          (De.pointLights.value = j.state.point),
          (De.pointLightShadows.value = j.state.pointShadow),
          (De.hemisphereLights.value = j.state.hemi),
          (De.directionalShadowMap.value = j.state.directionalShadowMap),
          (De.directionalShadowMatrix.value = j.state.directionalShadowMatrix),
          (De.spotShadowMap.value = j.state.spotShadowMap),
          (De.spotLightMatrix.value = j.state.spotLightMatrix),
          (De.spotLightMap.value = j.state.spotLightMap),
          (De.pointShadowMap.value = j.state.pointShadowMap),
          (De.pointShadowMatrix.value = j.state.pointShadowMatrix));
      const We = Pe.getUniforms(),
        Pt = Sa.seqWithValue(We.seq, De);
      return (F.currentProgram = Pe), (F.uniformsList = Pt), Pe;
    }
    function oc(E, k) {
      const W = pe.get(E);
      (W.outputEncoding = k.outputEncoding),
        (W.instancing = k.instancing),
        (W.skinning = k.skinning),
        (W.morphTargets = k.morphTargets),
        (W.morphNormals = k.morphNormals),
        (W.morphColors = k.morphColors),
        (W.morphTargetsCount = k.morphTargetsCount),
        (W.numClippingPlanes = k.numClippingPlanes),
        (W.numIntersection = k.numClipIntersection),
        (W.vertexAlphas = k.vertexAlphas),
        (W.vertexTangents = k.vertexTangents),
        (W.toneMapping = k.toneMapping);
    }
    function Ih(E, k, W, F, j) {
      k.isScene !== !0 && (k = ie), Re.resetTextureUnits();
      const _e = k.fog,
        Se = F.isMeshStandardMaterial ? k.environment : null,
        be =
          S === null
            ? p.outputEncoding
            : S.isXRRenderTarget === !0
            ? S.texture.encoding
            : Ji,
        Ee = (F.isMeshStandardMaterial ? xt : ft).get(F.envMap || Se),
        Ce =
          F.vertexColors === !0 &&
          !!W.attributes.color &&
          W.attributes.color.itemSize === 4,
        Pe = !!F.normalMap && !!W.attributes.tangent,
        De = !!W.morphAttributes.position,
        We = !!W.morphAttributes.normal,
        Pt = !!W.morphAttributes.color,
        hn = F.toneMapped ? p.toneMapping : jn,
        Ti =
          W.morphAttributes.position ||
          W.morphAttributes.normal ||
          W.morphAttributes.color,
        at = Ti !== void 0 ? Ti.length : 0,
        Fe = pe.get(F),
        qa = _.state.lights;
      if (Z === !0 && (me === !0 || E !== A)) {
        const Wt = E === A && F.id === w;
        G.setState(F, E, Wt);
      }
      let pt = !1;
      F.version === Fe.__version
        ? ((Fe.needsLights && Fe.lightsStateVersion !== qa.state.version) ||
            Fe.outputEncoding !== be ||
            (j.isInstancedMesh && Fe.instancing === !1) ||
            (!j.isInstancedMesh && Fe.instancing === !0) ||
            (j.isSkinnedMesh && Fe.skinning === !1) ||
            (!j.isSkinnedMesh && Fe.skinning === !0) ||
            Fe.envMap !== Ee ||
            (F.fog === !0 && Fe.fog !== _e) ||
            (Fe.numClippingPlanes !== void 0 &&
              (Fe.numClippingPlanes !== G.numPlanes ||
                Fe.numIntersection !== G.numIntersection)) ||
            Fe.vertexAlphas !== Ce ||
            Fe.vertexTangents !== Pe ||
            Fe.morphTargets !== De ||
            Fe.morphNormals !== We ||
            Fe.morphColors !== Pt ||
            Fe.toneMapping !== hn ||
            (se.isWebGL2 === !0 && Fe.morphTargetsCount !== at)) &&
          (pt = !0)
        : ((pt = !0), (Fe.__version = F.version));
      let Ei = Fe.currentProgram;
      pt === !0 && (Ei = Bs(F, k, j));
      let lc = !1,
        es = !1,
        Xa = !1;
      const Lt = Ei.getUniforms(),
        Ai = Fe.uniforms;
      if (
        (xe.useProgram(Ei.program) && ((lc = !0), (es = !0), (Xa = !0)),
        F.id !== w && ((w = F.id), (es = !0)),
        lc || A !== E)
      ) {
        if (
          (Lt.setValue(z, "projectionMatrix", E.projectionMatrix),
          se.logarithmicDepthBuffer &&
            Lt.setValue(
              z,
              "logDepthBufFC",
              2 / (Math.log(E.far + 1) / Math.LN2)
            ),
          A !== E && ((A = E), (es = !0), (Xa = !0)),
          F.isShaderMaterial ||
            F.isMeshPhongMaterial ||
            F.isMeshToonMaterial ||
            F.isMeshStandardMaterial ||
            F.envMap)
        ) {
          const Wt = Lt.map.cameraPosition;
          Wt !== void 0 &&
            Wt.setValue(z, K.setFromMatrixPosition(E.matrixWorld));
        }
        (F.isMeshPhongMaterial ||
          F.isMeshToonMaterial ||
          F.isMeshLambertMaterial ||
          F.isMeshBasicMaterial ||
          F.isMeshStandardMaterial ||
          F.isShaderMaterial) &&
          Lt.setValue(z, "isOrthographic", E.isOrthographicCamera === !0),
          (F.isMeshPhongMaterial ||
            F.isMeshToonMaterial ||
            F.isMeshLambertMaterial ||
            F.isMeshBasicMaterial ||
            F.isMeshStandardMaterial ||
            F.isShaderMaterial ||
            F.isShadowMaterial ||
            j.isSkinnedMesh) &&
            Lt.setValue(z, "viewMatrix", E.matrixWorldInverse);
      }
      if (j.isSkinnedMesh) {
        Lt.setOptional(z, j, "bindMatrix"),
          Lt.setOptional(z, j, "bindMatrixInverse");
        const Wt = j.skeleton;
        Wt &&
          (se.floatVertexTextures
            ? (Wt.boneTexture === null && Wt.computeBoneTexture(),
              Lt.setValue(z, "boneTexture", Wt.boneTexture, Re),
              Lt.setValue(z, "boneTextureSize", Wt.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const ja = W.morphAttributes;
      if (
        ((ja.position !== void 0 ||
          ja.normal !== void 0 ||
          (ja.color !== void 0 && se.isWebGL2 === !0)) &&
          ae.update(j, W, Ei),
        (es || Fe.receiveShadow !== j.receiveShadow) &&
          ((Fe.receiveShadow = j.receiveShadow),
          Lt.setValue(z, "receiveShadow", j.receiveShadow)),
        F.isMeshGouraudMaterial &&
          F.envMap !== null &&
          ((Ai.envMap.value = Ee),
          (Ai.flipEnvMap.value =
            Ee.isCubeTexture && Ee.isRenderTargetTexture === !1 ? -1 : 1)),
        es &&
          (Lt.setValue(z, "toneMappingExposure", p.toneMappingExposure),
          Fe.needsLights && Oh(Ai, Xa),
          _e && F.fog === !0 && Ut.refreshFogUniforms(Ai, _e),
          Ut.refreshMaterialUniforms(Ai, F, P, D, te),
          Sa.upload(z, Fe.uniformsList, Ai, Re)),
        F.isShaderMaterial &&
          F.uniformsNeedUpdate === !0 &&
          (Sa.upload(z, Fe.uniformsList, Ai, Re), (F.uniformsNeedUpdate = !1)),
        F.isSpriteMaterial && Lt.setValue(z, "center", j.center),
        Lt.setValue(z, "modelViewMatrix", j.modelViewMatrix),
        Lt.setValue(z, "normalMatrix", j.normalMatrix),
        Lt.setValue(z, "modelMatrix", j.matrixWorld),
        F.isShaderMaterial || F.isRawShaderMaterial)
      ) {
        const Wt = F.uniformsGroups;
        for (let Ya = 0, Uh = Wt.length; Ya < Uh; Ya++)
          if (se.isWebGL2) {
            const cc = Wt[Ya];
            ge.update(cc, Ei), ge.bind(cc, Ei);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return Ei;
    }
    function Oh(E, k) {
      (E.ambientLightColor.needsUpdate = k),
        (E.lightProbe.needsUpdate = k),
        (E.directionalLights.needsUpdate = k),
        (E.directionalLightShadows.needsUpdate = k),
        (E.pointLights.needsUpdate = k),
        (E.pointLightShadows.needsUpdate = k),
        (E.spotLights.needsUpdate = k),
        (E.spotLightShadows.needsUpdate = k),
        (E.rectAreaLights.needsUpdate = k),
        (E.hemisphereLights.needsUpdate = k);
    }
    function Nh(E) {
      return (
        E.isMeshLambertMaterial ||
        E.isMeshToonMaterial ||
        E.isMeshPhongMaterial ||
        E.isMeshStandardMaterial ||
        E.isShadowMaterial ||
        (E.isShaderMaterial && E.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return v;
    }),
      (this.getActiveMipmapLevel = function () {
        return x;
      }),
      (this.getRenderTarget = function () {
        return S;
      }),
      (this.setRenderTargetTextures = function (E, k, W) {
        (pe.get(E.texture).__webglTexture = k),
          (pe.get(E.depthTexture).__webglTexture = W);
        const F = pe.get(E);
        (F.__hasExternalTextures = !0),
          F.__hasExternalTextures &&
            ((F.__autoAllocateDepthBuffer = W === void 0),
            F.__autoAllocateDepthBuffer ||
              (Me.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (F.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (E, k) {
        const W = pe.get(E);
        (W.__webglFramebuffer = k), (W.__useDefaultFramebuffer = k === void 0);
      }),
      (this.setRenderTarget = function (E, k = 0, W = 0) {
        (S = E), (v = k), (x = W);
        let F = !0,
          j = null,
          _e = !1,
          Se = !1;
        if (E) {
          const Ee = pe.get(E);
          Ee.__useDefaultFramebuffer !== void 0
            ? (xe.bindFramebuffer(36160, null), (F = !1))
            : Ee.__webglFramebuffer === void 0
            ? Re.setupRenderTarget(E)
            : Ee.__hasExternalTextures &&
              Re.rebindTextures(
                E,
                pe.get(E.texture).__webglTexture,
                pe.get(E.depthTexture).__webglTexture
              );
          const Ce = E.texture;
          (Ce.isData3DTexture ||
            Ce.isDataArrayTexture ||
            Ce.isCompressedArrayTexture) &&
            (Se = !0);
          const Pe = pe.get(E).__webglFramebuffer;
          E.isWebGLCubeRenderTarget
            ? ((j = Pe[k]), (_e = !0))
            : se.isWebGL2 && E.samples > 0 && Re.useMultisampledRTT(E) === !1
            ? (j = pe.get(E).__webglMultisampledFramebuffer)
            : (j = Pe),
            C.copy(E.viewport),
            M.copy(E.scissor),
            (b = E.scissorTest);
        } else
          C.copy(H).multiplyScalar(P).floor(),
            M.copy(Y).multiplyScalar(P).floor(),
            (b = B);
        if (
          (xe.bindFramebuffer(36160, j) &&
            se.drawBuffers &&
            F &&
            xe.drawBuffers(E, j),
          xe.viewport(C),
          xe.scissor(M),
          xe.setScissorTest(b),
          _e)
        ) {
          const Ee = pe.get(E.texture);
          z.framebufferTexture2D(36160, 36064, 34069 + k, Ee.__webglTexture, W);
        } else if (Se) {
          const Ee = pe.get(E.texture),
            Ce = k || 0;
          z.framebufferTextureLayer(
            36160,
            36064,
            Ee.__webglTexture,
            W || 0,
            Ce
          );
        }
        w = -1;
      }),
      (this.readRenderTargetPixels = function (E, k, W, F, j, _e, Se) {
        if (!(E && E.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let be = pe.get(E).__webglFramebuffer;
        if ((E.isWebGLCubeRenderTarget && Se !== void 0 && (be = be[Se]), be)) {
          xe.bindFramebuffer(36160, be);
          try {
            const Ee = E.texture,
              Ce = Ee.format,
              Pe = Ee.type;
            if (Ce !== cn && X.convert(Ce) !== z.getParameter(35739)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const De =
              Pe === Ls &&
              (Me.has("EXT_color_buffer_half_float") ||
                (se.isWebGL2 && Me.has("EXT_color_buffer_float")));
            if (
              Pe !== Zi &&
              X.convert(Pe) !== z.getParameter(35738) &&
              !(
                Pe === mi &&
                (se.isWebGL2 ||
                  Me.has("OES_texture_float") ||
                  Me.has("WEBGL_color_buffer_float"))
              ) &&
              !De
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            k >= 0 &&
              k <= E.width - F &&
              W >= 0 &&
              W <= E.height - j &&
              z.readPixels(k, W, F, j, X.convert(Ce), X.convert(Pe), _e);
          } finally {
            const Ee = S !== null ? pe.get(S).__webglFramebuffer : null;
            xe.bindFramebuffer(36160, Ee);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (E, k, W = 0) {
        const F = Math.pow(2, -W),
          j = Math.floor(k.image.width * F),
          _e = Math.floor(k.image.height * F);
        Re.setTexture2D(k, 0),
          z.copyTexSubImage2D(3553, W, 0, 0, E.x, E.y, j, _e),
          xe.unbindTexture();
      }),
      (this.copyTextureToTexture = function (E, k, W, F = 0) {
        const j = k.image.width,
          _e = k.image.height,
          Se = X.convert(W.format),
          be = X.convert(W.type);
        Re.setTexture2D(W, 0),
          z.pixelStorei(37440, W.flipY),
          z.pixelStorei(37441, W.premultiplyAlpha),
          z.pixelStorei(3317, W.unpackAlignment),
          k.isDataTexture
            ? z.texSubImage2D(3553, F, E.x, E.y, j, _e, Se, be, k.image.data)
            : k.isCompressedTexture
            ? z.compressedTexSubImage2D(
                3553,
                F,
                E.x,
                E.y,
                k.mipmaps[0].width,
                k.mipmaps[0].height,
                Se,
                k.mipmaps[0].data
              )
            : z.texSubImage2D(3553, F, E.x, E.y, Se, be, k.image),
          F === 0 && W.generateMipmaps && z.generateMipmap(3553),
          xe.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (E, k, W, F, j = 0) {
        if (p.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const _e = E.max.x - E.min.x + 1,
          Se = E.max.y - E.min.y + 1,
          be = E.max.z - E.min.z + 1,
          Ee = X.convert(F.format),
          Ce = X.convert(F.type);
        let Pe;
        if (F.isData3DTexture) Re.setTexture3D(F, 0), (Pe = 32879);
        else if (F.isDataArrayTexture) Re.setTexture2DArray(F, 0), (Pe = 35866);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        z.pixelStorei(37440, F.flipY),
          z.pixelStorei(37441, F.premultiplyAlpha),
          z.pixelStorei(3317, F.unpackAlignment);
        const De = z.getParameter(3314),
          We = z.getParameter(32878),
          Pt = z.getParameter(3316),
          hn = z.getParameter(3315),
          Ti = z.getParameter(32877),
          at = W.isCompressedTexture ? W.mipmaps[0] : W.image;
        z.pixelStorei(3314, at.width),
          z.pixelStorei(32878, at.height),
          z.pixelStorei(3316, E.min.x),
          z.pixelStorei(3315, E.min.y),
          z.pixelStorei(32877, E.min.z),
          W.isDataTexture || W.isData3DTexture
            ? z.texSubImage3D(Pe, j, k.x, k.y, k.z, _e, Se, be, Ee, Ce, at.data)
            : W.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              z.compressedTexSubImage3D(
                Pe,
                j,
                k.x,
                k.y,
                k.z,
                _e,
                Se,
                be,
                Ee,
                at.data
              ))
            : z.texSubImage3D(Pe, j, k.x, k.y, k.z, _e, Se, be, Ee, Ce, at),
          z.pixelStorei(3314, De),
          z.pixelStorei(32878, We),
          z.pixelStorei(3316, Pt),
          z.pixelStorei(3315, hn),
          z.pixelStorei(32877, Ti),
          j === 0 && F.generateMipmaps && z.generateMipmap(Pe),
          xe.unbindTexture();
      }),
      (this.initTexture = function (E) {
        E.isCubeTexture
          ? Re.setTextureCube(E, 0)
          : E.isData3DTexture
          ? Re.setTexture3D(E, 0)
          : E.isDataArrayTexture || E.isCompressedArrayTexture
          ? Re.setTexture2DArray(E, 0)
          : Re.setTexture2D(E, 0),
          xe.unbindTexture();
      }),
      (this.resetState = function () {
        (v = 0), (x = 0), (S = null), xe.reset(), fe.reset();
      }),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
}
class aM extends Sh {}
aM.prototype.isWebGL1Renderer = !0;
class Ql {
  constructor(e, t = 1, n = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Te(e)),
      (this.near = t),
      (this.far = n);
  }
  clone() {
    return new Ql(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class oM extends Qe {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e);
  }
}
class lM {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = pl),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = vn());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Rt = new N();
class ec {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Rt.fromBufferAttribute(this, t),
        Rt.applyMatrix4(e),
        this.setXYZ(t, Rt.x, Rt.y, Rt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Rt.fromBufferAttribute(this, t),
        Rt.applyNormalMatrix(e),
        this.setXYZ(t, Rt.x, Rt.y, Rt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Rt.fromBufferAttribute(this, t),
        Rt.transformDirection(e),
        this.setXYZ(t, Rt.x, Rt.y, Rt.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = qn(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Xe(t, this.array)), (n = Xe(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array)),
        (r = Xe(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = r),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
      }
      return new Nt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new ec(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const Zu = new N(),
  Ju = new Ye(),
  Qu = new Ye(),
  cM = new N(),
  ed = new Le(),
  Sr = new N();
class uM extends Jt {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Le()),
      (this.bindMatrixInverse = new Le()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Jn()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      Sr.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, Sr),
        this.boundingBox.expandByPoint(Sr);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Qn()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      Sr.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, Sr),
        this.boundingSphere.expandByPoint(Sr);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Ye(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    Ju.fromBufferAttribute(i.attributes.skinIndex, e),
      Qu.fromBufferAttribute(i.attributes.skinWeight, e),
      Zu.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const a = Qu.getComponent(r);
      if (a !== 0) {
        const o = Ju.getComponent(r);
        ed.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]),
          t.addScaledVector(cM.copy(Zu).applyMatrix4(ed), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class Mh extends Qe {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class dM extends yt {
  constructor(e = null, t = 1, n = 1, i, r, a, o, l, c = gt, u = gt, d, f) {
    super(null, a, o, l, c, u, i, r, d, f),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const td = new Le(),
  fM = new Le();
class tc {
  constructor(e = [], t = []) {
    (this.uuid = vn()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new Le());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Le();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let r = 0, a = e.length; r < a; r++) {
      const o = e[r] ? e[r].matrixWorld : fM;
      td.multiplyMatrices(o, t[r]), td.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new tc(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = rh(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new dM(t, e, e, cn, mi);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let a = t[r];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", r),
        (a = new Mh())),
        this.bones.push(a),
        this.boneInverses.push(new Le().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const o = n[i];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class nd extends Nt {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Mr = new Le(),
  id = new Le(),
  da = [],
  rd = new Jn(),
  hM = new Le(),
  as = new Jt(),
  os = new Qn();
class pM extends Jt {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new nd(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, hM);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Jn()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Mr),
        rd.copy(e.boundingBox).applyMatrix4(Mr),
        this.boundingBox.union(rd);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Qn()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Mr),
        os.copy(e.boundingSphere).applyMatrix4(Mr),
        this.boundingSphere.union(os);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((as.geometry = this.geometry),
      (as.material = this.material),
      as.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        os.copy(this.boundingSphere),
        os.applyMatrix4(n),
        e.ray.intersectsSphere(os) !== !1))
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Mr),
          id.multiplyMatrices(n, Mr),
          (as.matrixWorld = id),
          as.raycast(e, da);
        for (let a = 0, o = da.length; a < o; a++) {
          const l = da[a];
          (l.instanceId = r), (l.object = this), t.push(l);
        }
        da.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new nd(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class bh extends Pn {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Te(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const sd = new N(),
  ad = new N(),
  od = new Le(),
  Bo = new Ba(),
  fa = new Qn();
class nc extends Qe {
  constructor(e = new Rn(), t = new bh()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, r = t.count; i < r; i++)
        sd.fromBufferAttribute(t, i - 1),
          ad.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += sd.distanceTo(ad));
      e.setAttribute("lineDistance", new Yn(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Line.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      fa.copy(n.boundingSphere),
      fa.applyMatrix4(i),
      (fa.radius += r),
      e.ray.intersectsSphere(fa) === !1)
    )
      return;
    od.copy(i).invert(), Bo.copy(e.ray).applyMatrix4(od);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = new N(),
      u = new N(),
      d = new N(),
      f = new N(),
      h = this.isLineSegments ? 2 : 1,
      _ = n.index,
      g = n.attributes.position;
    if (_ !== null) {
      const p = Math.max(0, a.start),
        y = Math.min(_.count, a.start + a.count);
      for (let v = p, x = y - 1; v < x; v += h) {
        const S = _.getX(v),
          w = _.getX(v + 1);
        if (
          (c.fromBufferAttribute(g, S),
          u.fromBufferAttribute(g, w),
          Bo.distanceSqToSegment(c, u, f, d) > l)
        )
          continue;
        f.applyMatrix4(this.matrixWorld);
        const C = e.ray.origin.distanceTo(f);
        C < e.near ||
          C > e.far ||
          t.push({
            distance: C,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const p = Math.max(0, a.start),
        y = Math.min(g.count, a.start + a.count);
      for (let v = p, x = y - 1; v < x; v += h) {
        if (
          (c.fromBufferAttribute(g, v),
          u.fromBufferAttribute(g, v + 1),
          Bo.distanceSqToSegment(c, u, f, d) > l)
        )
          continue;
        f.applyMatrix4(this.matrixWorld);
        const w = e.ray.origin.distanceTo(f);
        w < e.near ||
          w > e.far ||
          t.push({
            distance: w,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = r);
        }
      }
    }
  }
}
const ld = new N(),
  cd = new N();
class mM extends nc {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, r = t.count; i < r; i += 2)
        ld.fromBufferAttribute(t, i),
          cd.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + ld.distanceTo(cd));
      e.setAttribute("lineDistance", new Yn(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class gM extends nc {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class wh extends Pn {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Te(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const ud = new Le(),
  vl = new Ba(),
  ha = new Qn(),
  pa = new N();
class _M extends Qe {
  constructor(e = new Rn(), t = new wh()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = e.params.Points.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      ha.copy(n.boundingSphere),
      ha.applyMatrix4(i),
      (ha.radius += r),
      e.ray.intersectsSphere(ha) === !1)
    )
      return;
    ud.copy(i).invert(), vl.copy(e.ray).applyMatrix4(ud);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = n.index,
      d = n.attributes.position;
    if (c !== null) {
      const f = Math.max(0, a.start),
        h = Math.min(c.count, a.start + a.count);
      for (let _ = f, m = h; _ < m; _++) {
        const g = c.getX(_);
        pa.fromBufferAttribute(d, g), dd(pa, g, l, i, e, t, this);
      }
    } else {
      const f = Math.max(0, a.start),
        h = Math.min(d.count, a.start + a.count);
      for (let _ = f, m = h; _ < m; _++)
        pa.fromBufferAttribute(d, _), dd(pa, _, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = r);
        }
      }
    }
  }
}
function dd(s, e, t, n, i, r, a) {
  const o = vl.distanceSqToPoint(s);
  if (o < t) {
    const l = new N();
    vl.closestPointToPoint(s, l), l.applyMatrix4(n);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    r.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a,
    });
  }
}
class ic extends Pn {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Te(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Te(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = nh),
      (this.normalScale = new Ne(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ir extends ic {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ne(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return wt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Te(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Te(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Te(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function si(s, e, t) {
  return Th(s)
    ? new s.constructor(s.subarray(e, t !== void 0 ? t : s.length))
    : s.slice(e, t);
}
function ma(s, e, t) {
  return !s || (!t && s.constructor === e)
    ? s
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(s)
    : Array.prototype.slice.call(s);
}
function Th(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function vM(s) {
  function e(i, r) {
    return s[i] - s[r];
  }
  const t = s.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function fd(s, e, t) {
  const n = s.length,
    i = new s.constructor(n);
  for (let r = 0, a = 0; a !== n; ++r) {
    const o = t[r] * e;
    for (let l = 0; l !== e; ++l) i[a++] = s[o + l];
  }
  return i;
}
function Eh(s, e, t, n) {
  let i = 1,
    r = s[0];
  for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
  if (r === void 0) return;
  let a = r[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = r[n]),
          a !== void 0 && (e.push(r.time), t.push.apply(t, a)),
          (r = s[i++]);
      while (r !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = r[n]),
          a !== void 0 && (e.push(r.time), a.toArray(t, t.length)),
          (r = s[i++]);
      while (r !== void 0);
    else
      do (a = r[n]), a !== void 0 && (e.push(r.time), t.push(a)), (r = s[i++]);
      while (r !== void 0);
}
class ks {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      r = t[n - 1];
    n: {
      e: {
        let a;
        t: {
          i: if (!(e < i)) {
            for (let o = n + 2; ; ) {
              if (i === void 0) {
                if (e < r) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === o) break;
              if (((r = i), (i = t[++n]), e < i)) break e;
            }
            a = t.length;
            break t;
          }
          if (!(e >= r)) {
            const o = t[1];
            e < o && ((n = 2), (r = o));
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === l) break;
              if (((i = r), (r = t[--n - 1]), e >= r)) break e;
            }
            (a = n), (n = 0);
            break t;
          }
          break n;
        }
        for (; n < a; ) {
          const o = (n + a) >>> 1;
          e < t[o] ? (a = o) : (n = o + 1);
        }
        if (((i = t[n]), (r = t[n - 1]), r === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i;
    for (let a = 0; a !== i; ++a) t[a] = n[r + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class xM extends ks {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: uu, endingEnd: uu });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2,
      a = e + 1,
      o = i[r],
      l = i[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case du:
          (r = e), (o = 2 * t - n);
          break;
        case fu:
          (r = i.length - 2), (o = t + i[r] - i[r + 1]);
          break;
        default:
          (r = e), (o = n);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case du:
          (a = e), (l = 2 * n - t);
          break;
        case fu:
          (a = 1), (l = n + i[1] - i[0]);
          break;
        default:
          (a = e - 1), (l = t);
      }
    const c = (n - t) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (t - o)),
      (this._weightNext = c / (l - n)),
      (this._offsetPrev = r * u),
      (this._offsetNext = a * u);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      u = this._offsetPrev,
      d = this._offsetNext,
      f = this._weightPrev,
      h = this._weightNext,
      _ = (n - t) / (i - t),
      m = _ * _,
      g = m * _,
      p = -f * g + 2 * f * m - f * _,
      y = (1 + f) * g + (-1.5 - 2 * f) * m + (-0.5 + f) * _ + 1,
      v = (-1 - h) * g + (1.5 + h) * m + 0.5 * _,
      x = h * g - h * m;
    for (let S = 0; S !== o; ++S)
      r[S] = p * a[u + S] + y * a[c + S] + v * a[l + S] + x * a[d + S];
    return r;
  }
}
class yM extends ks {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      u = (n - t) / (i - t),
      d = 1 - u;
    for (let f = 0; f !== o; ++f) r[f] = a[c + f] * d + a[l + f] * u;
    return r;
  }
}
class SM extends ks {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Dn {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = ma(t, this.TimeBufferType)),
      (this.values = ma(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: ma(e.times, Array),
        values: ma(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new SM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new yM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new xM(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Rs:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Xr:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case _o:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Rs;
      case this.InterpolantFactoryMethodLinear:
        return Xr;
      case this.InterpolantFactoryMethodSmooth:
        return _o;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let r = 0,
      a = i - 1;
    for (; r !== i && n[r] < e; ) ++r;
    for (; a !== -1 && n[a] > t; ) --a;
    if ((++a, r !== 0 || a !== i)) {
      r >= a && ((a = Math.max(a, 1)), (r = a - 1));
      const o = this.getValueSize();
      (this.times = si(n, r, a)), (this.values = si(this.values, r * o, a * o));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      r = n.length;
    r === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let o = 0; o !== r; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          o,
          l
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a),
          (e = !1);
        break;
      }
      a = l;
    }
    if (i !== void 0 && Th(i))
      for (let o = 0, l = i.length; o !== l; ++o) {
        const c = i[o];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            o,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = si(this.times),
      t = si(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === _o,
      r = e.length - 1;
    let a = 1;
    for (let o = 1; o < r; ++o) {
      let l = !1;
      const c = e[o],
        u = e[o + 1];
      if (c !== u && (o !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const d = o * n,
            f = d - n,
            h = d + n;
          for (let _ = 0; _ !== n; ++_) {
            const m = t[d + _];
            if (m !== t[f + _] || m !== t[h + _]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const d = o * n,
            f = a * n;
          for (let h = 0; h !== n; ++h) t[f + h] = t[d + h];
        }
        ++a;
      }
    }
    if (r > 0) {
      e[a] = e[r];
      for (let o = r * n, l = a * n, c = 0; c !== n; ++c) t[l + c] = t[o + c];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = si(e, 0, a)), (this.values = si(t, 0, a * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = si(this.times, 0),
      t = si(this.values, 0),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Dn.prototype.TimeBufferType = Float32Array;
Dn.prototype.ValueBufferType = Float32Array;
Dn.prototype.DefaultInterpolation = Xr;
class Jr extends Dn {}
Jr.prototype.ValueTypeName = "bool";
Jr.prototype.ValueBufferType = Array;
Jr.prototype.DefaultInterpolation = Rs;
Jr.prototype.InterpolantFactoryMethodLinear = void 0;
Jr.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ah extends Dn {}
Ah.prototype.ValueTypeName = "color";
class Os extends Dn {}
Os.prototype.ValueTypeName = "number";
class MM extends ks {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = (n - t) / (i - t);
    let c = e * o;
    for (let u = c + o; c !== u; c += 4) wi.slerpFlat(r, 0, a, c - o, a, c, l);
    return r;
  }
}
class tr extends Dn {
  InterpolantFactoryMethodLinear(e) {
    return new MM(this.times, this.values, this.getValueSize(), e);
  }
}
tr.prototype.ValueTypeName = "quaternion";
tr.prototype.DefaultInterpolation = Xr;
tr.prototype.InterpolantFactoryMethodSmooth = void 0;
class Qr extends Dn {}
Qr.prototype.ValueTypeName = "string";
Qr.prototype.ValueBufferType = Array;
Qr.prototype.DefaultInterpolation = Rs;
Qr.prototype.InterpolantFactoryMethodLinear = void 0;
Qr.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ns extends Dn {}
Ns.prototype.ValueTypeName = "vector";
class bM {
  constructor(e, t = -1, n, i = z_) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = vn()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a) t.push(TM(n[a]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return (r.uuid = e.uuid), r;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let r = 0, a = n.length; r !== a; ++r) t.push(Dn.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length,
      a = [];
    for (let o = 0; o < r; o++) {
      let l = [],
        c = [];
      l.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
      const u = vM(l);
      (l = fd(l, 1, u)),
        (c = fd(c, 1, u)),
        !i && l[0] === 0 && (l.push(r), c.push(c[0])),
        a.push(
          new Os(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / n)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        u = c.name.match(r);
      if (u && u.length > 1) {
        const d = u[1];
        let f = i[d];
        f || (i[d] = f = []), f.push(c);
      }
    }
    const a = [];
    for (const o in i)
      a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (d, f, h, _, m) {
        if (h.length !== 0) {
          const g = [],
            p = [];
          Eh(h, g, p, _), g.length !== 0 && m.push(new d(f, g, p));
        }
      },
      i = [],
      r = e.name || "default",
      a = e.fps || 30,
      o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const f = c[d].keys;
      if (!(!f || f.length === 0))
        if (f[0].morphTargets) {
          const h = {};
          let _;
          for (_ = 0; _ < f.length; _++)
            if (f[_].morphTargets)
              for (let m = 0; m < f[_].morphTargets.length; m++)
                h[f[_].morphTargets[m]] = -1;
          for (const m in h) {
            const g = [],
              p = [];
            for (let y = 0; y !== f[_].morphTargets.length; ++y) {
              const v = f[_];
              g.push(v.time), p.push(v.morphTarget === m ? 1 : 0);
            }
            i.push(new Os(".morphTargetInfluence[" + m + "]", g, p));
          }
          l = h.length * a;
        } else {
          const h = ".bones[" + t[d].name + "]";
          n(Ns, h + ".position", f, "pos", i),
            n(tr, h + ".quaternion", f, "rot", i),
            n(Ns, h + ".scale", f, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(r, l, i, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function wM(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Os;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Ns;
    case "color":
      return Ah;
    case "quaternion":
      return tr;
    case "bool":
    case "boolean":
      return Jr;
    case "string":
      return Qr;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function TM(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = wM(s.type);
  if (s.times === void 0) {
    const t = [],
      n = [];
    Eh(s.keys, t, n, "value"), (s.times = t), (s.values = n);
  }
  return e.parse !== void 0
    ? e.parse(s)
    : new e(s.name, s.times, s.values, s.interpolation);
}
const $r = {
  enabled: !1,
  files: {},
  add: function (s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function (s) {
    if (this.enabled !== !1) return this.files[s];
  },
  remove: function (s) {
    delete this.files[s];
  },
  clear: function () {
    this.files = {};
  },
};
class EM {
  constructor(e, t, n) {
    const i = this;
    let r = !1,
      a = 0,
      o = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (u) {
        o++, r === !1 && i.onStart !== void 0 && i.onStart(u, a, o), (r = !0);
      }),
      (this.itemEnd = function (u) {
        a++,
          i.onProgress !== void 0 && i.onProgress(u, a, o),
          a === o && ((r = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, d) {
        return c.push(u, d), this;
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let d = 0, f = c.length; d < f; d += 2) {
          const h = c[d],
            _ = c[d + 1];
          if ((h.global && (h.lastIndex = 0), h.test(u))) return _;
        }
        return null;
      });
  }
}
const AM = new EM();
class zs {
  constructor(e) {
    (this.manager = e !== void 0 ? e : AM),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const zn = {};
class CM extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Ch extends zs {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = $r.get(e);
    if (r !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(r), this.manager.itemEnd(e);
        }, 0),
        r
      );
    if (zn[e] !== void 0) {
      zn[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (zn[e] = []), zn[e].push({ onLoad: t, onProgress: n, onError: i });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      o = this.mimeType,
      l = this.responseType;
    fetch(a)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream == "undefined" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = zn[e],
            d = c.body.getReader(),
            f = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            h = f ? parseInt(f) : 0,
            _ = h !== 0;
          let m = 0;
          const g = new ReadableStream({
            start(p) {
              y();
              function y() {
                d.read().then(({ done: v, value: x }) => {
                  if (v) p.close();
                  else {
                    m += x.byteLength;
                    const S = new ProgressEvent("progress", {
                      lengthComputable: _,
                      loaded: m,
                      total: h,
                    });
                    for (let w = 0, A = u.length; w < A; w++) {
                      const C = u[w];
                      C.onProgress && C.onProgress(S);
                    }
                    p.enqueue(x), y();
                  }
                });
              }
            },
          });
          return new Response(g);
        } else
          throw new CM(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, o));
          case "json":
            return c.json();
          default:
            if (o === void 0) return c.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(o),
                f = d && d[1] ? d[1].toLowerCase() : void 0,
                h = new TextDecoder(f);
              return c.arrayBuffer().then((_) => h.decode(_));
            }
        }
      })
      .then((c) => {
        $r.add(e, c);
        const u = zn[e];
        delete zn[e];
        for (let d = 0, f = u.length; d < f; d++) {
          const h = u[d];
          h.onLoad && h.onLoad(c);
        }
      })
      .catch((c) => {
        const u = zn[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete zn[e];
        for (let d = 0, f = u.length; d < f; d++) {
          const h = u[d];
          h.onError && h.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class PM extends zs {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      a = $r.get(e);
    if (a !== void 0)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), r.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = Is("img");
    function l() {
      u(), $r.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function c(d) {
      u(), i && i(d), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function u() {
      o.removeEventListener("load", l, !1),
        o.removeEventListener("error", c, !1);
    }
    return (
      o.addEventListener("load", l, !1),
      o.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      r.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class Ph extends zs {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new yt(),
      a = new PM(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (o) {
          (r.image = o), (r.needsUpdate = !0), t !== void 0 && t(r);
        },
        n,
        i
      ),
      r
    );
  }
}
class Wa extends Qe {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Te(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
const Vo = new Le(),
  hd = new N(),
  pd = new N();
class rc {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ne(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Le()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Kl()),
      (this._frameExtents = new Ne(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Ye(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    hd.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(hd),
      pd.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(pd),
      t.updateMatrixWorld(),
      Vo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Vo),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(Vo);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class LM extends rc {
  constructor() {
    super(new It(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = jr * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = r), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class RM extends Wa {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Qe.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Qe()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = r),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new LM());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const md = new Le(),
  ls = new N(),
  Go = new N();
class DM extends rc {
  constructor() {
    super(new It(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ne(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Ye(2, 1, 1, 1),
        new Ye(0, 1, 1, 1),
        new Ye(3, 1, 1, 1),
        new Ye(1, 1, 1, 1),
        new Ye(3, 0, 1, 1),
        new Ye(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new N(1, 0, 0),
        new N(-1, 0, 0),
        new N(0, 0, 1),
        new N(0, 0, -1),
        new N(0, 1, 0),
        new N(0, -1, 0),
      ]),
      (this._cubeUps = [
        new N(0, 1, 0),
        new N(0, 1, 0),
        new N(0, 1, 0),
        new N(0, 1, 0),
        new N(0, 0, 1),
        new N(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      r = e.distance || n.far;
    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
      ls.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(ls),
      Go.copy(n.position),
      Go.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(Go),
      n.updateMatrixWorld(),
      i.makeTranslation(-ls.x, -ls.y, -ls.z),
      md.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(md);
  }
}
class IM extends Wa {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new DM());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class OM extends rc {
  constructor() {
    super(new Zl(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class ms extends Wa {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Qe.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Qe()),
      (this.shadow = new OM());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class NM extends Wa {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class xl {
  static decodeText(e) {
    if (typeof TextDecoder != "undefined") return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class UM extends zs {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap == "undefined" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch == "undefined" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const r = this,
      a = $r.get(e);
    if (a !== void 0)
      return (
        r.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), r.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = {};
    (o.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (o.headers = this.requestHeader),
      fetch(e, o)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(r.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          $r.add(e, l), t && t(l), r.manager.itemEnd(e);
        })
        .catch(function (l) {
          i && i(l), r.manager.itemError(e), r.manager.itemEnd(e);
        }),
      r.manager.itemStart(e);
  }
}
const sc = "\\[\\]\\.:\\/",
  FM = new RegExp("[" + sc + "]", "g"),
  ac = "[^" + sc + "]",
  kM = "[^" + sc.replace("\\.", "") + "]",
  zM = /((?:WC+[\/:])*)/.source.replace("WC", ac),
  BM = /(WCOD+)?/.source.replace("WCOD", kM),
  VM = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ac),
  GM = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ac),
  HM = new RegExp("^" + zM + BM + VM + GM + "$"),
  WM = ["material", "materials", "bones", "map"];
class qM {
  constructor(e, t, n) {
    const i = n || Ge.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Ge {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || Ge.parseTrackName(t)),
      (this.node = Ge.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new Ge.Composite(e, t, n)
      : new Ge(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(FM, "");
  }
  static parseTrackName(e) {
    const t = HM.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      WM.indexOf(r) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (r) {
          for (let a = 0; a < r.length; a++) {
            const o = r[a];
            if (o.name === t || o.uuid === t) return o;
            const l = n(o.children);
            if (l) return l;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let r = t.propertyIndex;
    if (
      (e || ((e = Ge.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let o = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (o = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[r] !== void 0 &&
          (r = e.morphTargetDictionary[r]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = r);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][o]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Ge.Composite = qM;
Ge.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Ge.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Ge.prototype.GetterByBindingType = [
  Ge.prototype._getValue_direct,
  Ge.prototype._getValue_array,
  Ge.prototype._getValue_arrayElement,
  Ge.prototype._getValue_toArray,
];
Ge.prototype.SetterByBindingTypeAndVersioning = [
  [
    Ge.prototype._setValue_direct,
    Ge.prototype._setValue_direct_setNeedsUpdate,
    Ge.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Ge.prototype._setValue_array,
    Ge.prototype._setValue_array_setNeedsUpdate,
    Ge.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Ge.prototype._setValue_arrayElement,
    Ge.prototype._setValue_arrayElement_setNeedsUpdate,
    Ge.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Ge.prototype._setValue_fromArray,
    Ge.prototype._setValue_fromArray_setNeedsUpdate,
    Ge.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class XM {
  constructor(e, t, n = 0, i = 1 / 0) {
    (this.ray = new Ba(e, t)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new $l()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return yl(e, this, n, t), n.sort(gd), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, r = e.length; i < r; i++) yl(e[i], this, n, t);
    return n.sort(gd), n;
  }
}
function gd(s, e) {
  return s.distance - e.distance;
}
function yl(s, e, t, n) {
  if ((s.layers.test(e.layers) && s.raycast(e, t), n === !0)) {
    const i = s.children;
    for (let r = 0, a = i.length; r < a; r++) yl(i[r], e, t, !0);
  }
}
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: jl } })
  );
typeof window != "undefined" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = jl));
function _d(s, e) {
  if (e === B_)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      s
    );
  if (e === hl || e === th) {
    let t = s.getIndex();
    if (t === null) {
      const a = [],
        o = s.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++) a.push(l);
        s.setIndex(a), (t = s.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          s
        );
    }
    const n = t.count - 2,
      i = [];
    if (e === hl)
      for (let a = 1; a <= n; a++)
        i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0
          ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2)))
          : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const r = s.clone();
    return r.setIndex(i), r.clearGroups(), r;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      s
    );
}
class jM extends zs {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new JM(t);
      }),
      this.register(function (t) {
        return new sb(t);
      }),
      this.register(function (t) {
        return new ab(t);
      }),
      this.register(function (t) {
        return new ob(t);
      }),
      this.register(function (t) {
        return new eb(t);
      }),
      this.register(function (t) {
        return new tb(t);
      }),
      this.register(function (t) {
        return new nb(t);
      }),
      this.register(function (t) {
        return new ib(t);
      }),
      this.register(function (t) {
        return new ZM(t);
      }),
      this.register(function (t) {
        return new rb(t);
      }),
      this.register(function (t) {
        return new QM(t);
      }),
      this.register(function (t) {
        return new $M(t);
      }),
      this.register(function (t) {
        return new lb(t);
      }),
      this.register(function (t) {
        return new cb(t);
      });
  }
  load(e, t, n, i) {
    const r = this;
    let a;
    this.resourcePath !== ""
      ? (a = this.resourcePath)
      : this.path !== ""
      ? (a = this.path)
      : (a = xl.extractUrlBase(e)),
      this.manager.itemStart(e);
    const o = function (c) {
        i ? i(c) : console.error(c),
          r.manager.itemError(e),
          r.manager.itemEnd(e);
      },
      l = new Ch(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            r.parse(
              c,
              a,
              function (u) {
                t(u), r.manager.itemEnd(e);
              },
              o
            );
          } catch (u) {
            o(u);
          }
        },
        n,
        o
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let r;
    const a = {},
      o = {},
      l = new TextDecoder();
    if (typeof e == "string") r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === Lh) {
        try {
          a[ke.KHR_BINARY_GLTF] = new ub(e);
        } catch (d) {
          i && i(d);
          return;
        }
        r = JSON.parse(a[ke.KHR_BINARY_GLTF].content);
      } else r = JSON.parse(l.decode(e));
    else r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new bb(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const d = this.pluginCallbacks[u](c);
      (o[d.name] = d), (a[d.name] = !0);
    }
    if (r.extensionsUsed)
      for (let u = 0; u < r.extensionsUsed.length; ++u) {
        const d = r.extensionsUsed[u],
          f = r.extensionsRequired || [];
        switch (d) {
          case ke.KHR_MATERIALS_UNLIT:
            a[d] = new KM();
            break;
          case ke.KHR_DRACO_MESH_COMPRESSION:
            a[d] = new db(r, this.dracoLoader);
            break;
          case ke.KHR_TEXTURE_TRANSFORM:
            a[d] = new fb();
            break;
          case ke.KHR_MESH_QUANTIZATION:
            a[d] = new hb();
            break;
          default:
            f.indexOf(d) >= 0 &&
              o[d] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function YM() {
  let s = {};
  return {
    get: function (e) {
      return s[e];
    },
    add: function (e, t) {
      s[e] = t;
    },
    remove: function (e) {
      delete s[e];
    },
    removeAll: function () {
      s = {};
    },
  };
}
const ke = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class $M {
  constructor(e) {
    (this.parser = e),
      (this.name = ke.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions &&
        r.extensions[this.name] &&
        r.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const r = t.json,
      l = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const u = new Te(16777215);
    l.color !== void 0 && u.fromArray(l.color);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new ms(u)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new IM(u)), (c.distance = d);
        break;
      case "spot":
        (c = new RM(u)),
          (c.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      ci(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (i = Promise.resolve(c)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      r = n.json.nodes[e],
      o = ((r.extensions && r.extensions[this.name]) || {}).light;
    return o === void 0
      ? null
      : this._loadLight(o).then(function (l) {
          return n._getNodeRef(t.cache, o, l);
        });
  }
}
class KM {
  constructor() {
    this.name = ke.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return gi;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new Te(1, 1, 1)), (e.opacity = 1);
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const a = r.baseColorFactor;
        e.color.fromArray(a), (e.opacity = a[3]);
      }
      r.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", r.baseColorTexture, ze));
    }
    return Promise.all(i);
  }
}
class ZM {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class JM {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      a = i.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            a.clearcoatRoughnessTexture
          )
        ),
      a.clearcoatNormalTexture !== void 0 &&
        (r.push(
          n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
        ),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ne(o, o);
    }
    return Promise.all(r);
  }
}
class QM {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      a = i.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        r.push(
          n.assignTexture(
            t,
            "iridescenceThicknessMap",
            a.iridescenceThicknessTexture
          )
        ),
      Promise.all(r)
    );
  }
}
class eb {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [];
    (t.sheenColor = new Te(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = i.extensions[this.name];
    return (
      a.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(a.sheenColorFactor),
      a.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, ze)),
      a.sheenRoughnessTexture !== void 0 &&
        r.push(
          n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
        ),
      Promise.all(r)
    );
  }
}
class tb {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      a = i.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 &&
        (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
      Promise.all(r)
    );
  }
}
class nb {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      a = i.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const o = a.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Te(o[0], o[1], o[2])), Promise.all(r);
  }
}
class ib {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = i.extensions[this.name];
    return (t.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
  }
}
class rb {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : ir;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const r = [],
      a = i.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Te(o[0], o[1], o[2])),
      a.specularColorTexture !== void 0 &&
        r.push(
          n.assignTexture(t, "specularColorMap", a.specularColorTexture, ze)
        ),
      Promise.all(r)
    );
  }
}
class sb {
  constructor(e) {
    (this.parser = e), (this.name = ke.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const r = i.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, r.source, a);
  }
}
class ab {
  constructor(e) {
    (this.parser = e),
      (this.name = ke.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const a = r.extensions[t],
      o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class ob {
  constructor(e) {
    (this.parser = e),
      (this.name = ke.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[t]) return null;
    const a = r.extensions[t],
      o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class lb {
  constructor(e) {
    (this.name = ke.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        r = this.parser.getDependency("buffer", i.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return r.then(function (o) {
        const l = i.byteOffset || 0,
          c = i.byteLength || 0,
          u = i.count,
          d = i.byteStride,
          f = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync
          ? a
              .decodeGltfBufferAsync(u, d, f, i.mode, i.filter)
              .then(function (h) {
                return h.buffer;
              })
          : a.ready.then(function () {
              const h = new ArrayBuffer(u * d);
              return (
                a.decodeGltfBuffer(
                  new Uint8Array(h),
                  u,
                  d,
                  f,
                  i.mode,
                  i.filter
                ),
                h
              );
            });
      });
    } else return null;
  }
}
class cb {
  constructor(e) {
    (this.name = ke.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const c of i.primitives)
      if (
        c.mode !== an.TRIANGLES &&
        c.mode !== an.TRIANGLE_STRIP &&
        c.mode !== an.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const a = n.extensions[this.name].attributes,
      o = [],
      l = {};
    for (const c in a)
      o.push(
        this.parser
          .getDependency("accessor", a[c])
          .then((u) => ((l[c] = u), l[c]))
      );
    return o.length < 1
      ? null
      : (o.push(this.parser.createNodeMesh(e)),
        Promise.all(o).then((c) => {
          const u = c.pop(),
            d = u.isGroup ? u.children : [u],
            f = c[0].count,
            h = [];
          for (const _ of d) {
            const m = new Le(),
              g = new N(),
              p = new wi(),
              y = new N(1, 1, 1),
              v = new pM(_.geometry, _.material, f);
            for (let x = 0; x < f; x++)
              l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, x),
                l.ROTATION && p.fromBufferAttribute(l.ROTATION, x),
                l.SCALE && y.fromBufferAttribute(l.SCALE, x),
                v.setMatrixAt(x, m.compose(g, p, y));
            for (const x in l)
              x !== "TRANSLATION" &&
                x !== "ROTATION" &&
                x !== "SCALE" &&
                _.geometry.setAttribute(x, l[x]);
            Qe.prototype.copy.call(v, _),
              this.parser.assignFinalMaterial(v),
              h.push(v);
          }
          return u.isGroup ? (u.clear(), u.add(...h), u) : h[0];
        }));
  }
}
const Lh = "glTF",
  cs = 12,
  vd = { JSON: 1313821514, BIN: 5130562 };
class ub {
  constructor(e) {
    (this.name = ke.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, cs),
      n = new TextDecoder();
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== Lh)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - cs,
      r = new DataView(e, cs);
    let a = 0;
    for (; a < i; ) {
      const o = r.getUint32(a, !0);
      a += 4;
      const l = r.getUint32(a, !0);
      if (((a += 4), l === vd.JSON)) {
        const c = new Uint8Array(e, cs + a, o);
        this.content = n.decode(c);
      } else if (l === vd.BIN) {
        const c = cs + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class db {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = ke.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      r = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      o = {},
      l = {},
      c = {};
    for (const u in a) {
      const d = Sl[u] || u.toLowerCase();
      o[d] = a[u];
    }
    for (const u in e.attributes) {
      const d = Sl[u] || u.toLowerCase();
      if (a[u] !== void 0) {
        const f = n.accessors[e.attributes[u]],
          h = Ur[f.componentType];
        (c[d] = h.name), (l[d] = f.normalized === !0);
      }
    }
    return t.getDependency("bufferView", r).then(function (u) {
      return new Promise(function (d) {
        i.decodeDracoFile(
          u,
          function (f) {
            for (const h in f.attributes) {
              const _ = f.attributes[h],
                m = l[h];
              m !== void 0 && (_.normalized = m);
            }
            d(f);
          },
          o,
          c
        );
      });
    });
  }
}
class fb {
  constructor() {
    this.name = ke.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class hb {
  constructor() {
    this.name = ke.KHR_MESH_QUANTIZATION;
  }
}
class Rh extends ks {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = e * i * 3 + i;
    for (let a = 0; a !== i; a++) t[a] = n[r + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = o * 2,
      c = o * 3,
      u = i - t,
      d = (n - t) / u,
      f = d * d,
      h = f * d,
      _ = e * c,
      m = _ - c,
      g = -2 * h + 3 * f,
      p = h - f,
      y = 1 - g,
      v = p - f + d;
    for (let x = 0; x !== o; x++) {
      const S = a[m + x + o],
        w = a[m + x + l] * u,
        A = a[_ + x + o],
        C = a[_ + x] * u;
      r[x] = y * S + v * w + g * A + p * C;
    }
    return r;
  }
}
const pb = new wi();
class mb extends Rh {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return pb.fromArray(r).normalize().toArray(r), r;
  }
}
const an = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Ur = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  xd = { 9728: gt, 9729: Ft, 9984: fl, 9985: Qf, 9986: ya, 9987: Ki },
  yd = { 33071: ln, 33648: Ia, 10497: Wr },
  Ho = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  Sl = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  ai = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  gb = { CUBICSPLINE: void 0, LINEAR: Xr, STEP: Rs },
  Wo = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function _b(s) {
  return (
    s.DefaultMaterial === void 0 &&
      (s.DefaultMaterial = new ic({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Zn,
      })),
    s.DefaultMaterial
  );
}
function us(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function ci(s, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(s.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function vb(s, e, t) {
  let n = !1,
    i = !1,
    r = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const d = e[c];
    if (
      (d.POSITION !== void 0 && (n = !0),
      d.NORMAL !== void 0 && (i = !0),
      d.COLOR_0 !== void 0 && (r = !0),
      n && i && r)
    )
      break;
  }
  if (!n && !i && !r) return Promise.resolve(s);
  const a = [],
    o = [],
    l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const d = e[c];
    if (n) {
      const f =
        d.POSITION !== void 0
          ? t.getDependency("accessor", d.POSITION)
          : s.attributes.position;
      a.push(f);
    }
    if (i) {
      const f =
        d.NORMAL !== void 0
          ? t.getDependency("accessor", d.NORMAL)
          : s.attributes.normal;
      o.push(f);
    }
    if (r) {
      const f =
        d.COLOR_0 !== void 0
          ? t.getDependency("accessor", d.COLOR_0)
          : s.attributes.color;
      l.push(f);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(
    function (c) {
      const u = c[0],
        d = c[1],
        f = c[2];
      return (
        n && (s.morphAttributes.position = u),
        i && (s.morphAttributes.normal = d),
        r && (s.morphAttributes.color = f),
        (s.morphTargetsRelative = !0),
        s
      );
    }
  );
}
function xb(s, e) {
  if ((s.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function yb(s) {
  const e = s.extensions && s.extensions[ke.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + Sd(e.attributes))
      : (t = s.indices + ":" + Sd(s.attributes) + ":" + s.mode),
    t
  );
}
function Sd(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function Ml(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function Sb(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const Mb = new Le();
class bb {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new YM()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      r = -1;
    typeof navigator != "undefined" &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf("Firefox") > -1),
      (r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap == "undefined" || n || (i && r < 98)
        ? (this.textureLoader = new Ph(this.options.manager))
        : (this.textureLoader = new UM(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Ch(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      r = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (a) {
          const o = {
            scene: a[0][i.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          us(r, o, i),
            ci(o, i),
            Promise.all(
              n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(o);
              })
            ).then(function () {
              e(o);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i].joints;
      for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const a = e[i];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      r = (a, o) => {
        const l = this.associations.get(a);
        l != null && this.associations.set(o, l);
        for (const [c, u] of a.children.entries()) r(u, o.children[c]);
      };
    return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (r) {
              return r != this && r.getDependency && r.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (r, a) {
          return n.getDependency(e, a);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[ke.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (r, a) {
      n.load(xl.resolveURL(t.uri, i.path), r, void 0, function () {
        a(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = Ho[i.type],
        o = Ur[i.componentType],
        l = i.normalized === !0,
        c = new o(i.count * a);
      return Promise.resolve(new Nt(c, a, l));
    }
    const r = [];
    return (
      i.bufferView !== void 0
        ? r.push(this.getDependency("bufferView", i.bufferView))
        : r.push(null),
      i.sparse !== void 0 &&
        (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(r).then(function (a) {
        const o = a[0],
          l = Ho[i.type],
          c = Ur[i.componentType],
          u = c.BYTES_PER_ELEMENT,
          d = u * l,
          f = i.byteOffset || 0,
          h =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          _ = i.normalized === !0;
        let m, g;
        if (h && h !== d) {
          const p = Math.floor(f / h),
            y =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              p +
              ":" +
              i.count;
          let v = t.cache.get(y);
          v ||
            ((m = new c(o, p * h, (i.count * h) / u)),
            (v = new lM(m, h / u)),
            t.cache.add(y, v)),
            (g = new ec(v, l, (f % h) / u, _));
        } else o === null ? (m = new c(i.count * l)) : (m = new c(o, f, i.count * l)), (g = new Nt(m, l, _));
        if (i.sparse !== void 0) {
          const p = Ho.SCALAR,
            y = Ur[i.sparse.indices.componentType],
            v = i.sparse.indices.byteOffset || 0,
            x = i.sparse.values.byteOffset || 0,
            S = new y(a[1], v, i.sparse.count * p),
            w = new c(a[2], x, i.sparse.count * l);
          o !== null && (g = new Nt(g.array.slice(), g.itemSize, g.normalized));
          for (let A = 0, C = S.length; A < C; A++) {
            const M = S[A];
            if (
              (g.setX(M, w[A * l]),
              l >= 2 && g.setY(M, w[A * l + 1]),
              l >= 3 && g.setZ(M, w[A * l + 2]),
              l >= 4 && g.setW(M, w[A * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return g;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      r = t.textures[e].source,
      a = t.images[r];
    let o = this.textureLoader;
    if (a.uri) {
      const l = n.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, r, o);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      r = this.json,
      a = r.textures[e],
      o = r.images[t],
      l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, n)
      .then(function (u) {
        (u.flipY = !1),
          (u.name = a.name || o.name || ""),
          u.name === "" &&
            typeof o.uri == "string" &&
            o.uri.startsWith("data:image/") === !1 &&
            (u.name = o.uri);
        const f = (r.samplers || {})[a.sampler] || {};
        return (
          (u.magFilter = xd[f.magFilter] || Ft),
          (u.minFilter = xd[f.minFilter] || Ki),
          (u.wrapS = yd[f.wrapS] || Wr),
          (u.wrapT = yd[f.wrapT] || Wr),
          i.associations.set(u, { textures: e }),
          u
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const a = i.images[e],
      o = self.URL || self.webkitURL;
    let l = a.uri || "",
      c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function (d) {
        c = !0;
        const f = new Blob([d], { type: a.mimeType });
        return (l = o.createObjectURL(f)), l;
      });
    else if (a.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const u = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (f, h) {
          let _ = f;
          t.isImageBitmapLoader === !0 &&
            (_ = function (m) {
              const g = new yt(m);
              (g.needsUpdate = !0), f(g);
            }),
            t.load(xl.resolveURL(d, r.path), _, void 0, h);
        });
      })
      .then(function (d) {
        return (
          c === !0 && o.revokeObjectURL(l),
          (d.userData.mimeType = a.mimeType || Sb(a.uri)),
          d
        );
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d);
      });
    return (this.sourceCache[e] = u), u;
  }
  assignTexture(e, t, n, i) {
    const r = this;
    return this.getDependency("texture", n.index).then(function (a) {
      if (!a) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((a = a.clone()), (a.channel = n.texCoord)),
        r.extensions[ke.KHR_TEXTURE_TRANSFORM])
      ) {
        const o =
          n.extensions !== void 0
            ? n.extensions[ke.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (o) {
          const l = r.associations.get(a);
          (a = r.extensions[ke.KHR_TEXTURE_TRANSFORM].extendTexture(a, o)),
            r.associations.set(a, l);
        }
      }
      return i !== void 0 && (a.encoding = i), (e[t] = a), a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      r = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l ||
        ((l = new wh()),
        Pn.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        (l.sizeAttenuation = !1),
        this.cache.add(o, l)),
        (n = l);
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l ||
        ((l = new bh()),
        Pn.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        this.cache.add(o, l)),
        (n = l);
    }
    if (i || r || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      i && (o += "derivative-tangents:"),
        r && (o += "vertex-colors:"),
        a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l ||
        ((l = n.clone()),
        r && (l.vertexColors = !0),
        a && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(o, l),
        this.associations.set(l, this.associations.get(n))),
        (n = l);
    }
    e.material = n;
  }
  getMaterialType() {
    return ic;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.materials[e];
    let a;
    const o = {},
      l = r.extensions || {},
      c = [];
    if (l[ke.KHR_MATERIALS_UNLIT]) {
      const d = i[ke.KHR_MATERIALS_UNLIT];
      (a = d.getMaterialType()), c.push(d.extendParams(o, r, t));
    } else {
      const d = r.pbrMetallicRoughness || {};
      if (
        ((o.color = new Te(1, 1, 1)),
        (o.opacity = 1),
        Array.isArray(d.baseColorFactor))
      ) {
        const f = d.baseColorFactor;
        o.color.fromArray(f), (o.opacity = f[3]);
      }
      d.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(o, "map", d.baseColorTexture, ze)),
        (o.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (o.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(o, "metalnessMap", d.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(o, "roughnessMap", d.metallicRoughnessTexture)
          )),
        (a = this._invokeOne(function (f) {
          return f.getMaterialType && f.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (f) {
              return f.extendMaterialParams && f.extendMaterialParams(e, o);
            })
          )
        );
    }
    r.doubleSided === !0 && (o.side = wn);
    const u = r.alphaMode || Wo.OPAQUE;
    if (
      (u === Wo.BLEND
        ? ((o.transparent = !0), (o.depthWrite = !1))
        : ((o.transparent = !1),
          u === Wo.MASK &&
            (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
      r.normalTexture !== void 0 &&
        a !== gi &&
        (c.push(t.assignTexture(o, "normalMap", r.normalTexture)),
        (o.normalScale = new Ne(1, 1)),
        r.normalTexture.scale !== void 0))
    ) {
      const d = r.normalTexture.scale;
      o.normalScale.set(d, d);
    }
    return (
      r.occlusionTexture !== void 0 &&
        a !== gi &&
        (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 &&
          (o.aoMapIntensity = r.occlusionTexture.strength)),
      r.emissiveFactor !== void 0 &&
        a !== gi &&
        (o.emissive = new Te().fromArray(r.emissiveFactor)),
      r.emissiveTexture !== void 0 &&
        a !== gi &&
        c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, ze)),
      Promise.all(c).then(function () {
        const d = new a(o);
        return (
          r.name && (d.name = r.name),
          ci(d, r),
          t.associations.set(d, { materials: e }),
          r.extensions && us(i, d, r),
          d
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Ge.sanitizeNodeName(e || "");
    let n = t;
    for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
    return (this.nodeNamesUsed[n] = !0), n;
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function r(o) {
      return n[ke.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(o, t)
        .then(function (l) {
          return Md(l, o, t);
        });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        u = yb(c),
        d = i[u];
      if (d) a.push(d.promise);
      else {
        let f;
        c.extensions && c.extensions[ke.KHR_DRACO_MESH_COMPRESSION]
          ? (f = r(c))
          : (f = Md(new Rn(), c, t)),
          (i[u] = { primitive: c, promise: f }),
          a.push(f);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      r = n.meshes[e],
      a = r.primitives,
      o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const u =
        a[l].material === void 0
          ? _b(this.cache)
          : this.getDependency("material", a[l].material);
      o.push(u);
    }
    return (
      o.push(t.loadGeometries(a)),
      Promise.all(o).then(function (l) {
        const c = l.slice(0, l.length - 1),
          u = l[l.length - 1],
          d = [];
        for (let h = 0, _ = u.length; h < _; h++) {
          const m = u[h],
            g = a[h];
          let p;
          const y = c[h];
          if (
            g.mode === an.TRIANGLES ||
            g.mode === an.TRIANGLE_STRIP ||
            g.mode === an.TRIANGLE_FAN ||
            g.mode === void 0
          )
            (p = r.isSkinnedMesh === !0 ? new uM(m, y) : new Jt(m, y)),
              p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
              g.mode === an.TRIANGLE_STRIP
                ? (p.geometry = _d(p.geometry, th))
                : g.mode === an.TRIANGLE_FAN &&
                  (p.geometry = _d(p.geometry, hl));
          else if (g.mode === an.LINES) p = new mM(m, y);
          else if (g.mode === an.LINE_STRIP) p = new nc(m, y);
          else if (g.mode === an.LINE_LOOP) p = new gM(m, y);
          else if (g.mode === an.POINTS) p = new _M(m, y);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + g.mode
            );
          Object.keys(p.geometry.morphAttributes).length > 0 && xb(p, r),
            (p.name = t.createUniqueName(r.name || "mesh_" + e)),
            ci(p, r),
            g.extensions && us(i, p, g),
            t.assignFinalMaterial(p),
            d.push(p);
        }
        for (let h = 0, _ = d.length; h < _; h++)
          t.associations.set(d[h], { meshes: e, primitives: h });
        if (d.length === 1) return d[0];
        const f = new Xn();
        t.associations.set(f, { meshes: e });
        for (let h = 0, _ = d.length; h < _; h++) f.add(d[h]);
        return f;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new It(
            r0.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (t = new Zl(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      ci(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, r = t.joints.length; i < r; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const r = i.pop(),
          a = i,
          o = [],
          l = [];
        for (let c = 0, u = a.length; c < u; c++) {
          const d = a[c];
          if (d) {
            o.push(d);
            const f = new Le();
            r !== null && f.fromArray(r.array, c * 16), l.push(f);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[c]
            );
        }
        return new tc(o, l);
      })
    );
  }
  loadAnimation(e) {
    const n = this.json.animations[e],
      i = n.name ? n.name : "animation_" + e,
      r = [],
      a = [],
      o = [],
      l = [],
      c = [];
    for (let u = 0, d = n.channels.length; u < d; u++) {
      const f = n.channels[u],
        h = n.samplers[f.sampler],
        _ = f.target,
        m = _.node,
        g = n.parameters !== void 0 ? n.parameters[h.input] : h.input,
        p = n.parameters !== void 0 ? n.parameters[h.output] : h.output;
      _.node !== void 0 &&
        (r.push(this.getDependency("node", m)),
        a.push(this.getDependency("accessor", g)),
        o.push(this.getDependency("accessor", p)),
        l.push(h),
        c.push(_));
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
    ]).then(function (u) {
      const d = u[0],
        f = u[1],
        h = u[2],
        _ = u[3],
        m = u[4],
        g = [];
      for (let p = 0, y = d.length; p < y; p++) {
        const v = d[p],
          x = f[p],
          S = h[p],
          w = _[p],
          A = m[p];
        if (v === void 0) continue;
        v.updateMatrix();
        let C;
        switch (ai[A.path]) {
          case ai.weights:
            C = Os;
            break;
          case ai.rotation:
            C = tr;
            break;
          case ai.position:
          case ai.scale:
          default:
            C = Ns;
            break;
        }
        const M = v.name ? v.name : v.uuid,
          b = w.interpolation !== void 0 ? gb[w.interpolation] : Xr,
          R = [];
        ai[A.path] === ai.weights
          ? v.traverse(function (P) {
              P.morphTargetInfluences && R.push(P.name ? P.name : P.uuid);
            })
          : R.push(M);
        let D = S.array;
        if (S.normalized) {
          const P = Ml(D.constructor),
            I = new Float32Array(D.length);
          for (let U = 0, H = D.length; U < H; U++) I[U] = D[U] * P;
          D = I;
        }
        for (let P = 0, I = R.length; P < I; P++) {
          const U = new C(R[P] + "." + ai[A.path], x.array, D, b);
          w.interpolation === "CUBICSPLINE" &&
            ((U.createInterpolant = function (Y) {
              const B = this instanceof tr ? mb : Rh;
              return new B(this.times, this.values, this.getValueSize() / 3, Y);
            }),
            (U.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            g.push(U);
        }
      }
      return new bM(i, void 0, g);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (r) {
          const a = n._getNodeRef(n.meshCache, i.mesh, r);
          return (
            i.weights !== void 0 &&
              a.traverse(function (o) {
                if (!!o.isMesh)
                  for (let l = 0, c = i.weights.length; l < c; l++)
                    o.morphTargetInfluences[l] = i.weights[l];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      r = n._loadNodeShallow(e),
      a = [],
      o = i.children || [];
    for (let c = 0, u = o.length; c < u; c++)
      a.push(n.getDependency("node", o[c]));
    const l =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", i.skin);
    return Promise.all([r, Promise.all(a), l]).then(function (c) {
      const u = c[0],
        d = c[1],
        f = c[2];
      f !== null &&
        u.traverse(function (h) {
          !h.isSkinnedMesh || h.bind(f, Mb);
        });
      for (let h = 0, _ = d.length; h < _; h++) u.add(d[h]);
      return u;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const r = t.nodes[e],
      a = r.name ? i.createUniqueName(r.name) : "",
      o = [],
      l = i._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && o.push(l),
      r.camera !== void 0 &&
        o.push(
          i.getDependency("camera", r.camera).then(function (c) {
            return i._getNodeRef(i.cameraCache, r.camera, c);
          })
        ),
      i
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          o.push(c);
        }),
      (this.nodeCache[e] = Promise.all(o).then(function (c) {
        let u;
        if (
          (r.isBone === !0
            ? (u = new Mh())
            : c.length > 1
            ? (u = new Xn())
            : c.length === 1
            ? (u = c[0])
            : (u = new Qe()),
          u !== c[0])
        )
          for (let d = 0, f = c.length; d < f; d++) u.add(c[d]);
        if (
          (r.name && ((u.userData.name = r.name), (u.name = a)),
          ci(u, r),
          r.extensions && us(n, u, r),
          r.matrix !== void 0)
        ) {
          const d = new Le();
          d.fromArray(r.matrix), u.applyMatrix4(d);
        } else r.translation !== void 0 && u.position.fromArray(r.translation), r.rotation !== void 0 && u.quaternion.fromArray(r.rotation), r.scale !== void 0 && u.scale.fromArray(r.scale);
        return (
          i.associations.has(u) || i.associations.set(u, {}),
          (i.associations.get(u).nodes = e),
          u
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      r = new Xn();
    n.name && (r.name = i.createUniqueName(n.name)),
      ci(r, n),
      n.extensions && us(t, r, n);
    const a = n.nodes || [],
      o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(i.getDependency("node", a[l]));
    return Promise.all(o).then(function (l) {
      for (let u = 0, d = l.length; u < d; u++) r.add(l[u]);
      const c = (u) => {
        const d = new Map();
        for (const [f, h] of i.associations)
          (f instanceof Pn || f instanceof yt) && d.set(f, h);
        return (
          u.traverse((f) => {
            const h = i.associations.get(f);
            h != null && d.set(f, h);
          }),
          d
        );
      };
      return (i.associations = c(r)), r;
    });
  }
}
function wb(s, e, t) {
  const n = e.attributes,
    i = new Jn();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION],
      l = o.min,
      c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (i.set(new N(l[0], l[1], l[2]), new N(c[0], c[1], c[2])), o.normalized)
      ) {
        const u = Ml(Ur[o.componentType]);
        i.min.multiplyScalar(u), i.max.multiplyScalar(u);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const r = e.targets;
  if (r !== void 0) {
    const o = new N(),
      l = new N();
    for (let c = 0, u = r.length; c < u; c++) {
      const d = r[c];
      if (d.POSITION !== void 0) {
        const f = t.json.accessors[d.POSITION],
          h = f.min,
          _ = f.max;
        if (h !== void 0 && _ !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(h[0]), Math.abs(_[0]))),
            l.setY(Math.max(Math.abs(h[1]), Math.abs(_[1]))),
            l.setZ(Math.max(Math.abs(h[2]), Math.abs(_[2]))),
            f.normalized)
          ) {
            const m = Ml(Ur[f.componentType]);
            l.multiplyScalar(m);
          }
          o.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(o);
  }
  s.boundingBox = i;
  const a = new Qn();
  i.getCenter(a.center),
    (a.radius = i.min.distanceTo(i.max) / 2),
    (s.boundingSphere = a);
}
function Md(s, e, t) {
  const n = e.attributes,
    i = [];
  function r(a, o) {
    return t.getDependency("accessor", a).then(function (l) {
      s.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = Sl[a] || a.toLowerCase();
    o in s.attributes || i.push(r(n[a], o));
  }
  if (e.indices !== void 0 && !s.index) {
    const a = t.getDependency("accessor", e.indices).then(function (o) {
      s.setIndex(o);
    });
    i.push(a);
  }
  return (
    ci(s, e),
    wb(s, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? vb(s, e.targets, t) : s;
    })
  );
}
function Tb() {
  const s = document.querySelector("#helmet"),
    e = new jM(),
    t = new oM();
  t.fog = new Ql(0, 3, 11);
  const n = new It(40, window.innerWidth / window.innerHeight, 1, 50);
  n.position.z = 7;
  let i;
  const r = new Xn();
  t.add(r);
  const a = new Sh({ antialias: !0, alpha: !0, canvas: s });
  (a.shadowMap.enabled = !0),
    (a.shadowMap.type = jf),
    (a.outputColorSpace = "srgb"),
    (a.toneMapping = Zf),
    (a.toneMappingExposure = 4),
    a.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  const o = new NM(16777215, 0.2);
  t.add(o);
  const l = new Xn();
  t.add(l);
  const c = new ms(16777215, 1);
  c.position.set(0, -9, 20),
    (c.castShadow = !0),
    (c.shadow.bias = 0.001),
    (c.shadow.mapSize.width = 4096),
    (c.shadow.mapSize.height = 4096),
    t.add(c);
  const u = new ms(16777215, 0.7);
  u.position.set(-15, -9, 10),
    (u.castShadow = !0),
    (u.shadow.bias = 0.001),
    (u.shadow.mapSize.width = 4096),
    (u.shadow.mapSize.height = 4096),
    t.add(u);
  const d = new ms(16777215, 1);
  d.position.set(0, 10, 15),
    l.add(d),
    new ms(16777215, 1).position.set(0, 10, -15),
    l.add(d);
  const h = new Jt(new Ga(100, 100), new gi({ transparent: !0, opacity: 0 }));
  h.position.set(0, 0, 3), t.add(h);
  const _ = new XM(),
    m = new Ne(0, 0),
    g = new Ne(0, 0);
  window.addEventListener("mousemove", (R) => {
    const D = R.clientX,
      P = R.clientY;
    (g.x = (D / window.innerWidth) * 2 - 1),
      (g.y = (P / window.innerHeight) * 2 - 1);
  }),
    e.load(
      "https://uploads-ssl.webflow.com/653553673268205b9f99f650/6580b084e4ae5621de218603_helmet2.glb.txt",
      (R) => {
        (i = R.scene),
          r.add(i),
          R.scene.traverse((D) => {
            D.isMesh &&
              (D.material.name === "metal"
                ? ((D.material.roughness = 0.2),
                  (D.material.metalness = 0.9),
                  (D.material.normalMap = new Ph().load(
                    "https://uploads-ssl.webflow.com/653553673268205b9f99f650/6580b0706b878ce2c4343293_normalMap.jpeg"
                  )),
                  (D.material.normalScale = new Ne(0.1, 0.1)),
                  (D.castShadow = !0))
                : ((D.material.roughness = 0.1),
                  (D.material.metalness = 0.4),
                  (D.receiveShadow = !0)));
          });
      }
    ),
    p(),
    window.addEventListener("resize", () => p());
  function p() {
    (n.aspect = window.innerWidth / window.innerHeight),
      n.updateProjectionMatrix(),
      a.setSize(window.innerWidth, window.innerHeight);
  }
  y();
  function y(R) {
    if (i) {
      (i.position.y = 0.07 * Math.sin(0.001 * R)), _.setFromCamera(m, n);
      const D = _.intersectObject(h);
      D.length &&
        (i.lookAt(30 * (D[0].uv.x - 0.5), 30 * (0.5 - D[0].uv.y), 5),
        (i.rotation.x -= r.rotation.x),
        (i.rotation.y += r.rotation.y));
    }
    l && (l.rotation.y = 6e-4 * R),
      (m.x += (g.x - m.x) * 0.1),
      (m.y += (g.y - m.y) * 0.1),
      a.render(t, n),
      requestAnimationFrame(y);
  }
  const v = document.querySelectorAll(".transition-1");
  function x() {
    Wn.timeline({})
      .to(t.fog, { duration: 0.5, near: 4 }, 0)
      .to(r.position, { duration: 0.5, x: 0, y: -1.2 }, 0)
      .to(n.position, { duration: 1.5, z: 7, ease: "back.out(1.4)" }, 0)
      .to(
        r.rotation,
        { duration: 2, x: -0.1, y: -0.15, ease: "back.out(2)" },
        0
      );
  }
  v.forEach((R) => {
    R.onclick = x;
  });
  const S = document.querySelectorAll(".transition-2");
  function w() {
    let R = window.innerWidth / window.innerHeight;
    (R = Math.max(1.1, R)),
      (R = Math.min(1.6, R)),
      Wn.timeline({})
        .to(t.fog, { duration: 0.5, near: 1 }, 0)
        .to(r.position, { duration: 0.5, x: R, y: 0 }, 0)
        .to(n.position, { duration: 1.5, z: 4, ease: "power2.out" }, 0)
        .to(
          r.rotation,
          { duration: 1.5, x: 0, y: -0.4, ease: "back.out(4)" },
          0
        );
  }
  S.forEach((R) => (R.onclick = w));
  const A = document.querySelectorAll(".transition-3");
  function C() {
    Wn.timeline({})
      .to(t.fog, { duration: 0.5, near: 6 }, 0)
      .to(r.position, { duration: 0.5, x: 0, y: 0 }, 0)
      .to(n.position, { duration: 1.5, z: 7, ease: "back.out(1.4)" }, 0)
      .to(r.rotation, { duration: 2, x: 0, y: -0.1, ease: "back.out(4)" }, 0);
  }
  A.forEach((R) => (R.onclick = C));
  const M = document.querySelectorAll(".transition-4");
  function b() {
    Wn.timeline({})
      .to(t.fog, { duration: 0.5, near: 3 }, 0)
      .to(r.position, { duration: 1, x: 0, y: 0 }, 0)
      .to(n.position, { duration: 1.4, z: 10, ease: "power1.inOut" }, 0)
      .to(r.rotation, { duration: 1.5, x: 0, y: 0 }, 0);
  }
  return (
    M.forEach((R) => (R.onclick = b)),
    { toFstView: x, toSndView: w, toTrdView: C, toFrthView: b }
  );
}
const { toFstView: Eb, toSndView: Ab, toTrdView: Cb, toFrthView: br } = Tb();
function Dh(s, e) {
  Wn.from(s, { ...e });
}
function bd() {
  $(".copyright-year").text(new Date().getFullYear());
}
function oi(s) {
  window.Webflow &&
    window.Webflow.require &&
    window.Webflow.require("ix2").init(),
    setTimeout(() => {
      if (window.Webflow && window.Webflow.require) {
        const e = window.Webflow.require("forms");
        e && e.ready && e.ready(),
          document.querySelectorAll("form.w-form").forEach((n) => {
            n && typeof n.reset == "function" && n.reset();
          });
      }
    }, 200),
    document.dispatchEvent(new Event("DOMContentLoaded"));
}
function wd() {
  Eb(),
    Dh(".line", {
      yPercent: 100,
      ease: "power1.out",
      duration: 0.8,
      stagger: 0.04,
    });
}
function Td() {
  Ab(),
    Dh(".line", {
      yPercent: 100,
      delay: 0.5,
      ease: "power1.out",
      duration: 0.8,
      stagger: 0.02,
    });
}
function Ed() {
  Cb(),
    $(".details_block").each(function () {
      Wn.from(
        $(this).find(".line"),
        { yPercent: 100, duration: 0.8, stagger: 0.2, ease: "power1.out" },
        "<+=0.5"
      );
    });
}
function Ad(s) {
  Wn.from(".container.cc--portfolio", {
    yPercent: 50,
    duration: 0.8,
    ease: "power1.out",
  });
}
function Cd() {
  $(".portfolio_url").each(function () {
    let e = $(this)
      .text()
      .replace("https://", "")
      .replace("/", "")
      .replace("www.", "")
      .replace("login", "");
    $(this).text(e);
  });
}
ql.init({
  preventCustom: (s, e) =>
    !!(e.tagName === "FORM" || e.hasAttribute("data-no-barba")),
  preventRunning: !0,
  transitions: [
    {
      name: "home",
      to: { namespace: ["home"] },
      once() {
        wd();
      },
      enter() {
        wd();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "about",
      to: { namespace: ["about"] },
      once() {
        Td();
      },
      enter() {
        Td();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "focus",
      to: { namespace: ["focus"] },
      once() {
        Ed();
      },
      enter() {
        Ed();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "portfolio",
      to: { namespace: ["portfolio"] },
      once() {
        Ad(), Cd();
      },
      beforeEnter() {
        Cd();
      },
      enter() {
        Ad();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "team",
      to: { namespace: ["team"] },
      once() {
        Ws();
      },
      beforeEnter() {
        Ws();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "writing",
      to: { namespace: ["writing"] },
      once() {
        br();
      },
      enter() {
        br();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "blog-template",
      to: { namespace: ["blog-template"] },
      once() {
        br();
      },
      enter() {
        br();
      },
      afterEnter() {
        oi();
      },
    },
    {
      name: "contact",
      to: { namespace: ["contact"] },
      once() {
        br(), bd();
      },
      enter() {
        bd(), br();
      },
      afterEnter() {
        oi();
      },
    },
  ],
  views: [
    {
      namespace: "team",
      once() {
        Ws();
      },
      beforeEnter() {
        Ws();
      },
    },
  ],
});
ql.hooks.beforeEnter(() => {
  if (
    window.Webflow &&
    (window.Webflow.destroy && window.Webflow.destroy(),
    window.Webflow.ready && window.Webflow.ready(),
    window.Webflow.require)
  )
    try {
      window.Webflow.require("ix2").init();
      const s = window.Webflow.require("forms");
      s && s.ready && s.ready();
    } catch {}
  document.dispatchEvent(new Event("readystatechange"));
});
ql.hooks.once(() => {
  if (
    window.Webflow &&
    (window.Webflow.destroy && window.Webflow.destroy(),
    window.Webflow.ready && window.Webflow.ready(),
    window.Webflow.require)
  )
    try {
      window.Webflow.require("ix2").init();
      const s = window.Webflow.require("forms");
      s && s.ready && s.ready();
    } catch {}
  document.dispatchEvent(new Event("readystatechange"));
});
